/**
 * Generated by orval v7.9.0 ðŸº
 * Do not edit manually.
 * Fiddl API
 * OpenAPI spec version: 1.0.0
 */
export type ErrorBADREQUESTIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorBADREQUEST {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorBADREQUESTIssuesItem[];
}

export type ErrorUNAUTHORIZEDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorUNAUTHORIZED {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorUNAUTHORIZEDIssuesItem[];
}

export type ErrorFORBIDDENIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorFORBIDDEN {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorFORBIDDENIssuesItem[];
}

export type ErrorINTERNALSERVERERRORIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorINTERNALSERVERERROR {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorINTERNALSERVERERRORIssuesItem[];
}

export type ErrorNOTFOUNDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorNOTFOUND {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorNOTFOUNDIssuesItem[];
}

/**
 * PkAuthRegisterStartIn
 */
export type PkAuthRegisterStartBody = {
  email?: string;
  phone?: string;
  referredByUserName?: string;
};

/**
 * PkAuthRegisterFinishIn
 */
export type PkAuthRegisterFinishBody = {
  userId: string;
  data?: unknown;
};

/**
 * PkAuthLoginStartIn
 */
export type PkAuthLoginStartBody = {
  userId: string;
};

/**
 * PkAuthLoginFinishIn
 */
export type PkAuthLoginFinishBody = {
  userId: string;
  data?: unknown;
};

export type CreateImageBodyModel = typeof CreateImageBodyModel[keyof typeof CreateImageBodyModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreateImageBodyAspectRatio = typeof CreateImageBodyAspectRatio[keyof typeof CreateImageBodyAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

/**
 * CreateImageIn
 */
export type CreateImageBody = {
  prompt: string;
  negativePrompt?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  quantity: number;
  seed?: number;
  model: CreateImageBodyModel;
  public?: boolean;
  aspectRatio?: CreateImageBodyAspectRatio;
  customModelId?: string;
};

/**
 * CreateImageOut
 */
export type CreateImage200 = {
  ids: string[];
  id: string;
  errors: string[];
};

/**
 * CreateRandomPromptIn
 */
export type CreateRandomPromptBody = {
  theme?: string;
};

/**
 * CreateImprovePromptIn
 */
export type CreateImprovePromptBody = {
  prompt: string;
};

export type CreationsImageDataParams = {
imageId: string;
};

/**
 * CreationsImageDataOut
 */
export type CreationsImageData200 = {
  id: string;
  createdAt: string;
  imageRequestId: string;
  seed?: number;
  creatorId: string;
  numCollections: number;
};

export type CreationsUserImagePurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserImagePurchasesOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: CreationsUserImagePurchasesModel;
aspectRatio?: CreationsUserImagePurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserImagePurchasesOrder = typeof CreationsUserImagePurchasesOrder[keyof typeof CreationsUserImagePurchasesOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsUserImagePurchasesModel = typeof CreationsUserImagePurchasesModel[keyof typeof CreationsUserImagePurchasesModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsUserImagePurchasesAspectRatio = typeof CreationsUserImagePurchasesAspectRatio[keyof typeof CreationsUserImagePurchasesAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsUserImagePurchases200Item = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

export type CreationsCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateRequestsOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: CreationsCreateRequestsModel;
aspectRatio?: CreationsCreateRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateRequestsOrder = typeof CreationsCreateRequestsOrder[keyof typeof CreationsCreateRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsCreateRequestsModel = typeof CreationsCreateRequestsModel[keyof typeof CreationsCreateRequestsModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsCreateRequestsAspectRatio = typeof CreationsCreateRequestsAspectRatio[keyof typeof CreationsCreateRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsCreateRequests200Item = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsCreateRequestParams = {
requestId: string;
};

/**
 * CreationsCreateRequestOut
 */
export type CreationsCreateRequest200 = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsBrowseCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsBrowseCreateRequestsOrder;
endDateTime?: string;
promptIncludes?: string;
model?: CreationsBrowseCreateRequestsModel;
aspectRatio?: CreationsBrowseCreateRequestsAspectRatio;
customModelId?: string;
};

export type CreationsBrowseCreateRequestsOrder = typeof CreationsBrowseCreateRequestsOrder[keyof typeof CreationsBrowseCreateRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsBrowseCreateRequestsModel = typeof CreationsBrowseCreateRequestsModel[keyof typeof CreationsBrowseCreateRequestsModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsBrowseCreateRequestsAspectRatio = typeof CreationsBrowseCreateRequestsAspectRatio[keyof typeof CreationsBrowseCreateRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsHdImageParams = {
imageId: string;
};

export type CreationsOriginalImageParams = {
imageId: string;
};

export type CreationsUpscaledImageParams = {
imageId: string;
};

/**
 * CreationsPurchaseImageIn
 */
export type CreationsPurchaseImageBody = {
  imageId: string;
};

/**
 * CreationsPurchaseImageOut
 */
export type CreationsPurchaseImage200 = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

/**
 * CreationsDeleteImageIn
 */
export type CreationsDeleteImageBody = {
  imageId: string;
};

/**
 * CreationsDeleteRequestIn
 */
export type CreationsDeleteRequestBody = {
  requestId: string;
};

/**
 * CreationsSetRequestPrivacyIn
 */
export type CreationsSetRequestPrivacyBody = {
  requestId: string;
  public: boolean;
};

export type PointsPackagesAvailable200Item = {
  points: number;
  discountPct: number;
  usd: number;
};

export type PointsInitBuyPackageBodyMethod = typeof PointsInitBuyPackageBodyMethod[keyof typeof PointsInitBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

/**
 * PointsInitBuyPackageIn
 */
export type PointsInitBuyPackageBody = {
  packageId: number;
  method: PointsInitBuyPackageBodyMethod;
};

export type PointsInitBuyPackage200AnyOfLinksItem = {
  href: string;
  rel: string;
  method: string;
};

export type PointsInitBuyPackage200AnyOf = {
  id: string;
  status: string;
  links: PointsInitBuyPackage200AnyOfLinksItem[];
};

export type PointsInitBuyPackage200AnyOfThreeChainName = typeof PointsInitBuyPackage200AnyOfThreeChainName[keyof typeof PointsInitBuyPackage200AnyOfThreeChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackage200AnyOfThreeTokenType = typeof PointsInitBuyPackage200AnyOfThreeTokenType[keyof typeof PointsInitBuyPackage200AnyOfThreeTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsInitBuyPackage200AnyOfThree = {
  chainName: PointsInitBuyPackage200AnyOfThreeChainName;
  tokenType: PointsInitBuyPackage200AnyOfThreeTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

/**
 * PointsInitBuyPackageOut
 */
export type PointsInitBuyPackage200 = PointsInitBuyPackage200AnyOf | PointsInitBuyPackage200AnyOfThree;

export type PointsFinishBuyPackageBodyMethod = typeof PointsFinishBuyPackageBodyMethod[keyof typeof PointsFinishBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsFinishBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

/**
 * PointsFinishBuyPackageIn
 */
export type PointsFinishBuyPackageBody = {
  orderId: string;
  method: PointsFinishBuyPackageBodyMethod;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount = {
  currency_code: string;
  value: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItem = {
  reference_id: string;
  amount: PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount;
};

export type PointsFinishBuyPackage200AnyOf = {
  id: string;
  status: string;
  purchase_units: PointsFinishBuyPackage200AnyOfPurchaseUnitsItem[];
};

export type PointsFinishBuyPackage200AnyOfFour = {
  status: string;
};

/**
 * PointsFinishBuyPackageOut
 */
export type PointsFinishBuyPackage200 = PointsFinishBuyPackage200AnyOf | PointsFinishBuyPackage200AnyOfFour;

export type PointsGetOrders200PayPalOrdersItem = {
  id: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrders200CryptoOrdersItemChainName = typeof PointsGetOrders200CryptoOrdersItemChainName[keyof typeof PointsGetOrders200CryptoOrdersItemChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrders200CryptoOrdersItemChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrders200CryptoOrdersItem = {
  id: string;
  chainName: PointsGetOrders200CryptoOrdersItemChainName;
  tokenAmount: number;
  usdValue: number;
  confirmed: boolean;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

/**
 * PointsGetOrdersOut
 */
export type PointsGetOrders200 = {
  payPalOrders: PointsGetOrders200PayPalOrdersItem[];
  cryptoOrders: PointsGetOrders200CryptoOrdersItem[];
};

export type PointsGetOrderParams = {
id: string;
method: PointsGetOrderMethod;
};

export type PointsGetOrderMethod = typeof PointsGetOrderMethod[keyof typeof PointsGetOrderMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrderMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOf = {
  id: string;
  userId: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  packageDetailsJSON: string;
  /** @nullable */
  orderDataJSON: string | null;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrder200AnyOfTwoChainName = typeof PointsGetOrder200AnyOfTwoChainName[keyof typeof PointsGetOrder200AnyOfTwoChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOfTwoTokenType = typeof PointsGetOrder200AnyOfTwoTokenType[keyof typeof PointsGetOrder200AnyOfTwoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsGetOrder200AnyOfTwo = {
  chainName: PointsGetOrder200AnyOfTwoChainName;
  tokenType: PointsGetOrder200AnyOfTwoTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

/**
 * PointsGetOrderOut
 */
export type PointsGetOrder200 = PointsGetOrder200AnyOf | PointsGetOrder200AnyOfTwo;

export type UserGetParams = {
userId: string;
};

/**
 * @nullable
 */
export type UserGet200AvatarConfig = {
  imageId: string;
} | null;

/**
 * UserGetOut
 */
export type UserGet200 = {
  id: string;
  /** @nullable */
  privyId: string | null;
  /** @nullable */
  webauthnUserID: string | null;
  /** @nullable */
  currentPassKeyChallenge: string | null;
  admin: boolean;
  availablePoints: number;
  createdAt: string;
  updatedAt: string;
  spentPoints: number;
  /** @nullable */
  referredById: string | null;
  lastNotificationSent: string;
  /** @nullable */
  AvatarConfig: UserGet200AvatarConfig;
};

export type UserProfileParams = {
userId: string;
};

/**
 * UserProfileOut
 */
export type UserProfile200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

export type UserPublicProfileParams = {
userId: string;
};

export type UserPublicProfile200Profile = {
  /** @nullable */
  username: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
};

/**
 * UserPublicProfileOut
 */
export type UserPublicProfile200 = {
  profile: UserPublicProfile200Profile;
  imagesCreated: number;
  imagesFavorited: number;
};

export type UserGetUsernameParams = {
userId: string;
};

/**
 * UserSetUsernameIn
 */
export type UserSetUsernameBody = {
  username: string;
};

/**
 * UserSetUsernameOut
 */
export type UserSetUsername200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

/**
 * UserSetBioIn
 */
export type UserSetBioBody = {
  bio: string;
};

/**
 * UserSetBioOut
 */
export type UserSetBio200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

/**
 * UserSendVerificationEmailIn
 */
export type UserSendVerificationEmailBody = {
  email: string;
};

export type UserPointsHistoryParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: UserPointsHistoryOrder;
endDateTime?: string;
includeMetadata?: boolean;
};

export type UserPointsHistoryOrder = typeof UserPointsHistoryOrder[keyof typeof UserPointsHistoryOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistoryOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UserPointsHistory200ItemType = typeof UserPointsHistory200ItemType[keyof typeof UserPointsHistory200ItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistory200ItemType = {
  purchase: 'purchase',
  refund: 'refund',
  commission: 'commission',
  comission: 'comission',
  bonus: 'bonus',
  referral: 'referral',
  promoCode: 'promoCode',
  createModel: 'createModel',
  cryptoDeposit: 'cryptoDeposit',
} as const;

export type UserPointsHistory200Item = {
  type: UserPointsHistory200ItemType;
  id: string;
  createdAt: string;
  /** @nullable */
  memo: string | null;
  quantity: number;
  userFinalBalance: number;
};

export type UserFindByUsernameParams = {
username: string;
};

export type UserFindByEmailParams = {
email: string;
};

export type UserFindByPhoneParams = {
phone: string;
};

export type UserFindByPrivyIdParams = {
privyId: string;
};

export type UserGetNotificationConfig200EmailFrequency = typeof UserGetNotificationConfig200EmailFrequency[keyof typeof UserGetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200PhoneFrequency = typeof UserGetNotificationConfig200PhoneFrequency[keyof typeof UserGetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

/**
 * UserGetNotificationConfigOut
 */
export type UserGetNotificationConfig200 = {
  emailFrequency: UserGetNotificationConfig200EmailFrequency;
  phoneFrequency: UserGetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

export type UserSetNotificationConfigBodyEmailFrequency = typeof UserSetNotificationConfigBodyEmailFrequency[keyof typeof UserSetNotificationConfigBodyEmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyEmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBodyPhoneFrequency = typeof UserSetNotificationConfigBodyPhoneFrequency[keyof typeof UserSetNotificationConfigBodyPhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyPhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

/**
 * UserSetNotificationConfigIn
 */
export type UserSetNotificationConfigBody = {
  email?: boolean;
  phone?: boolean;
  emailFrequency?: UserSetNotificationConfigBodyEmailFrequency;
  phoneFrequency?: UserSetNotificationConfigBodyPhoneFrequency;
};

export type UserSetNotificationConfig200EmailFrequency = typeof UserSetNotificationConfig200EmailFrequency[keyof typeof UserSetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200PhoneFrequency = typeof UserSetNotificationConfig200PhoneFrequency[keyof typeof UserSetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

/**
 * UserSetNotificationConfigOut
 */
export type UserSetNotificationConfig200 = {
  emailFrequency: UserSetNotificationConfig200EmailFrequency;
  phoneFrequency: UserSetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

/**
 * UserUnsubscribeEmailNotificationsIn
 */
export type UserUnsubscribeEmailNotificationsBody = { [key: string]: unknown };

export type UserSetAvatarBodyPosition = {
  x: number;
  y: number;
};

/**
 * UserSetAvatarIn
 */
export type UserSetAvatarBody = {
  imageId: string;
  scale: number;
  position: UserSetAvatarBodyPosition;
};

/**
 * @nullable
 */
export type UserAllUsers200ItemProfile = {
  /** @nullable */
  bio: string | null;
  /** @nullable */
  username: string | null;
} | null;

export type UserAllUsers200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  Profile: UserAllUsers200ItemProfile;
};

/**
 * LoginLinkInitLoginLinkIn
 */
export type LoginLinkInitLoginLinkBody = {
  email?: string;
  phoneNumber?: string;
  referredBy?: string;
};

/**
 * LoginLinkLoginWithLinkIn
 */
export type LoginLinkLoginWithLinkBody = {
  linkId: string;
};

/**
 * LoginLinkLoginWithLinkOut
 */
export type LoginLinkLoginWithLink200 = {
  token: string;
  userId: string;
};

/**
 * StatsUsersOut
 */
export type StatsUsers200 = {
  spentPoints: number;
  spentOver100Points: number;
  spentOver1000Points: number;
  spentOver10000Points: number;
  spentOver20000Points: number;
  purchasedImage: number;
  createdImage: number;
  emailVerified: number;
  phoneVerified: number;
  instagramVerified: number;
  twitterVerified: number;
  setUsername: number;
};

export type _StatsImages200AverageImageQuantityPerCreateRequestAvg = {
  /** @nullable */
  quantity: number | null;
};

export type StatsImages200AverageImageQuantityPerCreateRequest = {
  _avg: _StatsImages200AverageImageQuantityPerCreateRequestAvg;
};

/**
 * StatsImagesOut
 */
export type StatsImages200 = {
  totalCreated: number;
  totalUpscaled: number;
  totalImageCreateRequests: number;
  averageImageQuantityPerCreateRequest: StatsImages200AverageImageQuantityPerCreateRequest;
  purchasedImages: number;
  totalPurchases: number;
  privateImages: number;
  imagesInAtLeastOneCollection: number;
  imageCreationFailed: number;
};

/**
 * StatsCollectionsOut
 */
export type StatsCollections200 = {
  collectionsCreated: number;
  emptyCollections: number;
};

export type _StatsPayments200PaypalOrdersTotalPaidSum = {
  /** @nullable */
  amount: number | null;
};

export type StatsPayments200PaypalOrdersTotalPaid = {
  _sum: _StatsPayments200PaypalOrdersTotalPaidSum;
};

/**
 * StatsPaymentsOut
 */
export type StatsPayments200 = {
  incompletePayPayPalOrders: number;
  completePayPayPalOrders: number;
  paypalOrdersTotalPaid: StatsPayments200PaypalOrdersTotalPaid;
};

export type CollectionsImageInUsersCollectionParams = {
name: string;
imageId: string;
};

/**
 * CollectionsLikeImageIn
 */
export type CollectionsLikeImageBody = {
  imageId: string;
};

/**
 * CollectionsUnlikeImageIn
 */
export type CollectionsUnlikeImageBody = {
  imageId: string;
};

export type CollectionsGetCollectionMetaParams = {
id: string;
};

export type _CollectionsGetCollectionMeta200Count = {
  Images: number;
  Favorited: number;
};

/**
 * CollectionsGetCollectionMetaOut
 */
export type CollectionsGetCollectionMeta200 = {
  id: string;
  name: string;
  description: string;
  ownerId: string;
  private: boolean;
  _count: _CollectionsGetCollectionMeta200Count;
};

export type CollectionsFindCollectionByNameParams = {
ownerId: string;
collectionName: string;
};

/**
 * CollectionsFindCollectionByNameOut
 */
export type CollectionsFindCollectionByName200 = {
  id: string;
};

export type CollectionsGetCollectionImagesParams = {
id: string;
};

export type CollectionsGetCollectionImages200ItemImageRequest = {
  userId: string;
};

export type CollectionsGetCollectionImages200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  imageRequestId: string;
  seed: string;
  errored: boolean;
  filtered: boolean;
  deleted: boolean;
  imageRequest: CollectionsGetCollectionImages200ItemImageRequest;
};

/**
 * PromoCreatePromoCodeIn
 */
export type PromoCreatePromoCodeBody = {
  points: number;
};

/**
 * PromoCreatePromoCodeOut
 */
export type PromoCreatePromoCode200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

/**
 * PromoDeletePromoCodeIn
 */
export type PromoDeletePromoCodeBody = {
  id: string;
};

export type PromoGetPromoCodes200Item = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoGetPromoCodeDetailsParams = {
id: string;
};

/**
 * PromoGetPromoCodeDetailsOut
 */
export type PromoGetPromoCodeDetails200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

/**
 * PromoClaimPromoCodeIn
 */
export type PromoClaimPromoCodeBody = {
  id: string;
};

/**
 * ModelsSetModelNameIn
 */
export type ModelsSetModelNameBody = {
  id: string;
  name: string;
};

export type ModelsGetUserModels200ItemStatus = typeof ModelsGetUserModels200ItemStatus[keyof typeof ModelsGetUserModels200ItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetUserModels200ItemModelType = typeof ModelsGetUserModels200ItemModelType[keyof typeof ModelsGetUserModels200ItemModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
} as const;

export type ModelsGetUserModels200ItemTrainingPreset = typeof ModelsGetUserModels200ItemTrainingPreset[keyof typeof ModelsGetUserModels200ItemTrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemTrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
} as const;

export type ModelsGetUserModels200ItemImageRequestsItemImagesItem = {
  id: string;
};

export type ModelsGetUserModels200ItemImageRequestsItem = {
  id: string;
  images: ModelsGetUserModels200ItemImageRequestsItemImagesItem[];
};

export type ModelsGetUserModels200Item = {
  status: ModelsGetUserModels200ItemStatus;
  modelType: ModelsGetUserModels200ItemModelType;
  trainingPreset: ModelsGetUserModels200ItemTrainingPreset;
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  trainingError: string | null;
  Public: boolean;
  imageRequests: ModelsGetUserModels200ItemImageRequestsItem[];
};

export type ModelsCreateModelBodyType = typeof ModelsCreateModelBodyType[keyof typeof ModelsCreateModelBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyType = {
  faceForge: 'faceForge',
} as const;

export type ModelsCreateModelBodyTrainingPreset = typeof ModelsCreateModelBodyTrainingPreset[keyof typeof ModelsCreateModelBodyTrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyTrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
} as const;

/**
 * ModelsCreateModelIn
 */
export type ModelsCreateModelBody = {
  name: string;
  type: ModelsCreateModelBodyType;
  trainingPreset: ModelsCreateModelBodyTrainingPreset;
};

export type ModelsGetTrainingStatusParams = {
id: string;
};

export type ModelsGetTrainingStatus200Input = {[key: string]: unknown};

export type ModelsGetTrainingStatus200Source = typeof ModelsGetTrainingStatus200Source[keyof typeof ModelsGetTrainingStatus200Source];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetTrainingStatus200Source = {
  api: 'api',
  web: 'web',
} as const;

export type ModelsGetTrainingStatus200Metrics = {
  predict_time?: number;
};

export type ModelsGetTrainingStatus200Urls = {
  get: string;
  cancel: string;
  stream?: string;
};

/**
 * ModelsGetTrainingStatusOut
 */
export type ModelsGetTrainingStatus200 = {
  id: string;
  status: string;
  model: string;
  version: string;
  input: ModelsGetTrainingStatus200Input;
  output?: unknown;
  source: ModelsGetTrainingStatus200Source;
  error?: unknown;
  logs?: string;
  metrics?: ModelsGetTrainingStatus200Metrics;
  webhook?: string;
  webhook_events_filter?: string[];
  created_at: string;
  started_at?: string;
  completed_at?: string;
  urls: ModelsGetTrainingStatus200Urls;
};

/**
 * ModelsDeleteModelIn
 */
export type ModelsDeleteModelBody = {
  id: string;
};

export type ModelsGetModelParams = {
id: string;
};

export type ModelsGetModel200Status = typeof ModelsGetModel200Status[keyof typeof ModelsGetModel200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200Status = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetModel200ModelType = typeof ModelsGetModel200ModelType[keyof typeof ModelsGetModel200ModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200ModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
} as const;

export type ModelsGetModel200TrainingPreset = typeof ModelsGetModel200TrainingPreset[keyof typeof ModelsGetModel200TrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200TrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
} as const;

/**
 * ModelsGetModelOut
 */
export type ModelsGetModel200 = {
  status: ModelsGetModel200Status;
  modelType: ModelsGetModel200ModelType;
  trainingPreset: ModelsGetModel200TrainingPreset;
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  trainingError: string | null;
  Public: boolean;
};

/**
 * ModelsSetModelPrivacyIn
 */
export type ModelsSetModelPrivacyBody = {
  id: string;
  public: boolean;
};

/**
 * AdminLoginAsUserIn
 */
export type AdminLoginAsUserBody = {
  id: string;
};

/**
 * PrivyAuthenticateIn
 */
export type PrivyAuthenticateBody = {
  accessToken: string;
  referrerUsername?: string;
};

/**
 * PrivyAuthenticateOut
 */
export type PrivyAuthenticate200 = {
  token: string;
  userId: string;
};

export type pkAuthRegisterStartResponse200 = {
  data: unknown
  status: 200
}

export type pkAuthRegisterStartResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pkAuthRegisterStartResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pkAuthRegisterStartResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pkAuthRegisterStartResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pkAuthRegisterStartResponseComposite = pkAuthRegisterStartResponse200 | pkAuthRegisterStartResponse400 | pkAuthRegisterStartResponse401 | pkAuthRegisterStartResponse403 | pkAuthRegisterStartResponse500;
    
export type pkAuthRegisterStartResponse = pkAuthRegisterStartResponseComposite & {
  headers: Headers;
}

export const getPkAuthRegisterStartUrl = () => {


  

  return `https://api.fiddl.art/api/pkAuth/registerStart`
}

export const pkAuthRegisterStart = async (pkAuthRegisterStartBody: PkAuthRegisterStartBody, options?: RequestInit): Promise<pkAuthRegisterStartResponse> => {
  
  const res = await fetch(getPkAuthRegisterStartUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pkAuthRegisterStartBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pkAuthRegisterStartResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pkAuthRegisterStartResponse
}



export type pkAuthRegisterFinishResponse200 = {
  data: unknown
  status: 200
}

export type pkAuthRegisterFinishResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pkAuthRegisterFinishResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pkAuthRegisterFinishResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pkAuthRegisterFinishResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pkAuthRegisterFinishResponseComposite = pkAuthRegisterFinishResponse200 | pkAuthRegisterFinishResponse400 | pkAuthRegisterFinishResponse401 | pkAuthRegisterFinishResponse403 | pkAuthRegisterFinishResponse500;
    
export type pkAuthRegisterFinishResponse = pkAuthRegisterFinishResponseComposite & {
  headers: Headers;
}

export const getPkAuthRegisterFinishUrl = () => {


  

  return `https://api.fiddl.art/api/pkAuth/registerFinish`
}

export const pkAuthRegisterFinish = async (pkAuthRegisterFinishBody: PkAuthRegisterFinishBody, options?: RequestInit): Promise<pkAuthRegisterFinishResponse> => {
  
  const res = await fetch(getPkAuthRegisterFinishUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pkAuthRegisterFinishBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pkAuthRegisterFinishResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pkAuthRegisterFinishResponse
}



export type pkAuthLoginStartResponse200 = {
  data: unknown
  status: 200
}

export type pkAuthLoginStartResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pkAuthLoginStartResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pkAuthLoginStartResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pkAuthLoginStartResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pkAuthLoginStartResponseComposite = pkAuthLoginStartResponse200 | pkAuthLoginStartResponse400 | pkAuthLoginStartResponse401 | pkAuthLoginStartResponse403 | pkAuthLoginStartResponse500;
    
export type pkAuthLoginStartResponse = pkAuthLoginStartResponseComposite & {
  headers: Headers;
}

export const getPkAuthLoginStartUrl = () => {


  

  return `https://api.fiddl.art/api/pkAuth/loginStart`
}

export const pkAuthLoginStart = async (pkAuthLoginStartBody: PkAuthLoginStartBody, options?: RequestInit): Promise<pkAuthLoginStartResponse> => {
  
  const res = await fetch(getPkAuthLoginStartUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pkAuthLoginStartBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pkAuthLoginStartResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pkAuthLoginStartResponse
}



export type pkAuthLoginFinishResponse200 = {
  data: unknown
  status: 200
}

export type pkAuthLoginFinishResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pkAuthLoginFinishResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pkAuthLoginFinishResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pkAuthLoginFinishResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pkAuthLoginFinishResponseComposite = pkAuthLoginFinishResponse200 | pkAuthLoginFinishResponse400 | pkAuthLoginFinishResponse401 | pkAuthLoginFinishResponse403 | pkAuthLoginFinishResponse500;
    
export type pkAuthLoginFinishResponse = pkAuthLoginFinishResponseComposite & {
  headers: Headers;
}

export const getPkAuthLoginFinishUrl = () => {


  

  return `https://api.fiddl.art/api/pkAuth/loginFinish`
}

export const pkAuthLoginFinish = async (pkAuthLoginFinishBody: PkAuthLoginFinishBody, options?: RequestInit): Promise<pkAuthLoginFinishResponse> => {
  
  const res = await fetch(getPkAuthLoginFinishUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pkAuthLoginFinishBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pkAuthLoginFinishResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pkAuthLoginFinishResponse
}



export type createImageResponse200 = {
  data: CreateImage200
  status: 200
}

export type createImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type createImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type createImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type createImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type createImageResponseComposite = createImageResponse200 | createImageResponse400 | createImageResponse401 | createImageResponse403 | createImageResponse500;
    
export type createImageResponse = createImageResponseComposite & {
  headers: Headers;
}

export const getCreateImageUrl = () => {


  

  return `https://api.fiddl.art/api/create/image`
}

export const createImage = async (createImageBody: CreateImageBody, options?: RequestInit): Promise<createImageResponse> => {
  
  const res = await fetch(getCreateImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createImageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createImageResponse
}



export type createRandomPromptResponse200 = {
  data: string
  status: 200
}

export type createRandomPromptResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type createRandomPromptResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type createRandomPromptResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type createRandomPromptResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type createRandomPromptResponseComposite = createRandomPromptResponse200 | createRandomPromptResponse400 | createRandomPromptResponse401 | createRandomPromptResponse403 | createRandomPromptResponse500;
    
export type createRandomPromptResponse = createRandomPromptResponseComposite & {
  headers: Headers;
}

export const getCreateRandomPromptUrl = () => {


  

  return `https://api.fiddl.art/api/create/randomPrompt`
}

export const createRandomPrompt = async (createRandomPromptBody: CreateRandomPromptBody, options?: RequestInit): Promise<createRandomPromptResponse> => {
  
  const res = await fetch(getCreateRandomPromptUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createRandomPromptBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createRandomPromptResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createRandomPromptResponse
}



export type createImprovePromptResponse200 = {
  data: string
  status: 200
}

export type createImprovePromptResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type createImprovePromptResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type createImprovePromptResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type createImprovePromptResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type createImprovePromptResponseComposite = createImprovePromptResponse200 | createImprovePromptResponse400 | createImprovePromptResponse401 | createImprovePromptResponse403 | createImprovePromptResponse500;
    
export type createImprovePromptResponse = createImprovePromptResponseComposite & {
  headers: Headers;
}

export const getCreateImprovePromptUrl = () => {


  

  return `https://api.fiddl.art/api/create/improvePrompt`
}

export const createImprovePrompt = async (createImprovePromptBody: CreateImprovePromptBody, options?: RequestInit): Promise<createImprovePromptResponse> => {
  
  const res = await fetch(getCreateImprovePromptUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      createImprovePromptBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: createImprovePromptResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as createImprovePromptResponse
}



export type creationsImageDataResponse200 = {
  data: CreationsImageData200
  status: 200
}

export type creationsImageDataResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsImageDataResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsImageDataResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsImageDataResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsImageDataResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsImageDataResponseComposite = creationsImageDataResponse200 | creationsImageDataResponse400 | creationsImageDataResponse401 | creationsImageDataResponse403 | creationsImageDataResponse404 | creationsImageDataResponse500;
    
export type creationsImageDataResponse = creationsImageDataResponseComposite & {
  headers: Headers;
}

export const getCreationsImageDataUrl = (params: CreationsImageDataParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/imageData?${stringifiedParams}` : `https://api.fiddl.art/api/creations/imageData`
}

export const creationsImageData = async (params: CreationsImageDataParams, options?: RequestInit): Promise<creationsImageDataResponse> => {
  
  const res = await fetch(getCreationsImageDataUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsImageDataResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsImageDataResponse
}



export type creationsUserImagePurchasesResponse200 = {
  data: CreationsUserImagePurchases200Item[]
  status: 200
}

export type creationsUserImagePurchasesResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsUserImagePurchasesResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsUserImagePurchasesResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsUserImagePurchasesResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsUserImagePurchasesResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsUserImagePurchasesResponseComposite = creationsUserImagePurchasesResponse200 | creationsUserImagePurchasesResponse400 | creationsUserImagePurchasesResponse401 | creationsUserImagePurchasesResponse403 | creationsUserImagePurchasesResponse404 | creationsUserImagePurchasesResponse500;
    
export type creationsUserImagePurchasesResponse = creationsUserImagePurchasesResponseComposite & {
  headers: Headers;
}

export const getCreationsUserImagePurchasesUrl = (params?: CreationsUserImagePurchasesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/userImagePurchases?${stringifiedParams}` : `https://api.fiddl.art/api/creations/userImagePurchases`
}

export const creationsUserImagePurchases = async (params?: CreationsUserImagePurchasesParams, options?: RequestInit): Promise<creationsUserImagePurchasesResponse> => {
  
  const res = await fetch(getCreationsUserImagePurchasesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsUserImagePurchasesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsUserImagePurchasesResponse
}



export type creationsCreateRequestsResponse200 = {
  data: CreationsCreateRequests200Item[]
  status: 200
}

export type creationsCreateRequestsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsCreateRequestsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsCreateRequestsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsCreateRequestsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsCreateRequestsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsCreateRequestsResponseComposite = creationsCreateRequestsResponse200 | creationsCreateRequestsResponse400 | creationsCreateRequestsResponse401 | creationsCreateRequestsResponse403 | creationsCreateRequestsResponse404 | creationsCreateRequestsResponse500;
    
export type creationsCreateRequestsResponse = creationsCreateRequestsResponseComposite & {
  headers: Headers;
}

export const getCreationsCreateRequestsUrl = (params?: CreationsCreateRequestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/createRequests?${stringifiedParams}` : `https://api.fiddl.art/api/creations/createRequests`
}

export const creationsCreateRequests = async (params?: CreationsCreateRequestsParams, options?: RequestInit): Promise<creationsCreateRequestsResponse> => {
  
  const res = await fetch(getCreationsCreateRequestsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsCreateRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsCreateRequestsResponse
}



export type creationsCreateRequestResponse200 = {
  data: CreationsCreateRequest200
  status: 200
}

export type creationsCreateRequestResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsCreateRequestResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsCreateRequestResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsCreateRequestResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsCreateRequestResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsCreateRequestResponseComposite = creationsCreateRequestResponse200 | creationsCreateRequestResponse400 | creationsCreateRequestResponse401 | creationsCreateRequestResponse403 | creationsCreateRequestResponse404 | creationsCreateRequestResponse500;
    
export type creationsCreateRequestResponse = creationsCreateRequestResponseComposite & {
  headers: Headers;
}

export const getCreationsCreateRequestUrl = (params: CreationsCreateRequestParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/createRequest?${stringifiedParams}` : `https://api.fiddl.art/api/creations/createRequest`
}

export const creationsCreateRequest = async (params: CreationsCreateRequestParams, options?: RequestInit): Promise<creationsCreateRequestResponse> => {
  
  const res = await fetch(getCreationsCreateRequestUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsCreateRequestResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsCreateRequestResponse
}



export type creationsBrowseCreateRequestsResponse200 = {
  data: unknown[]
  status: 200
}

export type creationsBrowseCreateRequestsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsBrowseCreateRequestsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsBrowseCreateRequestsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsBrowseCreateRequestsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsBrowseCreateRequestsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsBrowseCreateRequestsResponseComposite = creationsBrowseCreateRequestsResponse200 | creationsBrowseCreateRequestsResponse400 | creationsBrowseCreateRequestsResponse401 | creationsBrowseCreateRequestsResponse403 | creationsBrowseCreateRequestsResponse404 | creationsBrowseCreateRequestsResponse500;
    
export type creationsBrowseCreateRequestsResponse = creationsBrowseCreateRequestsResponseComposite & {
  headers: Headers;
}

export const getCreationsBrowseCreateRequestsUrl = (params?: CreationsBrowseCreateRequestsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/browseCreateRequests?${stringifiedParams}` : `https://api.fiddl.art/api/creations/browseCreateRequests`
}

export const creationsBrowseCreateRequests = async (params?: CreationsBrowseCreateRequestsParams, options?: RequestInit): Promise<creationsBrowseCreateRequestsResponse> => {
  
  const res = await fetch(getCreationsBrowseCreateRequestsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsBrowseCreateRequestsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsBrowseCreateRequestsResponse
}



export type creationsHdImageResponse200 = {
  data: string
  status: 200
}

export type creationsHdImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsHdImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsHdImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsHdImageResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsHdImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsHdImageResponseComposite = creationsHdImageResponse200 | creationsHdImageResponse400 | creationsHdImageResponse401 | creationsHdImageResponse403 | creationsHdImageResponse404 | creationsHdImageResponse500;
    
export type creationsHdImageResponse = creationsHdImageResponseComposite & {
  headers: Headers;
}

export const getCreationsHdImageUrl = (params: CreationsHdImageParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/hdImage?${stringifiedParams}` : `https://api.fiddl.art/api/creations/hdImage`
}

export const creationsHdImage = async (params: CreationsHdImageParams, options?: RequestInit): Promise<creationsHdImageResponse> => {
  
  const res = await fetch(getCreationsHdImageUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsHdImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsHdImageResponse
}



export type creationsOriginalImageResponse200 = {
  data: string
  status: 200
}

export type creationsOriginalImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsOriginalImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsOriginalImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsOriginalImageResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsOriginalImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsOriginalImageResponseComposite = creationsOriginalImageResponse200 | creationsOriginalImageResponse400 | creationsOriginalImageResponse401 | creationsOriginalImageResponse403 | creationsOriginalImageResponse404 | creationsOriginalImageResponse500;
    
export type creationsOriginalImageResponse = creationsOriginalImageResponseComposite & {
  headers: Headers;
}

export const getCreationsOriginalImageUrl = (params: CreationsOriginalImageParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/originalImage?${stringifiedParams}` : `https://api.fiddl.art/api/creations/originalImage`
}

export const creationsOriginalImage = async (params: CreationsOriginalImageParams, options?: RequestInit): Promise<creationsOriginalImageResponse> => {
  
  const res = await fetch(getCreationsOriginalImageUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsOriginalImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsOriginalImageResponse
}



export type creationsUpscaledImageResponse200 = {
  data: string
  status: 200
}

export type creationsUpscaledImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsUpscaledImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsUpscaledImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsUpscaledImageResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type creationsUpscaledImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsUpscaledImageResponseComposite = creationsUpscaledImageResponse200 | creationsUpscaledImageResponse400 | creationsUpscaledImageResponse401 | creationsUpscaledImageResponse403 | creationsUpscaledImageResponse404 | creationsUpscaledImageResponse500;
    
export type creationsUpscaledImageResponse = creationsUpscaledImageResponseComposite & {
  headers: Headers;
}

export const getCreationsUpscaledImageUrl = (params: CreationsUpscaledImageParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/creations/upscaledImage?${stringifiedParams}` : `https://api.fiddl.art/api/creations/upscaledImage`
}

export const creationsUpscaledImage = async (params: CreationsUpscaledImageParams, options?: RequestInit): Promise<creationsUpscaledImageResponse> => {
  
  const res = await fetch(getCreationsUpscaledImageUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsUpscaledImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsUpscaledImageResponse
}



export type creationsPurchaseImageResponse200 = {
  data: CreationsPurchaseImage200
  status: 200
}

export type creationsPurchaseImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsPurchaseImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsPurchaseImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsPurchaseImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsPurchaseImageResponseComposite = creationsPurchaseImageResponse200 | creationsPurchaseImageResponse400 | creationsPurchaseImageResponse401 | creationsPurchaseImageResponse403 | creationsPurchaseImageResponse500;
    
export type creationsPurchaseImageResponse = creationsPurchaseImageResponseComposite & {
  headers: Headers;
}

export const getCreationsPurchaseImageUrl = () => {


  

  return `https://api.fiddl.art/api/creations/purchaseImage`
}

export const creationsPurchaseImage = async (creationsPurchaseImageBody: CreationsPurchaseImageBody, options?: RequestInit): Promise<creationsPurchaseImageResponse> => {
  
  const res = await fetch(getCreationsPurchaseImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      creationsPurchaseImageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsPurchaseImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsPurchaseImageResponse
}



export type creationsDeleteImageResponse200 = {
  data: boolean
  status: 200
}

export type creationsDeleteImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsDeleteImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsDeleteImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsDeleteImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsDeleteImageResponseComposite = creationsDeleteImageResponse200 | creationsDeleteImageResponse400 | creationsDeleteImageResponse401 | creationsDeleteImageResponse403 | creationsDeleteImageResponse500;
    
export type creationsDeleteImageResponse = creationsDeleteImageResponseComposite & {
  headers: Headers;
}

export const getCreationsDeleteImageUrl = () => {


  

  return `https://api.fiddl.art/api/creations/deleteImage`
}

export const creationsDeleteImage = async (creationsDeleteImageBody: CreationsDeleteImageBody, options?: RequestInit): Promise<creationsDeleteImageResponse> => {
  
  const res = await fetch(getCreationsDeleteImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      creationsDeleteImageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsDeleteImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsDeleteImageResponse
}



export type creationsDeleteRequestResponse200 = {
  data: boolean
  status: 200
}

export type creationsDeleteRequestResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsDeleteRequestResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsDeleteRequestResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsDeleteRequestResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsDeleteRequestResponseComposite = creationsDeleteRequestResponse200 | creationsDeleteRequestResponse400 | creationsDeleteRequestResponse401 | creationsDeleteRequestResponse403 | creationsDeleteRequestResponse500;
    
export type creationsDeleteRequestResponse = creationsDeleteRequestResponseComposite & {
  headers: Headers;
}

export const getCreationsDeleteRequestUrl = () => {


  

  return `https://api.fiddl.art/api/creations/deleteRequest`
}

export const creationsDeleteRequest = async (creationsDeleteRequestBody: CreationsDeleteRequestBody, options?: RequestInit): Promise<creationsDeleteRequestResponse> => {
  
  const res = await fetch(getCreationsDeleteRequestUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      creationsDeleteRequestBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsDeleteRequestResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsDeleteRequestResponse
}



export type creationsSetRequestPrivacyResponse200 = {
  data: boolean
  status: 200
}

export type creationsSetRequestPrivacyResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type creationsSetRequestPrivacyResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type creationsSetRequestPrivacyResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type creationsSetRequestPrivacyResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type creationsSetRequestPrivacyResponseComposite = creationsSetRequestPrivacyResponse200 | creationsSetRequestPrivacyResponse400 | creationsSetRequestPrivacyResponse401 | creationsSetRequestPrivacyResponse403 | creationsSetRequestPrivacyResponse500;
    
export type creationsSetRequestPrivacyResponse = creationsSetRequestPrivacyResponseComposite & {
  headers: Headers;
}

export const getCreationsSetRequestPrivacyUrl = () => {


  

  return `https://api.fiddl.art/api/creations/setRequestPrivacy`
}

export const creationsSetRequestPrivacy = async (creationsSetRequestPrivacyBody: CreationsSetRequestPrivacyBody, options?: RequestInit): Promise<creationsSetRequestPrivacyResponse> => {
  
  const res = await fetch(getCreationsSetRequestPrivacyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      creationsSetRequestPrivacyBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: creationsSetRequestPrivacyResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as creationsSetRequestPrivacyResponse
}



export type pointsPackagesAvailableResponse200 = {
  data: PointsPackagesAvailable200Item[]
  status: 200
}

export type pointsPackagesAvailableResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pointsPackagesAvailableResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pointsPackagesAvailableResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pointsPackagesAvailableResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type pointsPackagesAvailableResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pointsPackagesAvailableResponseComposite = pointsPackagesAvailableResponse200 | pointsPackagesAvailableResponse400 | pointsPackagesAvailableResponse401 | pointsPackagesAvailableResponse403 | pointsPackagesAvailableResponse404 | pointsPackagesAvailableResponse500;
    
export type pointsPackagesAvailableResponse = pointsPackagesAvailableResponseComposite & {
  headers: Headers;
}

export const getPointsPackagesAvailableUrl = () => {


  

  return `https://api.fiddl.art/api/points/packagesAvailable`
}

export const pointsPackagesAvailable = async ( options?: RequestInit): Promise<pointsPackagesAvailableResponse> => {
  
  const res = await fetch(getPointsPackagesAvailableUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pointsPackagesAvailableResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pointsPackagesAvailableResponse
}



export type pointsInitBuyPackageResponse200 = {
  data: PointsInitBuyPackage200
  status: 200
}

export type pointsInitBuyPackageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pointsInitBuyPackageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pointsInitBuyPackageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pointsInitBuyPackageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pointsInitBuyPackageResponseComposite = pointsInitBuyPackageResponse200 | pointsInitBuyPackageResponse400 | pointsInitBuyPackageResponse401 | pointsInitBuyPackageResponse403 | pointsInitBuyPackageResponse500;
    
export type pointsInitBuyPackageResponse = pointsInitBuyPackageResponseComposite & {
  headers: Headers;
}

export const getPointsInitBuyPackageUrl = () => {


  

  return `https://api.fiddl.art/api/points/initBuyPackage`
}

export const pointsInitBuyPackage = async (pointsInitBuyPackageBody: PointsInitBuyPackageBody, options?: RequestInit): Promise<pointsInitBuyPackageResponse> => {
  
  const res = await fetch(getPointsInitBuyPackageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pointsInitBuyPackageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pointsInitBuyPackageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pointsInitBuyPackageResponse
}



export type pointsFinishBuyPackageResponse200 = {
  data: PointsFinishBuyPackage200
  status: 200
}

export type pointsFinishBuyPackageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pointsFinishBuyPackageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pointsFinishBuyPackageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pointsFinishBuyPackageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pointsFinishBuyPackageResponseComposite = pointsFinishBuyPackageResponse200 | pointsFinishBuyPackageResponse400 | pointsFinishBuyPackageResponse401 | pointsFinishBuyPackageResponse403 | pointsFinishBuyPackageResponse500;
    
export type pointsFinishBuyPackageResponse = pointsFinishBuyPackageResponseComposite & {
  headers: Headers;
}

export const getPointsFinishBuyPackageUrl = () => {


  

  return `https://api.fiddl.art/api/points/finishBuyPackage`
}

export const pointsFinishBuyPackage = async (pointsFinishBuyPackageBody: PointsFinishBuyPackageBody, options?: RequestInit): Promise<pointsFinishBuyPackageResponse> => {
  
  const res = await fetch(getPointsFinishBuyPackageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      pointsFinishBuyPackageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pointsFinishBuyPackageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pointsFinishBuyPackageResponse
}



export type pointsGetOrdersResponse200 = {
  data: PointsGetOrders200
  status: 200
}

export type pointsGetOrdersResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pointsGetOrdersResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pointsGetOrdersResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pointsGetOrdersResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type pointsGetOrdersResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pointsGetOrdersResponseComposite = pointsGetOrdersResponse200 | pointsGetOrdersResponse400 | pointsGetOrdersResponse401 | pointsGetOrdersResponse403 | pointsGetOrdersResponse404 | pointsGetOrdersResponse500;
    
export type pointsGetOrdersResponse = pointsGetOrdersResponseComposite & {
  headers: Headers;
}

export const getPointsGetOrdersUrl = () => {


  

  return `https://api.fiddl.art/api/points/getOrders`
}

export const pointsGetOrders = async ( options?: RequestInit): Promise<pointsGetOrdersResponse> => {
  
  const res = await fetch(getPointsGetOrdersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pointsGetOrdersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pointsGetOrdersResponse
}



export type pointsGetOrderResponse200 = {
  data: PointsGetOrder200
  status: 200
}

export type pointsGetOrderResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type pointsGetOrderResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type pointsGetOrderResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type pointsGetOrderResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type pointsGetOrderResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type pointsGetOrderResponseComposite = pointsGetOrderResponse200 | pointsGetOrderResponse400 | pointsGetOrderResponse401 | pointsGetOrderResponse403 | pointsGetOrderResponse404 | pointsGetOrderResponse500;
    
export type pointsGetOrderResponse = pointsGetOrderResponseComposite & {
  headers: Headers;
}

export const getPointsGetOrderUrl = (params: PointsGetOrderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/points/getOrder?${stringifiedParams}` : `https://api.fiddl.art/api/points/getOrder`
}

export const pointsGetOrder = async (params: PointsGetOrderParams, options?: RequestInit): Promise<pointsGetOrderResponse> => {
  
  const res = await fetch(getPointsGetOrderUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: pointsGetOrderResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as pointsGetOrderResponse
}



export type userGetResponse200 = {
  data: UserGet200
  status: 200
}

export type userGetResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userGetResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userGetResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userGetResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userGetResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userGetResponseComposite = userGetResponse200 | userGetResponse400 | userGetResponse401 | userGetResponse403 | userGetResponse404 | userGetResponse500;
    
export type userGetResponse = userGetResponseComposite & {
  headers: Headers;
}

export const getUserGetUrl = (params: UserGetParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/get?${stringifiedParams}` : `https://api.fiddl.art/api/user/get`
}

export const userGet = async (params: UserGetParams, options?: RequestInit): Promise<userGetResponse> => {
  
  const res = await fetch(getUserGetUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userGetResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userGetResponse
}



export type userProfileResponse200 = {
  data: UserProfile200
  status: 200
}

export type userProfileResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userProfileResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userProfileResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userProfileResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userProfileResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userProfileResponseComposite = userProfileResponse200 | userProfileResponse400 | userProfileResponse401 | userProfileResponse403 | userProfileResponse404 | userProfileResponse500;
    
export type userProfileResponse = userProfileResponseComposite & {
  headers: Headers;
}

export const getUserProfileUrl = (params: UserProfileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/profile?${stringifiedParams}` : `https://api.fiddl.art/api/user/profile`
}

export const userProfile = async (params: UserProfileParams, options?: RequestInit): Promise<userProfileResponse> => {
  
  const res = await fetch(getUserProfileUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userProfileResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userProfileResponse
}



export type userPublicProfileResponse200 = {
  data: UserPublicProfile200
  status: 200
}

export type userPublicProfileResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userPublicProfileResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userPublicProfileResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userPublicProfileResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userPublicProfileResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userPublicProfileResponseComposite = userPublicProfileResponse200 | userPublicProfileResponse400 | userPublicProfileResponse401 | userPublicProfileResponse403 | userPublicProfileResponse404 | userPublicProfileResponse500;
    
export type userPublicProfileResponse = userPublicProfileResponseComposite & {
  headers: Headers;
}

export const getUserPublicProfileUrl = (params: UserPublicProfileParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/publicProfile?${stringifiedParams}` : `https://api.fiddl.art/api/user/publicProfile`
}

export const userPublicProfile = async (params: UserPublicProfileParams, options?: RequestInit): Promise<userPublicProfileResponse> => {
  
  const res = await fetch(getUserPublicProfileUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userPublicProfileResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userPublicProfileResponse
}



export type userGetUsernameResponse200 = {
  data: string
  status: 200
}

export type userGetUsernameResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userGetUsernameResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userGetUsernameResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userGetUsernameResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userGetUsernameResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userGetUsernameResponseComposite = userGetUsernameResponse200 | userGetUsernameResponse400 | userGetUsernameResponse401 | userGetUsernameResponse403 | userGetUsernameResponse404 | userGetUsernameResponse500;
    
export type userGetUsernameResponse = userGetUsernameResponseComposite & {
  headers: Headers;
}

export const getUserGetUsernameUrl = (params: UserGetUsernameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/getUsername?${stringifiedParams}` : `https://api.fiddl.art/api/user/getUsername`
}

export const userGetUsername = async (params: UserGetUsernameParams, options?: RequestInit): Promise<userGetUsernameResponse> => {
  
  const res = await fetch(getUserGetUsernameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userGetUsernameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userGetUsernameResponse
}



export type userSetUsernameResponse200 = {
  data: UserSetUsername200
  status: 200
}

export type userSetUsernameResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userSetUsernameResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userSetUsernameResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userSetUsernameResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userSetUsernameResponseComposite = userSetUsernameResponse200 | userSetUsernameResponse400 | userSetUsernameResponse401 | userSetUsernameResponse403 | userSetUsernameResponse500;
    
export type userSetUsernameResponse = userSetUsernameResponseComposite & {
  headers: Headers;
}

export const getUserSetUsernameUrl = () => {


  

  return `https://api.fiddl.art/api/user/setUsername`
}

export const userSetUsername = async (userSetUsernameBody: UserSetUsernameBody, options?: RequestInit): Promise<userSetUsernameResponse> => {
  
  const res = await fetch(getUserSetUsernameUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSetUsernameBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userSetUsernameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userSetUsernameResponse
}



export type userSetBioResponse200 = {
  data: UserSetBio200
  status: 200
}

export type userSetBioResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userSetBioResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userSetBioResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userSetBioResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userSetBioResponseComposite = userSetBioResponse200 | userSetBioResponse400 | userSetBioResponse401 | userSetBioResponse403 | userSetBioResponse500;
    
export type userSetBioResponse = userSetBioResponseComposite & {
  headers: Headers;
}

export const getUserSetBioUrl = () => {


  

  return `https://api.fiddl.art/api/user/setBio`
}

export const userSetBio = async (userSetBioBody: UserSetBioBody, options?: RequestInit): Promise<userSetBioResponse> => {
  
  const res = await fetch(getUserSetBioUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSetBioBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userSetBioResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userSetBioResponse
}



export type userSendVerificationEmailResponse200 = {
  data: boolean
  status: 200
}

export type userSendVerificationEmailResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userSendVerificationEmailResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userSendVerificationEmailResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userSendVerificationEmailResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userSendVerificationEmailResponseComposite = userSendVerificationEmailResponse200 | userSendVerificationEmailResponse400 | userSendVerificationEmailResponse401 | userSendVerificationEmailResponse403 | userSendVerificationEmailResponse500;
    
export type userSendVerificationEmailResponse = userSendVerificationEmailResponseComposite & {
  headers: Headers;
}

export const getUserSendVerificationEmailUrl = () => {


  

  return `https://api.fiddl.art/api/user/sendVerificationEmail`
}

export const userSendVerificationEmail = async (userSendVerificationEmailBody: UserSendVerificationEmailBody, options?: RequestInit): Promise<userSendVerificationEmailResponse> => {
  
  const res = await fetch(getUserSendVerificationEmailUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSendVerificationEmailBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userSendVerificationEmailResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userSendVerificationEmailResponse
}



export type userPointsHistoryResponse200 = {
  data: UserPointsHistory200Item[]
  status: 200
}

export type userPointsHistoryResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userPointsHistoryResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userPointsHistoryResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userPointsHistoryResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userPointsHistoryResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userPointsHistoryResponseComposite = userPointsHistoryResponse200 | userPointsHistoryResponse400 | userPointsHistoryResponse401 | userPointsHistoryResponse403 | userPointsHistoryResponse404 | userPointsHistoryResponse500;
    
export type userPointsHistoryResponse = userPointsHistoryResponseComposite & {
  headers: Headers;
}

export const getUserPointsHistoryUrl = (params?: UserPointsHistoryParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/pointsHistory?${stringifiedParams}` : `https://api.fiddl.art/api/user/pointsHistory`
}

export const userPointsHistory = async (params?: UserPointsHistoryParams, options?: RequestInit): Promise<userPointsHistoryResponse> => {
  
  const res = await fetch(getUserPointsHistoryUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userPointsHistoryResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userPointsHistoryResponse
}



export type userFindByUsernameResponse200 = {
  data: string
  status: 200
}

export type userFindByUsernameResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userFindByUsernameResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userFindByUsernameResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userFindByUsernameResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userFindByUsernameResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userFindByUsernameResponseComposite = userFindByUsernameResponse200 | userFindByUsernameResponse400 | userFindByUsernameResponse401 | userFindByUsernameResponse403 | userFindByUsernameResponse404 | userFindByUsernameResponse500;
    
export type userFindByUsernameResponse = userFindByUsernameResponseComposite & {
  headers: Headers;
}

export const getUserFindByUsernameUrl = (params: UserFindByUsernameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/findByUsername?${stringifiedParams}` : `https://api.fiddl.art/api/user/findByUsername`
}

export const userFindByUsername = async (params: UserFindByUsernameParams, options?: RequestInit): Promise<userFindByUsernameResponse> => {
  
  const res = await fetch(getUserFindByUsernameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userFindByUsernameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userFindByUsernameResponse
}



export type userFindByEmailResponse200 = {
  data: string
  status: 200
}

export type userFindByEmailResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userFindByEmailResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userFindByEmailResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userFindByEmailResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userFindByEmailResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userFindByEmailResponseComposite = userFindByEmailResponse200 | userFindByEmailResponse400 | userFindByEmailResponse401 | userFindByEmailResponse403 | userFindByEmailResponse404 | userFindByEmailResponse500;
    
export type userFindByEmailResponse = userFindByEmailResponseComposite & {
  headers: Headers;
}

export const getUserFindByEmailUrl = (params: UserFindByEmailParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/findByEmail?${stringifiedParams}` : `https://api.fiddl.art/api/user/findByEmail`
}

export const userFindByEmail = async (params: UserFindByEmailParams, options?: RequestInit): Promise<userFindByEmailResponse> => {
  
  const res = await fetch(getUserFindByEmailUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userFindByEmailResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userFindByEmailResponse
}



export type userFindByPhoneResponse200 = {
  data: string
  status: 200
}

export type userFindByPhoneResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userFindByPhoneResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userFindByPhoneResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userFindByPhoneResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userFindByPhoneResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userFindByPhoneResponseComposite = userFindByPhoneResponse200 | userFindByPhoneResponse400 | userFindByPhoneResponse401 | userFindByPhoneResponse403 | userFindByPhoneResponse404 | userFindByPhoneResponse500;
    
export type userFindByPhoneResponse = userFindByPhoneResponseComposite & {
  headers: Headers;
}

export const getUserFindByPhoneUrl = (params: UserFindByPhoneParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/findByPhone?${stringifiedParams}` : `https://api.fiddl.art/api/user/findByPhone`
}

export const userFindByPhone = async (params: UserFindByPhoneParams, options?: RequestInit): Promise<userFindByPhoneResponse> => {
  
  const res = await fetch(getUserFindByPhoneUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userFindByPhoneResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userFindByPhoneResponse
}



export type userFindByPrivyIdResponse200 = {
  data: string
  status: 200
}

export type userFindByPrivyIdResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userFindByPrivyIdResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userFindByPrivyIdResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userFindByPrivyIdResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userFindByPrivyIdResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userFindByPrivyIdResponseComposite = userFindByPrivyIdResponse200 | userFindByPrivyIdResponse400 | userFindByPrivyIdResponse401 | userFindByPrivyIdResponse403 | userFindByPrivyIdResponse404 | userFindByPrivyIdResponse500;
    
export type userFindByPrivyIdResponse = userFindByPrivyIdResponseComposite & {
  headers: Headers;
}

export const getUserFindByPrivyIdUrl = (params: UserFindByPrivyIdParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/user/findByPrivyId?${stringifiedParams}` : `https://api.fiddl.art/api/user/findByPrivyId`
}

export const userFindByPrivyId = async (params: UserFindByPrivyIdParams, options?: RequestInit): Promise<userFindByPrivyIdResponse> => {
  
  const res = await fetch(getUserFindByPrivyIdUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userFindByPrivyIdResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userFindByPrivyIdResponse
}



export type userGetNotificationConfigResponse200 = {
  data: UserGetNotificationConfig200
  status: 200
}

export type userGetNotificationConfigResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userGetNotificationConfigResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userGetNotificationConfigResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userGetNotificationConfigResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userGetNotificationConfigResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userGetNotificationConfigResponseComposite = userGetNotificationConfigResponse200 | userGetNotificationConfigResponse400 | userGetNotificationConfigResponse401 | userGetNotificationConfigResponse403 | userGetNotificationConfigResponse404 | userGetNotificationConfigResponse500;
    
export type userGetNotificationConfigResponse = userGetNotificationConfigResponseComposite & {
  headers: Headers;
}

export const getUserGetNotificationConfigUrl = () => {


  

  return `https://api.fiddl.art/api/user/getNotificationConfig`
}

export const userGetNotificationConfig = async ( options?: RequestInit): Promise<userGetNotificationConfigResponse> => {
  
  const res = await fetch(getUserGetNotificationConfigUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userGetNotificationConfigResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userGetNotificationConfigResponse
}



export type userSetNotificationConfigResponse200 = {
  data: UserSetNotificationConfig200
  status: 200
}

export type userSetNotificationConfigResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userSetNotificationConfigResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userSetNotificationConfigResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userSetNotificationConfigResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userSetNotificationConfigResponseComposite = userSetNotificationConfigResponse200 | userSetNotificationConfigResponse400 | userSetNotificationConfigResponse401 | userSetNotificationConfigResponse403 | userSetNotificationConfigResponse500;
    
export type userSetNotificationConfigResponse = userSetNotificationConfigResponseComposite & {
  headers: Headers;
}

export const getUserSetNotificationConfigUrl = () => {


  

  return `https://api.fiddl.art/api/user/setNotificationConfig`
}

export const userSetNotificationConfig = async (userSetNotificationConfigBody: UserSetNotificationConfigBody, options?: RequestInit): Promise<userSetNotificationConfigResponse> => {
  
  const res = await fetch(getUserSetNotificationConfigUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSetNotificationConfigBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userSetNotificationConfigResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userSetNotificationConfigResponse
}



export type userUnsubscribeEmailNotificationsResponse200 = {
  data: unknown
  status: 200
}

export type userUnsubscribeEmailNotificationsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userUnsubscribeEmailNotificationsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userUnsubscribeEmailNotificationsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userUnsubscribeEmailNotificationsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userUnsubscribeEmailNotificationsResponseComposite = userUnsubscribeEmailNotificationsResponse200 | userUnsubscribeEmailNotificationsResponse400 | userUnsubscribeEmailNotificationsResponse401 | userUnsubscribeEmailNotificationsResponse403 | userUnsubscribeEmailNotificationsResponse500;
    
export type userUnsubscribeEmailNotificationsResponse = userUnsubscribeEmailNotificationsResponseComposite & {
  headers: Headers;
}

export const getUserUnsubscribeEmailNotificationsUrl = () => {


  

  return `https://api.fiddl.art/api/user/unsubscribeEmailNotifications`
}

export const userUnsubscribeEmailNotifications = async (userUnsubscribeEmailNotificationsBody: UserUnsubscribeEmailNotificationsBody, options?: RequestInit): Promise<userUnsubscribeEmailNotificationsResponse> => {
  
  const res = await fetch(getUserUnsubscribeEmailNotificationsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userUnsubscribeEmailNotificationsBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userUnsubscribeEmailNotificationsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userUnsubscribeEmailNotificationsResponse
}



export type userSetAvatarResponse200 = {
  data: boolean
  status: 200
}

export type userSetAvatarResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userSetAvatarResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userSetAvatarResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userSetAvatarResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userSetAvatarResponseComposite = userSetAvatarResponse200 | userSetAvatarResponse400 | userSetAvatarResponse401 | userSetAvatarResponse403 | userSetAvatarResponse500;
    
export type userSetAvatarResponse = userSetAvatarResponseComposite & {
  headers: Headers;
}

export const getUserSetAvatarUrl = () => {


  

  return `https://api.fiddl.art/api/user/setAvatar`
}

export const userSetAvatar = async (userSetAvatarBody: UserSetAvatarBody, options?: RequestInit): Promise<userSetAvatarResponse> => {
  
  const res = await fetch(getUserSetAvatarUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userSetAvatarBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userSetAvatarResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userSetAvatarResponse
}



export type userAllUsersResponse200 = {
  data: UserAllUsers200Item[]
  status: 200
}

export type userAllUsersResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type userAllUsersResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type userAllUsersResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type userAllUsersResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type userAllUsersResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type userAllUsersResponseComposite = userAllUsersResponse200 | userAllUsersResponse400 | userAllUsersResponse401 | userAllUsersResponse403 | userAllUsersResponse404 | userAllUsersResponse500;
    
export type userAllUsersResponse = userAllUsersResponseComposite & {
  headers: Headers;
}

export const getUserAllUsersUrl = () => {


  

  return `https://api.fiddl.art/api/user/allUsers`
}

export const userAllUsers = async ( options?: RequestInit): Promise<userAllUsersResponse> => {
  
  const res = await fetch(getUserAllUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: userAllUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as userAllUsersResponse
}



export type loginLinkInitLoginLinkResponse200 = {
  data: string
  status: 200
}

export type loginLinkInitLoginLinkResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type loginLinkInitLoginLinkResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type loginLinkInitLoginLinkResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type loginLinkInitLoginLinkResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type loginLinkInitLoginLinkResponseComposite = loginLinkInitLoginLinkResponse200 | loginLinkInitLoginLinkResponse400 | loginLinkInitLoginLinkResponse401 | loginLinkInitLoginLinkResponse403 | loginLinkInitLoginLinkResponse500;
    
export type loginLinkInitLoginLinkResponse = loginLinkInitLoginLinkResponseComposite & {
  headers: Headers;
}

export const getLoginLinkInitLoginLinkUrl = () => {


  

  return `https://api.fiddl.art/api/loginLink/initLoginLink`
}

export const loginLinkInitLoginLink = async (loginLinkInitLoginLinkBody: LoginLinkInitLoginLinkBody, options?: RequestInit): Promise<loginLinkInitLoginLinkResponse> => {
  
  const res = await fetch(getLoginLinkInitLoginLinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginLinkInitLoginLinkBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: loginLinkInitLoginLinkResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as loginLinkInitLoginLinkResponse
}



export type loginLinkLoginWithLinkResponse200 = {
  data: LoginLinkLoginWithLink200
  status: 200
}

export type loginLinkLoginWithLinkResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type loginLinkLoginWithLinkResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type loginLinkLoginWithLinkResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type loginLinkLoginWithLinkResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type loginLinkLoginWithLinkResponseComposite = loginLinkLoginWithLinkResponse200 | loginLinkLoginWithLinkResponse400 | loginLinkLoginWithLinkResponse401 | loginLinkLoginWithLinkResponse403 | loginLinkLoginWithLinkResponse500;
    
export type loginLinkLoginWithLinkResponse = loginLinkLoginWithLinkResponseComposite & {
  headers: Headers;
}

export const getLoginLinkLoginWithLinkUrl = () => {


  

  return `https://api.fiddl.art/api/loginLink/loginWithLink`
}

export const loginLinkLoginWithLink = async (loginLinkLoginWithLinkBody: LoginLinkLoginWithLinkBody, options?: RequestInit): Promise<loginLinkLoginWithLinkResponse> => {
  
  const res = await fetch(getLoginLinkLoginWithLinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      loginLinkLoginWithLinkBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: loginLinkLoginWithLinkResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as loginLinkLoginWithLinkResponse
}



export type statsUsersResponse200 = {
  data: StatsUsers200
  status: 200
}

export type statsUsersResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type statsUsersResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type statsUsersResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type statsUsersResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type statsUsersResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type statsUsersResponseComposite = statsUsersResponse200 | statsUsersResponse400 | statsUsersResponse401 | statsUsersResponse403 | statsUsersResponse404 | statsUsersResponse500;
    
export type statsUsersResponse = statsUsersResponseComposite & {
  headers: Headers;
}

export const getStatsUsersUrl = () => {


  

  return `https://api.fiddl.art/api/stats/users`
}

export const statsUsers = async ( options?: RequestInit): Promise<statsUsersResponse> => {
  
  const res = await fetch(getStatsUsersUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statsUsersResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statsUsersResponse
}



export type statsImagesResponse200 = {
  data: StatsImages200
  status: 200
}

export type statsImagesResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type statsImagesResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type statsImagesResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type statsImagesResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type statsImagesResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type statsImagesResponseComposite = statsImagesResponse200 | statsImagesResponse400 | statsImagesResponse401 | statsImagesResponse403 | statsImagesResponse404 | statsImagesResponse500;
    
export type statsImagesResponse = statsImagesResponseComposite & {
  headers: Headers;
}

export const getStatsImagesUrl = () => {


  

  return `https://api.fiddl.art/api/stats/images`
}

export const statsImages = async ( options?: RequestInit): Promise<statsImagesResponse> => {
  
  const res = await fetch(getStatsImagesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statsImagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statsImagesResponse
}



export type statsCollectionsResponse200 = {
  data: StatsCollections200
  status: 200
}

export type statsCollectionsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type statsCollectionsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type statsCollectionsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type statsCollectionsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type statsCollectionsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type statsCollectionsResponseComposite = statsCollectionsResponse200 | statsCollectionsResponse400 | statsCollectionsResponse401 | statsCollectionsResponse403 | statsCollectionsResponse404 | statsCollectionsResponse500;
    
export type statsCollectionsResponse = statsCollectionsResponseComposite & {
  headers: Headers;
}

export const getStatsCollectionsUrl = () => {


  

  return `https://api.fiddl.art/api/stats/collections`
}

export const statsCollections = async ( options?: RequestInit): Promise<statsCollectionsResponse> => {
  
  const res = await fetch(getStatsCollectionsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statsCollectionsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statsCollectionsResponse
}



export type statsPaymentsResponse200 = {
  data: StatsPayments200
  status: 200
}

export type statsPaymentsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type statsPaymentsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type statsPaymentsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type statsPaymentsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type statsPaymentsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type statsPaymentsResponseComposite = statsPaymentsResponse200 | statsPaymentsResponse400 | statsPaymentsResponse401 | statsPaymentsResponse403 | statsPaymentsResponse404 | statsPaymentsResponse500;
    
export type statsPaymentsResponse = statsPaymentsResponseComposite & {
  headers: Headers;
}

export const getStatsPaymentsUrl = () => {


  

  return `https://api.fiddl.art/api/stats/payments`
}

export const statsPayments = async ( options?: RequestInit): Promise<statsPaymentsResponse> => {
  
  const res = await fetch(getStatsPaymentsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statsPaymentsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statsPaymentsResponse
}



export type statsApiMetricsResponse200 = {
  data: unknown
  status: 200
}

export type statsApiMetricsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type statsApiMetricsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type statsApiMetricsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type statsApiMetricsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type statsApiMetricsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type statsApiMetricsResponseComposite = statsApiMetricsResponse200 | statsApiMetricsResponse400 | statsApiMetricsResponse401 | statsApiMetricsResponse403 | statsApiMetricsResponse404 | statsApiMetricsResponse500;
    
export type statsApiMetricsResponse = statsApiMetricsResponseComposite & {
  headers: Headers;
}

export const getStatsApiMetricsUrl = () => {


  

  return `https://api.fiddl.art/api/stats/apiMetrics`
}

export const statsApiMetrics = async ( options?: RequestInit): Promise<statsApiMetricsResponse> => {
  
  const res = await fetch(getStatsApiMetricsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: statsApiMetricsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as statsApiMetricsResponse
}



export type collectionsImageInUsersCollectionResponse200 = {
  data: boolean
  status: 200
}

export type collectionsImageInUsersCollectionResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsImageInUsersCollectionResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsImageInUsersCollectionResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsImageInUsersCollectionResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type collectionsImageInUsersCollectionResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsImageInUsersCollectionResponseComposite = collectionsImageInUsersCollectionResponse200 | collectionsImageInUsersCollectionResponse400 | collectionsImageInUsersCollectionResponse401 | collectionsImageInUsersCollectionResponse403 | collectionsImageInUsersCollectionResponse404 | collectionsImageInUsersCollectionResponse500;
    
export type collectionsImageInUsersCollectionResponse = collectionsImageInUsersCollectionResponseComposite & {
  headers: Headers;
}

export const getCollectionsImageInUsersCollectionUrl = (params: CollectionsImageInUsersCollectionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/collections/imageInUsersCollection?${stringifiedParams}` : `https://api.fiddl.art/api/collections/imageInUsersCollection`
}

export const collectionsImageInUsersCollection = async (params: CollectionsImageInUsersCollectionParams, options?: RequestInit): Promise<collectionsImageInUsersCollectionResponse> => {
  
  const res = await fetch(getCollectionsImageInUsersCollectionUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsImageInUsersCollectionResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsImageInUsersCollectionResponse
}



export type collectionsLikeImageResponse200 = {
  data: boolean
  status: 200
}

export type collectionsLikeImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsLikeImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsLikeImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsLikeImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsLikeImageResponseComposite = collectionsLikeImageResponse200 | collectionsLikeImageResponse400 | collectionsLikeImageResponse401 | collectionsLikeImageResponse403 | collectionsLikeImageResponse500;
    
export type collectionsLikeImageResponse = collectionsLikeImageResponseComposite & {
  headers: Headers;
}

export const getCollectionsLikeImageUrl = () => {


  

  return `https://api.fiddl.art/api/collections/likeImage`
}

export const collectionsLikeImage = async (collectionsLikeImageBody: CollectionsLikeImageBody, options?: RequestInit): Promise<collectionsLikeImageResponse> => {
  
  const res = await fetch(getCollectionsLikeImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionsLikeImageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsLikeImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsLikeImageResponse
}



export type collectionsUnlikeImageResponse200 = {
  data: boolean
  status: 200
}

export type collectionsUnlikeImageResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsUnlikeImageResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsUnlikeImageResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsUnlikeImageResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsUnlikeImageResponseComposite = collectionsUnlikeImageResponse200 | collectionsUnlikeImageResponse400 | collectionsUnlikeImageResponse401 | collectionsUnlikeImageResponse403 | collectionsUnlikeImageResponse500;
    
export type collectionsUnlikeImageResponse = collectionsUnlikeImageResponseComposite & {
  headers: Headers;
}

export const getCollectionsUnlikeImageUrl = () => {


  

  return `https://api.fiddl.art/api/collections/unlikeImage`
}

export const collectionsUnlikeImage = async (collectionsUnlikeImageBody: CollectionsUnlikeImageBody, options?: RequestInit): Promise<collectionsUnlikeImageResponse> => {
  
  const res = await fetch(getCollectionsUnlikeImageUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      collectionsUnlikeImageBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsUnlikeImageResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsUnlikeImageResponse
}



export type collectionsGetCollectionMetaResponse200 = {
  data: CollectionsGetCollectionMeta200
  status: 200
}

export type collectionsGetCollectionMetaResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsGetCollectionMetaResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsGetCollectionMetaResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsGetCollectionMetaResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type collectionsGetCollectionMetaResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsGetCollectionMetaResponseComposite = collectionsGetCollectionMetaResponse200 | collectionsGetCollectionMetaResponse400 | collectionsGetCollectionMetaResponse401 | collectionsGetCollectionMetaResponse403 | collectionsGetCollectionMetaResponse404 | collectionsGetCollectionMetaResponse500;
    
export type collectionsGetCollectionMetaResponse = collectionsGetCollectionMetaResponseComposite & {
  headers: Headers;
}

export const getCollectionsGetCollectionMetaUrl = (params: CollectionsGetCollectionMetaParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/collections/getCollectionMeta?${stringifiedParams}` : `https://api.fiddl.art/api/collections/getCollectionMeta`
}

export const collectionsGetCollectionMeta = async (params: CollectionsGetCollectionMetaParams, options?: RequestInit): Promise<collectionsGetCollectionMetaResponse> => {
  
  const res = await fetch(getCollectionsGetCollectionMetaUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsGetCollectionMetaResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsGetCollectionMetaResponse
}



export type collectionsFindCollectionByNameResponse200 = {
  data: CollectionsFindCollectionByName200
  status: 200
}

export type collectionsFindCollectionByNameResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsFindCollectionByNameResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsFindCollectionByNameResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsFindCollectionByNameResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type collectionsFindCollectionByNameResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsFindCollectionByNameResponseComposite = collectionsFindCollectionByNameResponse200 | collectionsFindCollectionByNameResponse400 | collectionsFindCollectionByNameResponse401 | collectionsFindCollectionByNameResponse403 | collectionsFindCollectionByNameResponse404 | collectionsFindCollectionByNameResponse500;
    
export type collectionsFindCollectionByNameResponse = collectionsFindCollectionByNameResponseComposite & {
  headers: Headers;
}

export const getCollectionsFindCollectionByNameUrl = (params: CollectionsFindCollectionByNameParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/collections/findCollectionByName?${stringifiedParams}` : `https://api.fiddl.art/api/collections/findCollectionByName`
}

export const collectionsFindCollectionByName = async (params: CollectionsFindCollectionByNameParams, options?: RequestInit): Promise<collectionsFindCollectionByNameResponse> => {
  
  const res = await fetch(getCollectionsFindCollectionByNameUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsFindCollectionByNameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsFindCollectionByNameResponse
}



export type collectionsGetCollectionImagesResponse200 = {
  data: CollectionsGetCollectionImages200Item[]
  status: 200
}

export type collectionsGetCollectionImagesResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type collectionsGetCollectionImagesResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type collectionsGetCollectionImagesResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type collectionsGetCollectionImagesResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type collectionsGetCollectionImagesResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type collectionsGetCollectionImagesResponseComposite = collectionsGetCollectionImagesResponse200 | collectionsGetCollectionImagesResponse400 | collectionsGetCollectionImagesResponse401 | collectionsGetCollectionImagesResponse403 | collectionsGetCollectionImagesResponse404 | collectionsGetCollectionImagesResponse500;
    
export type collectionsGetCollectionImagesResponse = collectionsGetCollectionImagesResponseComposite & {
  headers: Headers;
}

export const getCollectionsGetCollectionImagesUrl = (params: CollectionsGetCollectionImagesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/collections/getCollectionImages?${stringifiedParams}` : `https://api.fiddl.art/api/collections/getCollectionImages`
}

export const collectionsGetCollectionImages = async (params: CollectionsGetCollectionImagesParams, options?: RequestInit): Promise<collectionsGetCollectionImagesResponse> => {
  
  const res = await fetch(getCollectionsGetCollectionImagesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: collectionsGetCollectionImagesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as collectionsGetCollectionImagesResponse
}



export type promoCreatePromoCodeResponse200 = {
  data: PromoCreatePromoCode200
  status: 200
}

export type promoCreatePromoCodeResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type promoCreatePromoCodeResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type promoCreatePromoCodeResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type promoCreatePromoCodeResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type promoCreatePromoCodeResponseComposite = promoCreatePromoCodeResponse200 | promoCreatePromoCodeResponse400 | promoCreatePromoCodeResponse401 | promoCreatePromoCodeResponse403 | promoCreatePromoCodeResponse500;
    
export type promoCreatePromoCodeResponse = promoCreatePromoCodeResponseComposite & {
  headers: Headers;
}

export const getPromoCreatePromoCodeUrl = () => {


  

  return `https://api.fiddl.art/api/promo/createPromoCode`
}

export const promoCreatePromoCode = async (promoCreatePromoCodeBody: PromoCreatePromoCodeBody, options?: RequestInit): Promise<promoCreatePromoCodeResponse> => {
  
  const res = await fetch(getPromoCreatePromoCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      promoCreatePromoCodeBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: promoCreatePromoCodeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as promoCreatePromoCodeResponse
}



export type promoDeletePromoCodeResponse200 = {
  data: unknown
  status: 200
}

export type promoDeletePromoCodeResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type promoDeletePromoCodeResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type promoDeletePromoCodeResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type promoDeletePromoCodeResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type promoDeletePromoCodeResponseComposite = promoDeletePromoCodeResponse200 | promoDeletePromoCodeResponse400 | promoDeletePromoCodeResponse401 | promoDeletePromoCodeResponse403 | promoDeletePromoCodeResponse500;
    
export type promoDeletePromoCodeResponse = promoDeletePromoCodeResponseComposite & {
  headers: Headers;
}

export const getPromoDeletePromoCodeUrl = () => {


  

  return `https://api.fiddl.art/api/promo/deletePromoCode`
}

export const promoDeletePromoCode = async (promoDeletePromoCodeBody: PromoDeletePromoCodeBody, options?: RequestInit): Promise<promoDeletePromoCodeResponse> => {
  
  const res = await fetch(getPromoDeletePromoCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      promoDeletePromoCodeBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: promoDeletePromoCodeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as promoDeletePromoCodeResponse
}



export type promoGetPromoCodesResponse200 = {
  data: PromoGetPromoCodes200Item[]
  status: 200
}

export type promoGetPromoCodesResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type promoGetPromoCodesResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type promoGetPromoCodesResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type promoGetPromoCodesResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type promoGetPromoCodesResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type promoGetPromoCodesResponseComposite = promoGetPromoCodesResponse200 | promoGetPromoCodesResponse400 | promoGetPromoCodesResponse401 | promoGetPromoCodesResponse403 | promoGetPromoCodesResponse404 | promoGetPromoCodesResponse500;
    
export type promoGetPromoCodesResponse = promoGetPromoCodesResponseComposite & {
  headers: Headers;
}

export const getPromoGetPromoCodesUrl = () => {


  

  return `https://api.fiddl.art/api/promo/getPromoCodes`
}

export const promoGetPromoCodes = async ( options?: RequestInit): Promise<promoGetPromoCodesResponse> => {
  
  const res = await fetch(getPromoGetPromoCodesUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: promoGetPromoCodesResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as promoGetPromoCodesResponse
}



export type promoGetPromoCodeDetailsResponse200 = {
  data: PromoGetPromoCodeDetails200
  status: 200
}

export type promoGetPromoCodeDetailsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type promoGetPromoCodeDetailsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type promoGetPromoCodeDetailsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type promoGetPromoCodeDetailsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type promoGetPromoCodeDetailsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type promoGetPromoCodeDetailsResponseComposite = promoGetPromoCodeDetailsResponse200 | promoGetPromoCodeDetailsResponse400 | promoGetPromoCodeDetailsResponse401 | promoGetPromoCodeDetailsResponse403 | promoGetPromoCodeDetailsResponse404 | promoGetPromoCodeDetailsResponse500;
    
export type promoGetPromoCodeDetailsResponse = promoGetPromoCodeDetailsResponseComposite & {
  headers: Headers;
}

export const getPromoGetPromoCodeDetailsUrl = (params: PromoGetPromoCodeDetailsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/promo/getPromoCodeDetails?${stringifiedParams}` : `https://api.fiddl.art/api/promo/getPromoCodeDetails`
}

export const promoGetPromoCodeDetails = async (params: PromoGetPromoCodeDetailsParams, options?: RequestInit): Promise<promoGetPromoCodeDetailsResponse> => {
  
  const res = await fetch(getPromoGetPromoCodeDetailsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: promoGetPromoCodeDetailsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as promoGetPromoCodeDetailsResponse
}



export type promoClaimPromoCodeResponse200 = {
  data: unknown
  status: 200
}

export type promoClaimPromoCodeResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type promoClaimPromoCodeResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type promoClaimPromoCodeResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type promoClaimPromoCodeResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type promoClaimPromoCodeResponseComposite = promoClaimPromoCodeResponse200 | promoClaimPromoCodeResponse400 | promoClaimPromoCodeResponse401 | promoClaimPromoCodeResponse403 | promoClaimPromoCodeResponse500;
    
export type promoClaimPromoCodeResponse = promoClaimPromoCodeResponseComposite & {
  headers: Headers;
}

export const getPromoClaimPromoCodeUrl = () => {


  

  return `https://api.fiddl.art/api/promo/claimPromoCode`
}

export const promoClaimPromoCode = async (promoClaimPromoCodeBody: PromoClaimPromoCodeBody, options?: RequestInit): Promise<promoClaimPromoCodeResponse> => {
  
  const res = await fetch(getPromoClaimPromoCodeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      promoClaimPromoCodeBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: promoClaimPromoCodeResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as promoClaimPromoCodeResponse
}



export type modelsSetModelNameResponse200 = {
  data: unknown
  status: 200
}

export type modelsSetModelNameResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsSetModelNameResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsSetModelNameResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsSetModelNameResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsSetModelNameResponseComposite = modelsSetModelNameResponse200 | modelsSetModelNameResponse400 | modelsSetModelNameResponse401 | modelsSetModelNameResponse403 | modelsSetModelNameResponse500;
    
export type modelsSetModelNameResponse = modelsSetModelNameResponseComposite & {
  headers: Headers;
}

export const getModelsSetModelNameUrl = () => {


  

  return `https://api.fiddl.art/api/models/setModelName`
}

export const modelsSetModelName = async (modelsSetModelNameBody: ModelsSetModelNameBody, options?: RequestInit): Promise<modelsSetModelNameResponse> => {
  
  const res = await fetch(getModelsSetModelNameUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      modelsSetModelNameBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsSetModelNameResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsSetModelNameResponse
}



export type modelsGetUserModelsResponse200 = {
  data: ModelsGetUserModels200Item[]
  status: 200
}

export type modelsGetUserModelsResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsGetUserModelsResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsGetUserModelsResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsGetUserModelsResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type modelsGetUserModelsResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsGetUserModelsResponseComposite = modelsGetUserModelsResponse200 | modelsGetUserModelsResponse400 | modelsGetUserModelsResponse401 | modelsGetUserModelsResponse403 | modelsGetUserModelsResponse404 | modelsGetUserModelsResponse500;
    
export type modelsGetUserModelsResponse = modelsGetUserModelsResponseComposite & {
  headers: Headers;
}

export const getModelsGetUserModelsUrl = () => {


  

  return `https://api.fiddl.art/api/models/getUserModels`
}

export const modelsGetUserModels = async ( options?: RequestInit): Promise<modelsGetUserModelsResponse> => {
  
  const res = await fetch(getModelsGetUserModelsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsGetUserModelsResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsGetUserModelsResponse
}



export type modelsCreateModelResponse200 = {
  data: string
  status: 200
}

export type modelsCreateModelResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsCreateModelResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsCreateModelResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsCreateModelResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsCreateModelResponseComposite = modelsCreateModelResponse200 | modelsCreateModelResponse400 | modelsCreateModelResponse401 | modelsCreateModelResponse403 | modelsCreateModelResponse500;
    
export type modelsCreateModelResponse = modelsCreateModelResponseComposite & {
  headers: Headers;
}

export const getModelsCreateModelUrl = () => {


  

  return `https://api.fiddl.art/api/models/createModel`
}

export const modelsCreateModel = async (modelsCreateModelBody: ModelsCreateModelBody, options?: RequestInit): Promise<modelsCreateModelResponse> => {
  
  const res = await fetch(getModelsCreateModelUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      modelsCreateModelBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsCreateModelResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsCreateModelResponse
}



export type modelsGetTrainingStatusResponse200 = {
  data: ModelsGetTrainingStatus200
  status: 200
}

export type modelsGetTrainingStatusResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsGetTrainingStatusResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsGetTrainingStatusResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsGetTrainingStatusResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type modelsGetTrainingStatusResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsGetTrainingStatusResponseComposite = modelsGetTrainingStatusResponse200 | modelsGetTrainingStatusResponse400 | modelsGetTrainingStatusResponse401 | modelsGetTrainingStatusResponse403 | modelsGetTrainingStatusResponse404 | modelsGetTrainingStatusResponse500;
    
export type modelsGetTrainingStatusResponse = modelsGetTrainingStatusResponseComposite & {
  headers: Headers;
}

export const getModelsGetTrainingStatusUrl = (params: ModelsGetTrainingStatusParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/models/getTrainingStatus?${stringifiedParams}` : `https://api.fiddl.art/api/models/getTrainingStatus`
}

export const modelsGetTrainingStatus = async (params: ModelsGetTrainingStatusParams, options?: RequestInit): Promise<modelsGetTrainingStatusResponse> => {
  
  const res = await fetch(getModelsGetTrainingStatusUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsGetTrainingStatusResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsGetTrainingStatusResponse
}



export type modelsDeleteModelResponse200 = {
  data: unknown
  status: 200
}

export type modelsDeleteModelResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsDeleteModelResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsDeleteModelResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsDeleteModelResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsDeleteModelResponseComposite = modelsDeleteModelResponse200 | modelsDeleteModelResponse400 | modelsDeleteModelResponse401 | modelsDeleteModelResponse403 | modelsDeleteModelResponse500;
    
export type modelsDeleteModelResponse = modelsDeleteModelResponseComposite & {
  headers: Headers;
}

export const getModelsDeleteModelUrl = () => {


  

  return `https://api.fiddl.art/api/models/deleteModel`
}

export const modelsDeleteModel = async (modelsDeleteModelBody: ModelsDeleteModelBody, options?: RequestInit): Promise<modelsDeleteModelResponse> => {
  
  const res = await fetch(getModelsDeleteModelUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      modelsDeleteModelBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsDeleteModelResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsDeleteModelResponse
}



export type modelsGetModelResponse200 = {
  data: ModelsGetModel200
  status: 200
}

export type modelsGetModelResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsGetModelResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsGetModelResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsGetModelResponse404 = {
  data: ErrorNOTFOUND
  status: 404
}

export type modelsGetModelResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsGetModelResponseComposite = modelsGetModelResponse200 | modelsGetModelResponse400 | modelsGetModelResponse401 | modelsGetModelResponse403 | modelsGetModelResponse404 | modelsGetModelResponse500;
    
export type modelsGetModelResponse = modelsGetModelResponseComposite & {
  headers: Headers;
}

export const getModelsGetModelUrl = (params: ModelsGetModelParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://api.fiddl.art/api/models/getModel?${stringifiedParams}` : `https://api.fiddl.art/api/models/getModel`
}

export const modelsGetModel = async (params: ModelsGetModelParams, options?: RequestInit): Promise<modelsGetModelResponse> => {
  
  const res = await fetch(getModelsGetModelUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsGetModelResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsGetModelResponse
}



export type modelsSetModelPrivacyResponse200 = {
  data: unknown
  status: 200
}

export type modelsSetModelPrivacyResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type modelsSetModelPrivacyResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type modelsSetModelPrivacyResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type modelsSetModelPrivacyResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type modelsSetModelPrivacyResponseComposite = modelsSetModelPrivacyResponse200 | modelsSetModelPrivacyResponse400 | modelsSetModelPrivacyResponse401 | modelsSetModelPrivacyResponse403 | modelsSetModelPrivacyResponse500;
    
export type modelsSetModelPrivacyResponse = modelsSetModelPrivacyResponseComposite & {
  headers: Headers;
}

export const getModelsSetModelPrivacyUrl = () => {


  

  return `https://api.fiddl.art/api/models/setModelPrivacy`
}

export const modelsSetModelPrivacy = async (modelsSetModelPrivacyBody: ModelsSetModelPrivacyBody, options?: RequestInit): Promise<modelsSetModelPrivacyResponse> => {
  
  const res = await fetch(getModelsSetModelPrivacyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      modelsSetModelPrivacyBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: modelsSetModelPrivacyResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as modelsSetModelPrivacyResponse
}



export type adminLoginAsUserResponse200 = {
  data: string
  status: 200
}

export type adminLoginAsUserResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type adminLoginAsUserResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type adminLoginAsUserResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type adminLoginAsUserResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type adminLoginAsUserResponseComposite = adminLoginAsUserResponse200 | adminLoginAsUserResponse400 | adminLoginAsUserResponse401 | adminLoginAsUserResponse403 | adminLoginAsUserResponse500;
    
export type adminLoginAsUserResponse = adminLoginAsUserResponseComposite & {
  headers: Headers;
}

export const getAdminLoginAsUserUrl = () => {


  

  return `https://api.fiddl.art/api/admin/loginAsUser`
}

export const adminLoginAsUser = async (adminLoginAsUserBody: AdminLoginAsUserBody, options?: RequestInit): Promise<adminLoginAsUserResponse> => {
  
  const res = await fetch(getAdminLoginAsUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      adminLoginAsUserBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: adminLoginAsUserResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as adminLoginAsUserResponse
}



export type privyAuthenticateResponse200 = {
  data: PrivyAuthenticate200
  status: 200
}

export type privyAuthenticateResponse400 = {
  data: ErrorBADREQUEST
  status: 400
}

export type privyAuthenticateResponse401 = {
  data: ErrorUNAUTHORIZED
  status: 401
}

export type privyAuthenticateResponse403 = {
  data: ErrorFORBIDDEN
  status: 403
}

export type privyAuthenticateResponse500 = {
  data: ErrorINTERNALSERVERERROR
  status: 500
}
    
export type privyAuthenticateResponseComposite = privyAuthenticateResponse200 | privyAuthenticateResponse400 | privyAuthenticateResponse401 | privyAuthenticateResponse403 | privyAuthenticateResponse500;
    
export type privyAuthenticateResponse = privyAuthenticateResponseComposite & {
  headers: Headers;
}

export const getPrivyAuthenticateUrl = () => {


  

  return `https://api.fiddl.art/api/privy/authenticate`
}

export const privyAuthenticate = async (privyAuthenticateBody: PrivyAuthenticateBody, options?: RequestInit): Promise<privyAuthenticateResponse> => {
  
  const res = await fetch(getPrivyAuthenticateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      privyAuthenticateBody,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text()
  const data: privyAuthenticateResponse['data'] = body ? JSON.parse(body) : {}

  return { data, status: res.status, headers: res.headers } as privyAuthenticateResponse
}
