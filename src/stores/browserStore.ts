import { defineStore } from "pinia"
import { creationsBrowseCreateRequests, type CreationsBrowseCreateRequests200Item } from "src/lib/orval"
import { img, s3Video } from "lib/netlifyImg"
import { SortMethod } from "fiddl-server/dist/lib/types/serverTypes"
import type { MediaGalleryMeta } from "src/types/media-gallery"
import type { MediaType } from "lib/types"
import { useCreatorStore } from "src/stores/creatorStore"
import { extractAspectRatioFromMeta, getCachedAspectRatio, parseAspectRatio, rememberAspectRatio } from "lib/aspectRatio"

function resolveAspectRatio(row: BrowseRow, mediaId: string, mediaItem: { [key: string]: unknown }): number | undefined {
  const rowRatio = parseAspectRatio(row.aspectRatio)
  if (typeof rowRatio === "number") {
    rememberAspectRatio(mediaId, rowRatio)
    return rowRatio
  }

  const mediaRatio = parseAspectRatio((mediaItem as unknown as { aspectRatio?: unknown })?.aspectRatio)
  if (typeof mediaRatio === "number") {
    rememberAspectRatio(mediaId, mediaRatio)
    return mediaRatio
  }

  const metaRatio = extractAspectRatioFromMeta((row as unknown as { meta?: unknown }).meta)
  if (typeof metaRatio === "number") {
    rememberAspectRatio(mediaId, metaRatio)
    return metaRatio
  }

  return getCachedAspectRatio(mediaId)
}

export const sortMethodIcon: Record<SortMethod, string> = {
  latest: "sym_o_overview",
  popular: "star",
  shuffle: "shuffle",
}

export const mediaTypeIcon: Record<MediaTypeFilter, string> = {
  all: "all_inclusive",
  image: "sym_o_image",
  video: "sym_o_video_library",
}

/** Internal store item */
export interface MediaItem extends MediaGalleryMeta {
  createdAt: Date
}

/** Row returned from creationsBrowseCreateRequests (generated by Orval) */
type BrowseRow = CreationsBrowseCreateRequests200Item
type MediaTypeFilter = MediaType | "all"

export const useBrowserStore = defineStore("browserStore", {
  state: (): {
    media: MediaItem[]
    loading: boolean
    search: string | null
    randomSeed: number
    filter: {
      aspectRatio?: string
      model?: string
      sort: SortMethod
      mediaType: MediaTypeFilter
    }
  } => ({
    media: [],
    loading: false,
    search: null,
    randomSeed: Math.floor(Math.random() * Number.MAX_SAFE_INTEGER),
    filter: { sort: "shuffle", mediaType: "all" },
  }),

  getters: {
    /** legacy alias â€“ other pages still reference items */
    items(state): MediaItem[] {
      return state.media
    },
    newestFirst(state): MediaItem[] {
      return [...state.media].sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())
    },
    filterActive(state): boolean {
      return !!state.filter.aspectRatio || !!state.filter.model
    },
  },

  actions: {
    // all properties of filter are being watched to trigger a reset
    setSort(method: SortMethod) {
      this.filter.sort = method
      // this.reset() // refresh list
    },
    setMediaType(type: MediaTypeFilter) {
      this.filter = { ...this.filter, mediaType: type, model: undefined }
    },
    resetFilters() {
      this.filter.aspectRatio = undefined
      this.filter.model = undefined
      this.filter.sort = "shuffle"
      this.reset()
    },
    reset() {
      this.media = []
      void this.loadCreations()
    },
    searchCreations() {
      this.media = []
      void this.loadCreations()
    },
    deleteMedia(id: string) {
      this.media = this.media.filter((m) => m.id !== id)
    },

    removeMedia(id: string) {
      this.media = this.media.filter((item) => item.id !== id)
    },

    /* ---------- main loaders ---------- */
    async loadCreations() {
      this.loading = true
      const last = this.media[this.media.length - 1]

      try {
        const { data } = await creationsBrowseCreateRequests({
          order: "desc",
          endDateTime: last?.createdAt.toISOString(),
          limit: 100,
          promptIncludes: this.search || undefined,
          aspectRatio: this.filter.aspectRatio as any,
          model: this.filter.model as any,
          randomSeed: this.filter.sort === "shuffle" ? this.randomSeed : undefined,
          sortMethod: this.filter.sort,
          mediaType: this.filter.mediaType,
        })
        this.addBatch(data as unknown as BrowseRow[])
      } catch (err) {
        console.error("loadCreations failed", err)
      } finally {
        this.loading = false
      }
    },

    async loadRecentCreations() {
      if (this.filter.sort !== "latest") return
      this.loading = true
      const first = this.media[0]

      try {
        const { data } = await creationsBrowseCreateRequests({
          order: "asc",
          startDateTime: first?.createdAt.toISOString(),
          limit: 100,
          promptIncludes: this.search || undefined,
          aspectRatio: this.filter.aspectRatio as any,
          model: this.filter.model as any,
          sortMethod: this.filter.sort,
          mediaType: this.filter.mediaType,
        })
        this.addBatch(data as unknown as BrowseRow[], true)
      } catch (err) {
        console.error("loadRecentCreations failed", err)
      } finally {
        this.loading = false
      }
    },

    /* ---------- internal util ---------- */
    addBatch(rows: BrowseRow[], prepend = false) {
      const MAX_ITEMS = 1500 // soft cap to prevent unbounded memory growth
      const creatorStore = useCreatorStore()
      const creatorsToRemember: { id?: string | null; username?: string | null }[] = []
      for (const row of rows) {
        // Normalize media to a proper array
        let medias: { id: string; nsfw?: boolean }[] = []
        // Primary path: new API shape (array of media items)
        if (Array.isArray((row as any).media)) {
          medias = (row as any).media as { id: string; nsfw?: boolean }[]
        } else if (typeof (row as any).media === "string") {
          // Fallback for older servers that returned JSON string
          try {
            const parsed = JSON.parse((row as any).media) as unknown
            if (Array.isArray(parsed)) medias = parsed as { id: string; nsfw?: boolean }[]
          } catch {
            /* ignore parse errors */
          }
        }

        if (medias.length === 0) continue

        const t = row.mediaType
        const creatorId = (row as any)?.user?.id
        let creatorUsername = (row as any)?.user?.username as string | undefined
        if (creatorId && !creatorUsername) {
          creatorUsername = creatorStore.getUsername(creatorId)
        }
        if (creatorId && creatorUsername) {
          creatorsToRemember.push({ id: creatorId, username: creatorUsername })
        }

        for (const m of medias) {
          if (this.media.find((e) => e.id === m.id)) continue

          const aspectRatio = resolveAspectRatio(row, m.id, m)

          const item: MediaItem = {
            id: m.id,
            url: t === "image" ? img(m.id, "md") : s3Video(m.id, "preview-md"),
            type: t,
            aspectRatio,
            createdAt: new Date(row.createdAt),
            nsfw: m.nsfw === true,
            // Pass-through creator metadata from the nested user object
            creatorId,
            creatorUsername,
            requestId: (row as any)?.id,
            requestType: t,
          }

          if (prepend) {
            this.media.unshift(item)
          } else {
            this.media.push(item)
          }
        }
      }
      if (creatorsToRemember.length) {
        void creatorStore.rememberMany(creatorsToRemember)
      }
      // Trim to cap to avoid DOM and memory blow-up on extremely long sessions
      if (this.media.length > MAX_ITEMS) {
        const excess = this.media.length - MAX_ITEMS
        if (prepend) {
          // Added to the top; drop from the bottom (oldest loaded tail)
          this.media.splice(MAX_ITEMS)
        } else {
          // Added to the bottom; drop from the top (newest head)
          this.media.splice(0, excess)
        }
      }
    },
  },

  persist: false,
})
