/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Fiddl.art API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

export type ErrorBADREQUESTIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorBADREQUEST {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorBADREQUESTIssuesItem[];
}

export type ErrorUNAUTHORIZEDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorUNAUTHORIZED {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorUNAUTHORIZEDIssuesItem[];
}

export type ErrorFORBIDDENIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorFORBIDDEN {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorFORBIDDENIssuesItem[];
}

export type ErrorINTERNALSERVERERRORIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorINTERNALSERVERERROR {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorINTERNALSERVERERRORIssuesItem[];
}

export type ErrorNOTFOUNDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorNOTFOUND {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorNOTFOUNDIssuesItem[];
}

export type PkAuthRegisterStartBody = {
  email?: string;
  phone?: string;
  referredByUserName?: string;
};

export type PkAuthRegisterFinishBody = {
  userId: string;
  data?: unknown;
};

export type PkAuthLoginStartBody = {
  userId: string;
};

export type PkAuthLoginFinishBody = {
  userId: string;
  data?: unknown;
};

export type CreateImageBodyModel = typeof CreateImageBodyModel[keyof typeof CreateImageBodyModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreateImageBodyAspectRatio = typeof CreateImageBodyAspectRatio[keyof typeof CreateImageBodyAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreateImageBody = {
  prompt: string;
  negativePrompt?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  quantity: number;
  seed?: number;
  model: CreateImageBodyModel;
  public?: boolean;
  aspectRatio?: CreateImageBodyAspectRatio;
  customModelId?: string;
};

export type CreateImage200 = {
  ids: string[];
  id: string;
  errors: string[];
};

export type CreateRandomPromptBody = {
  theme?: string;
};

export type CreateImprovePromptBody = {
  prompt: string;
};

export type CreationsImageDataParams = {
imageId: string;
};

export type CreationsImageData200 = {
  id: string;
  createdAt: string;
  imageRequestId: string;
  seed?: number;
  creatorId: string;
  numCollections: number;
};

export type CreationsUserImagePurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserImagePurchasesOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: CreationsUserImagePurchasesModel;
aspectRatio?: CreationsUserImagePurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserImagePurchasesOrder = typeof CreationsUserImagePurchasesOrder[keyof typeof CreationsUserImagePurchasesOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsUserImagePurchasesModel = typeof CreationsUserImagePurchasesModel[keyof typeof CreationsUserImagePurchasesModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsUserImagePurchasesAspectRatio = typeof CreationsUserImagePurchasesAspectRatio[keyof typeof CreationsUserImagePurchasesAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsUserImagePurchases200Item = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

export type CreationsCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateRequestsOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: CreationsCreateRequestsModel;
aspectRatio?: CreationsCreateRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateRequestsOrder = typeof CreationsCreateRequestsOrder[keyof typeof CreationsCreateRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsCreateRequestsModel = typeof CreationsCreateRequestsModel[keyof typeof CreationsCreateRequestsModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsCreateRequestsAspectRatio = typeof CreationsCreateRequestsAspectRatio[keyof typeof CreationsCreateRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsCreateRequests200Item = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsCreateRequestParams = {
requestId: string;
};

export type CreationsCreateRequest200 = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsBrowseCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsBrowseCreateRequestsOrder;
endDateTime?: string;
promptIncludes?: string;
model?: CreationsBrowseCreateRequestsModel;
aspectRatio?: CreationsBrowseCreateRequestsAspectRatio;
customModelId?: string;
};

export type CreationsBrowseCreateRequestsOrder = typeof CreationsBrowseCreateRequestsOrder[keyof typeof CreationsBrowseCreateRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsBrowseCreateRequestsModel = typeof CreationsBrowseCreateRequestsModel[keyof typeof CreationsBrowseCreateRequestsModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
} as const;

export type CreationsBrowseCreateRequestsAspectRatio = typeof CreationsBrowseCreateRequestsAspectRatio[keyof typeof CreationsBrowseCreateRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
} as const;

export type CreationsHdImageParams = {
imageId: string;
};

export type CreationsOriginalImageParams = {
imageId: string;
};

export type CreationsUpscaledImageParams = {
imageId: string;
};

export type CreationsPurchaseImageBody = {
  imageId: string;
};

export type CreationsPurchaseImage200 = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

export type CreationsDeleteImageBody = {
  imageId: string;
};

export type CreationsDeleteRequestBody = {
  requestId: string;
};

export type CreationsSetRequestPrivacyBody = {
  requestId: string;
  public: boolean;
};

export type PointsPackagesAvailable200Item = {
  points: number;
  discountPct: number;
  usd: number;
};

export type PointsPrices200 = {
  createTrainingSet: number;
};

export type PointsInitBuyPackageBodyMethod = typeof PointsInitBuyPackageBodyMethod[keyof typeof PointsInitBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackageBody = {
  packageId: number;
  method: PointsInitBuyPackageBodyMethod;
};

export type PointsInitBuyPackage200AnyOfLinksItem = {
  href: string;
  rel: string;
  method: string;
};

export type PointsInitBuyPackage200AnyOf = {
  id: string;
  status: string;
  links: PointsInitBuyPackage200AnyOfLinksItem[];
};

export type PointsInitBuyPackage200AnyOfThreeChainName = typeof PointsInitBuyPackage200AnyOfThreeChainName[keyof typeof PointsInitBuyPackage200AnyOfThreeChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackage200AnyOfThreeTokenType = typeof PointsInitBuyPackage200AnyOfThreeTokenType[keyof typeof PointsInitBuyPackage200AnyOfThreeTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsInitBuyPackage200AnyOfThree = {
  chainName: PointsInitBuyPackage200AnyOfThreeChainName;
  tokenType: PointsInitBuyPackage200AnyOfThreeTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsInitBuyPackage200 = PointsInitBuyPackage200AnyOf | PointsInitBuyPackage200AnyOfThree;

export type PointsFinishBuyPackageBodyMethod = typeof PointsFinishBuyPackageBodyMethod[keyof typeof PointsFinishBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsFinishBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsFinishBuyPackageBody = {
  orderId: string;
  method: PointsFinishBuyPackageBodyMethod;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount = {
  currency_code: string;
  value: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItem = {
  reference_id: string;
  amount: PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount;
};

export type PointsFinishBuyPackage200AnyOf = {
  id: string;
  status: string;
  purchase_units: PointsFinishBuyPackage200AnyOfPurchaseUnitsItem[];
};

export type PointsFinishBuyPackage200AnyOfFour = {
  status: string;
};

export type PointsFinishBuyPackage200 = PointsFinishBuyPackage200AnyOf | PointsFinishBuyPackage200AnyOfFour;

export type PointsGetOrders200PayPalOrdersItem = {
  id: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrders200CryptoOrdersItemChainName = typeof PointsGetOrders200CryptoOrdersItemChainName[keyof typeof PointsGetOrders200CryptoOrdersItemChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrders200CryptoOrdersItemChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrders200CryptoOrdersItem = {
  id: string;
  chainName: PointsGetOrders200CryptoOrdersItemChainName;
  tokenAmount: number;
  usdValue: number;
  confirmed: boolean;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsGetOrders200 = {
  payPalOrders: PointsGetOrders200PayPalOrdersItem[];
  cryptoOrders: PointsGetOrders200CryptoOrdersItem[];
};

export type PointsGetOrderParams = {
id: string;
method: PointsGetOrderMethod;
};

export type PointsGetOrderMethod = typeof PointsGetOrderMethod[keyof typeof PointsGetOrderMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrderMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOf = {
  id: string;
  userId: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  packageDetailsJSON: string;
  /** @nullable */
  orderDataJSON: string | null;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrder200AnyOfTwoChainName = typeof PointsGetOrder200AnyOfTwoChainName[keyof typeof PointsGetOrder200AnyOfTwoChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOfTwoTokenType = typeof PointsGetOrder200AnyOfTwoTokenType[keyof typeof PointsGetOrder200AnyOfTwoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsGetOrder200AnyOfTwo = {
  chainName: PointsGetOrder200AnyOfTwoChainName;
  tokenType: PointsGetOrder200AnyOfTwoTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsGetOrder200 = PointsGetOrder200AnyOf | PointsGetOrder200AnyOfTwo;

export type UserGetParams = {
userId: string;
};

/**
 * @nullable
 */
export type UserGet200AvatarConfig = {
  imageId: string;
} | null;

export type UserGet200 = {
  id: string;
  /** @nullable */
  privyId: string | null;
  /** @nullable */
  webauthnUserID: string | null;
  /** @nullable */
  currentPassKeyChallenge: string | null;
  admin: boolean;
  availablePoints: number;
  createdAt: string;
  updatedAt: string;
  spentPoints: number;
  /** @nullable */
  referredById: string | null;
  lastNotificationSent: string;
  /** @nullable */
  AvatarConfig: UserGet200AvatarConfig;
};

export type UserProfileParams = {
userId: string;
};

export type UserProfile200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

export type UserPublicProfileParams = {
userId: string;
};

export type UserPublicProfile200Profile = {
  /** @nullable */
  username: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
};

export type UserPublicProfile200 = {
  profile: UserPublicProfile200Profile;
  imagesCreated: number;
  imagesFavorited: number;
};

export type UserGetUsernameParams = {
userId: string;
};

export type UserSetUsernameBody = {
  username: string;
};

export type UserSetUsername200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

export type UserSetBioBody = {
  bio: string;
};

export type UserSetBio200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  lastUsernameChange: string | null;
};

export type UserSendVerificationEmailBody = {
  email: string;
};

export type UserPointsHistoryParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: UserPointsHistoryOrder;
endDateTime?: string;
includeMetadata?: boolean;
};

export type UserPointsHistoryOrder = typeof UserPointsHistoryOrder[keyof typeof UserPointsHistoryOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistoryOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UserPointsHistory200ItemType = typeof UserPointsHistory200ItemType[keyof typeof UserPointsHistory200ItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistory200ItemType = {
  purchase: 'purchase',
  refund: 'refund',
  commission: 'commission',
  comission: 'comission',
  bonus: 'bonus',
  referral: 'referral',
  promoCode: 'promoCode',
  createModel: 'createModel',
  cryptoDeposit: 'cryptoDeposit',
  createTrainingSet: 'createTrainingSet',
} as const;

export type UserPointsHistory200Item = {
  type: UserPointsHistory200ItemType;
  id: string;
  createdAt: string;
  /** @nullable */
  memo: string | null;
  quantity: number;
  userFinalBalance: number;
};

export type UserFindByUsernameParams = {
username: string;
};

export type UserFindByEmailParams = {
email: string;
};

export type UserFindByPhoneParams = {
phone: string;
};

export type UserFindByPrivyIdParams = {
privyId: string;
};

export type UserGetNotificationConfig200EmailFrequency = typeof UserGetNotificationConfig200EmailFrequency[keyof typeof UserGetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200PhoneFrequency = typeof UserGetNotificationConfig200PhoneFrequency[keyof typeof UserGetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200 = {
  emailFrequency: UserGetNotificationConfig200EmailFrequency;
  phoneFrequency: UserGetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

export type UserSetNotificationConfigBodyEmailFrequency = typeof UserSetNotificationConfigBodyEmailFrequency[keyof typeof UserSetNotificationConfigBodyEmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyEmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBodyPhoneFrequency = typeof UserSetNotificationConfigBodyPhoneFrequency[keyof typeof UserSetNotificationConfigBodyPhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyPhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBody = {
  email?: boolean;
  phone?: boolean;
  emailFrequency?: UserSetNotificationConfigBodyEmailFrequency;
  phoneFrequency?: UserSetNotificationConfigBodyPhoneFrequency;
};

export type UserSetNotificationConfig200EmailFrequency = typeof UserSetNotificationConfig200EmailFrequency[keyof typeof UserSetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200PhoneFrequency = typeof UserSetNotificationConfig200PhoneFrequency[keyof typeof UserSetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200 = {
  emailFrequency: UserSetNotificationConfig200EmailFrequency;
  phoneFrequency: UserSetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

export type UserUnsubscribeEmailNotificationsBody = { [key: string]: unknown };

export type UserSetAvatarBodyPosition = {
  x: number;
  y: number;
};

export type UserSetAvatarBody = {
  imageId: string;
  scale: number;
  position: UserSetAvatarBodyPosition;
};

/**
 * @nullable
 */
export type UserAllUsers200ItemProfile = {
  /** @nullable */
  bio: string | null;
  /** @nullable */
  username: string | null;
} | null;

export type UserAllUsers200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  Profile: UserAllUsers200ItemProfile;
};

export type LoginLinkInitLoginLinkBody = {
  email?: string;
  phoneNumber?: string;
  referredBy?: string;
};

export type LoginLinkLoginWithLinkBody = {
  linkId: string;
};

export type LoginLinkLoginWithLink200 = {
  token: string;
  userId: string;
};

export type StatsUsers200 = {
  spentPoints: number;
  spentOver100Points: number;
  spentOver1000Points: number;
  spentOver10000Points: number;
  spentOver20000Points: number;
  purchasedImage: number;
  createdImage: number;
  emailVerified: number;
  phoneVerified: number;
  instagramVerified: number;
  twitterVerified: number;
  setUsername: number;
};

export type _StatsImages200AverageImageQuantityPerCreateRequestAvg = {
  /** @nullable */
  quantity: number | null;
};

export type StatsImages200AverageImageQuantityPerCreateRequest = {
  _avg: _StatsImages200AverageImageQuantityPerCreateRequestAvg;
};

export type StatsImages200 = {
  totalCreated: number;
  totalUpscaled: number;
  totalImageCreateRequests: number;
  averageImageQuantityPerCreateRequest: StatsImages200AverageImageQuantityPerCreateRequest;
  purchasedImages: number;
  totalPurchases: number;
  privateImages: number;
  imagesInAtLeastOneCollection: number;
  imageCreationFailed: number;
};

export type StatsCollections200 = {
  collectionsCreated: number;
  emptyCollections: number;
};

export type _StatsPayments200PaypalOrdersTotalPaidSum = {
  /** @nullable */
  amount: number | null;
};

export type StatsPayments200PaypalOrdersTotalPaid = {
  _sum: _StatsPayments200PaypalOrdersTotalPaidSum;
};

export type StatsPayments200 = {
  incompletePayPayPalOrders: number;
  completePayPayPalOrders: number;
  paypalOrdersTotalPaid: StatsPayments200PaypalOrdersTotalPaid;
};

export type CollectionsImageInUsersCollectionParams = {
name: string;
imageId: string;
};

export type CollectionsLikeImageBody = {
  imageId: string;
};

export type CollectionsUnlikeImageBody = {
  imageId: string;
};

export type CollectionsGetCollectionMetaParams = {
id: string;
};

export type _CollectionsGetCollectionMeta200Count = {
  Images: number;
  Favorited: number;
};

export type CollectionsGetCollectionMeta200 = {
  id: string;
  name: string;
  description: string;
  ownerId: string;
  private: boolean;
  _count: _CollectionsGetCollectionMeta200Count;
};

export type CollectionsFindCollectionByNameParams = {
ownerId: string;
collectionName: string;
};

export type CollectionsFindCollectionByName200 = {
  id: string;
};

export type CollectionsGetCollectionImagesParams = {
id: string;
};

export type CollectionsGetCollectionImages200ItemImageRequest = {
  userId: string;
};

export type CollectionsGetCollectionImages200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  imageRequestId: string;
  seed: string;
  errored: boolean;
  filtered: boolean;
  deleted: boolean;
  imageRequest: CollectionsGetCollectionImages200ItemImageRequest;
};

export type PromoCreatePromoCodeBody = {
  points: number;
};

export type PromoCreatePromoCode200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoDeletePromoCodeBody = {
  id: string;
};

export type PromoGetPromoCodes200Item = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoGetPromoCodeDetailsParams = {
id: string;
};

export type PromoGetPromoCodeDetails200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoClaimPromoCodeBody = {
  id: string;
};

export type ModelsSetModelNameBody = {
  id: string;
  name: string;
};

export type ModelsGetUserModels200ItemStatus = typeof ModelsGetUserModels200ItemStatus[keyof typeof ModelsGetUserModels200ItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetUserModels200ItemModelType = typeof ModelsGetUserModels200ItemModelType[keyof typeof ModelsGetUserModels200ItemModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

export type ModelsGetUserModels200ItemTrainingPreset = typeof ModelsGetUserModels200ItemTrainingPreset[keyof typeof ModelsGetUserModels200ItemTrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemTrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
  custom: 'custom',
} as const;

export type ModelsGetUserModels200ItemImageRequestsItemImagesItem = {
  id: string;
};

export type ModelsGetUserModels200ItemImageRequestsItem = {
  id: string;
  images: ModelsGetUserModels200ItemImageRequestsItemImagesItem[];
};

export type ModelsGetUserModels200Item = {
  status: ModelsGetUserModels200ItemStatus;
  modelType: ModelsGetUserModels200ItemModelType;
  trainingPreset: ModelsGetUserModels200ItemTrainingPreset;
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  trainingError: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  imageRequests: ModelsGetUserModels200ItemImageRequestsItem[];
};

export type ModelsCreateModelBodyType = typeof ModelsCreateModelBodyType[keyof typeof ModelsCreateModelBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyType = {
  faceForge: 'faceForge',
} as const;

export type ModelsCreateModelBodyTrainingPreset = typeof ModelsCreateModelBodyTrainingPreset[keyof typeof ModelsCreateModelBodyTrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyTrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
} as const;

export type ModelsCreateModelBody = {
  name: string;
  type: ModelsCreateModelBodyType;
  trainingPreset: ModelsCreateModelBodyTrainingPreset;
};

export type ModelsGetTrainingStatusParams = {
id: string;
};

export type ModelsGetTrainingStatus200Input = {[key: string]: unknown};

export type ModelsGetTrainingStatus200Source = typeof ModelsGetTrainingStatus200Source[keyof typeof ModelsGetTrainingStatus200Source];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetTrainingStatus200Source = {
  api: 'api',
  web: 'web',
} as const;

export type ModelsGetTrainingStatus200Metrics = {
  predict_time?: number;
};

export type ModelsGetTrainingStatus200Urls = {
  get: string;
  cancel: string;
  stream?: string;
};

export type ModelsGetTrainingStatus200 = {
  id: string;
  status: string;
  model: string;
  version: string;
  input: ModelsGetTrainingStatus200Input;
  output?: unknown;
  source: ModelsGetTrainingStatus200Source;
  error?: unknown;
  logs?: string;
  metrics?: ModelsGetTrainingStatus200Metrics;
  webhook?: string;
  webhook_events_filter?: string[];
  created_at: string;
  started_at?: string;
  completed_at?: string;
  urls: ModelsGetTrainingStatus200Urls;
};

export type ModelsDeleteModelBody = {
  id: string;
};

export type ModelsGetModelParams = {
id: string;
};

export type ModelsGetModel200Status = typeof ModelsGetModel200Status[keyof typeof ModelsGetModel200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200Status = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetModel200ModelType = typeof ModelsGetModel200ModelType[keyof typeof ModelsGetModel200ModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200ModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

export type ModelsGetModel200TrainingPreset = typeof ModelsGetModel200TrainingPreset[keyof typeof ModelsGetModel200TrainingPreset];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetModel200TrainingPreset = {
  simple: 'simple',
  normal: 'normal',
  advanced: 'advanced',
  extreme: 'extreme',
  custom: 'custom',
} as const;

export type ModelsGetModel200 = {
  status: ModelsGetModel200Status;
  modelType: ModelsGetModel200ModelType;
  trainingPreset: ModelsGetModel200TrainingPreset;
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  trainingError: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
};

export type ModelsSetModelPrivacyBody = {
  id: string;
  public: boolean;
};

export type AdminLoginAsUserBody = {
  id: string;
};

export type PrivyAuthenticateBody = {
  accessToken: string;
  referrerUsername?: string;
};

export type PrivyAuthenticate200 = {
  token: string;
  userId: string;
};

export type TrainingSetsCreateSetBodyType = typeof TrainingSetsCreateSetBodyType[keyof typeof TrainingSetsCreateSetBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrainingSetsCreateSetBodyType = {
  subject: 'subject',
  style: 'style',
} as const;

export type TrainingSetsCreateSetBody = {
  /** @maxLength 30 */
  name: string;
  type: TrainingSetsCreateSetBodyType;
  /** @maxLength 400 */
  description: string;
  /**
   * @minimum 1
   * @maximum 200
   */
  numImages: number;
  /** @maximum 800 */
  zipSizeMb: number;
};

export type TrainingSetsCreateSet200SignedZipUploadDataFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedZipUploadData = {
  url: string;
  fields: TrainingSetsCreateSet200SignedZipUploadDataFields;
};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItem = {
  url: string;
  fields: TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields;
};

export type TrainingSetsCreateSet200 = {
  trainingSetId: string;
  signedZipUploadData: TrainingSetsCreateSet200SignedZipUploadData;
  signedThumbnailUploadDatas: TrainingSetsCreateSet200SignedThumbnailUploadDatasItem[];
};

export type TrainingSetsFinalizeSetBody = {
  trainingSetId: string;
};

export type TrainingSetsGetUserSetsParams = {
userId: string;
};

export type TrainingSetsGetUserSets200ItemType = typeof TrainingSetsGetUserSets200ItemType[keyof typeof TrainingSetsGetUserSets200ItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrainingSetsGetUserSets200ItemType = {
  subject: 'subject',
  style: 'style',
} as const;

export type TrainingSetsGetUserSets200Item = {
  type: TrainingSetsGetUserSets200ItemType;
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  updatedAt: string;
  deleted: boolean;
  /** @nullable */
  description: string | null;
};

export type TrainingSetsGetSetParams = {
trainingSetId: string;
};

export type TrainingSetsGetSet200Type = typeof TrainingSetsGetSet200Type[keyof typeof TrainingSetsGetSet200Type];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const TrainingSetsGetSet200Type = {
  subject: 'subject',
  style: 'style',
} as const;

export type TrainingSetsGetSet200 = {
  type: TrainingSetsGetSet200Type;
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  updatedAt: string;
  deleted: boolean;
  /** @nullable */
  description: string | null;
};

export type TrainingSetsDeleteSetBody = {
  trainingSetId: string;
};

export type TrainingSetsEditSetBody = {
  trainingSetId: string;
  /** @maxLength 32 */
  newName: string;
  /** @maxLength 400 */
  newDescription: string;
};

export const pkAuthRegisterStart = (
    pkAuthRegisterStartBody: MaybeRef<PkAuthRegisterStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterStartBody = unref(pkAuthRegisterStartBody);
    
    return axios.post(
      `/pkAuth/registerStart`,
      pkAuthRegisterStartBody,options
    );
  }



export const getPkAuthRegisterStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext> => {

const mutationKey = ['pkAuthRegisterStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterStart>>, {data: PkAuthRegisterStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterStart>>>
    export type PkAuthRegisterStartMutationBody = PkAuthRegisterStartBody
    export type PkAuthRegisterStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterStart>>,
        TError,
        {data: PkAuthRegisterStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthRegisterFinish = (
    pkAuthRegisterFinishBody: MaybeRef<PkAuthRegisterFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterFinishBody = unref(pkAuthRegisterFinishBody);
    
    return axios.post(
      `/pkAuth/registerFinish`,
      pkAuthRegisterFinishBody,options
    );
  }



export const getPkAuthRegisterFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext> => {

const mutationKey = ['pkAuthRegisterFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, {data: PkAuthRegisterFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterFinish>>>
    export type PkAuthRegisterFinishMutationBody = PkAuthRegisterFinishBody
    export type PkAuthRegisterFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterFinish>>,
        TError,
        {data: PkAuthRegisterFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginStart = (
    pkAuthLoginStartBody: MaybeRef<PkAuthLoginStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginStartBody = unref(pkAuthLoginStartBody);
    
    return axios.post(
      `/pkAuth/loginStart`,
      pkAuthLoginStartBody,options
    );
  }



export const getPkAuthLoginStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext> => {

const mutationKey = ['pkAuthLoginStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginStart>>, {data: PkAuthLoginStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginStart>>>
    export type PkAuthLoginStartMutationBody = PkAuthLoginStartBody
    export type PkAuthLoginStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginStart>>,
        TError,
        {data: PkAuthLoginStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginFinish = (
    pkAuthLoginFinishBody: MaybeRef<PkAuthLoginFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginFinishBody = unref(pkAuthLoginFinishBody);
    
    return axios.post(
      `/pkAuth/loginFinish`,
      pkAuthLoginFinishBody,options
    );
  }



export const getPkAuthLoginFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext> => {

const mutationKey = ['pkAuthLoginFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginFinish>>, {data: PkAuthLoginFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginFinish>>>
    export type PkAuthLoginFinishMutationBody = PkAuthLoginFinishBody
    export type PkAuthLoginFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginFinish>>,
        TError,
        {data: PkAuthLoginFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImage = (
    createImageBody: MaybeRef<CreateImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateImage200>> => {
    createImageBody = unref(createImageBody);
    
    return axios.post(
      `/create/image`,
      createImageBody,options
    );
  }



export const getCreateImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext> => {

const mutationKey = ['createImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImage>>, {data: CreateImageBody}> = (props) => {
          const {data} = props ?? {};

          return  createImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImageMutationResult = NonNullable<Awaited<ReturnType<typeof createImage>>>
    export type CreateImageMutationBody = CreateImageBody
    export type CreateImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImage>>,
        TError,
        {data: CreateImageBody},
        TContext
      > => {

      const mutationOptions = getCreateImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createRandomPrompt = (
    createRandomPromptBody: MaybeRef<CreateRandomPromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createRandomPromptBody = unref(createRandomPromptBody);
    
    return axios.post(
      `/create/randomPrompt`,
      createRandomPromptBody,options
    );
  }



export const getCreateRandomPromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext> => {

const mutationKey = ['createRandomPrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRandomPrompt>>, {data: CreateRandomPromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createRandomPrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRandomPromptMutationResult = NonNullable<Awaited<ReturnType<typeof createRandomPrompt>>>
    export type CreateRandomPromptMutationBody = CreateRandomPromptBody
    export type CreateRandomPromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateRandomPrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createRandomPrompt>>,
        TError,
        {data: CreateRandomPromptBody},
        TContext
      > => {

      const mutationOptions = getCreateRandomPromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImprovePrompt = (
    createImprovePromptBody: MaybeRef<CreateImprovePromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createImprovePromptBody = unref(createImprovePromptBody);
    
    return axios.post(
      `/create/improvePrompt`,
      createImprovePromptBody,options
    );
  }



export const getCreateImprovePromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext> => {

const mutationKey = ['createImprovePrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImprovePrompt>>, {data: CreateImprovePromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createImprovePrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImprovePromptMutationResult = NonNullable<Awaited<ReturnType<typeof createImprovePrompt>>>
    export type CreateImprovePromptMutationBody = CreateImprovePromptBody
    export type CreateImprovePromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImprovePrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImprovePrompt>>,
        TError,
        {data: CreateImprovePromptBody},
        TContext
      > => {

      const mutationOptions = getCreateImprovePromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsImageData = (
    params: MaybeRef<CreationsImageDataParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsImageData200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/imageData`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsImageDataQueryKey = (params: MaybeRef<CreationsImageDataParams>,) => {
    return ['creations','imageData', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsImageDataQueryOptions = <TData = Awaited<ReturnType<typeof creationsImageData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsImageDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsImageData>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsImageDataQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsImageData>>> = ({ signal }) => creationsImageData(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsImageData>>, TError, TData> 
}

export type CreationsImageDataQueryResult = NonNullable<Awaited<ReturnType<typeof creationsImageData>>>
export type CreationsImageDataQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsImageData<TData = Awaited<ReturnType<typeof creationsImageData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsImageDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsImageData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsImageDataQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUserImagePurchases = (
    params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsUserImagePurchases200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/userImagePurchases`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUserImagePurchasesQueryKey = (params?: MaybeRef<CreationsUserImagePurchasesParams>,) => {
    return ['creations','userImagePurchases', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUserImagePurchasesQueryOptions = <TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUserImagePurchasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUserImagePurchases>>> = ({ signal }) => creationsUserImagePurchases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData> 
}

export type CreationsUserImagePurchasesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUserImagePurchases>>>
export type CreationsUserImagePurchasesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUserImagePurchases<TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUserImagePurchasesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateRequests = (
    params?: MaybeRef<CreationsCreateRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateRequestsQueryKey = (params?: MaybeRef<CreationsCreateRequestsParams>,) => {
    return ['creations','createRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateRequests>>> = ({ signal }) => creationsCreateRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequests>>, TError, TData> 
}

export type CreationsCreateRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateRequests>>>
export type CreationsCreateRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateRequests<TData = Awaited<ReturnType<typeof creationsCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateRequest = (
    params: MaybeRef<CreationsCreateRequestParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateRequest200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createRequest`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateRequestQueryKey = (params: MaybeRef<CreationsCreateRequestParams>,) => {
    return ['creations','createRequest', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateRequestQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsCreateRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateRequestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateRequest>>> = ({ signal }) => creationsCreateRequest(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequest>>, TError, TData> 
}

export type CreationsCreateRequestQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateRequest>>>
export type CreationsCreateRequestQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateRequest<TData = Awaited<ReturnType<typeof creationsCreateRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsCreateRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateRequestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsBrowseCreateRequests = (
    params?: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/browseCreateRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsBrowseCreateRequestsQueryKey = (params?: MaybeRef<CreationsBrowseCreateRequestsParams>,) => {
    return ['creations','browseCreateRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsBrowseCreateRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsBrowseCreateRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>> = ({ signal }) => creationsBrowseCreateRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData> 
}

export type CreationsBrowseCreateRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>>
export type CreationsBrowseCreateRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsBrowseCreateRequests<TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsBrowseCreateRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsHdImage = (
    params: MaybeRef<CreationsHdImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/hdImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsHdImageQueryKey = (params: MaybeRef<CreationsHdImageParams>,) => {
    return ['creations','hdImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsHdImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsHdImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsHdImage>>> = ({ signal }) => creationsHdImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData> 
}

export type CreationsHdImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsHdImage>>>
export type CreationsHdImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsHdImage<TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsHdImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsOriginalImage = (
    params: MaybeRef<CreationsOriginalImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/originalImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsOriginalImageQueryKey = (params: MaybeRef<CreationsOriginalImageParams>,) => {
    return ['creations','originalImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsOriginalImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsOriginalImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsOriginalImage>>> = ({ signal }) => creationsOriginalImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData> 
}

export type CreationsOriginalImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsOriginalImage>>>
export type CreationsOriginalImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsOriginalImage<TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsOriginalImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUpscaledImage = (
    params: MaybeRef<CreationsUpscaledImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/upscaledImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUpscaledImageQueryKey = (params: MaybeRef<CreationsUpscaledImageParams>,) => {
    return ['creations','upscaledImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUpscaledImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUpscaledImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUpscaledImage>>> = ({ signal }) => creationsUpscaledImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData> 
}

export type CreationsUpscaledImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUpscaledImage>>>
export type CreationsUpscaledImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUpscaledImage<TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUpscaledImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsPurchaseImage = (
    creationsPurchaseImageBody: MaybeRef<CreationsPurchaseImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsPurchaseImage200>> => {
    creationsPurchaseImageBody = unref(creationsPurchaseImageBody);
    
    return axios.post(
      `/creations/purchaseImage`,
      creationsPurchaseImageBody,options
    );
  }



export const getCreationsPurchaseImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseImage>>, TError,{data: CreationsPurchaseImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseImage>>, TError,{data: CreationsPurchaseImageBody}, TContext> => {

const mutationKey = ['creationsPurchaseImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsPurchaseImage>>, {data: CreationsPurchaseImageBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsPurchaseImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsPurchaseImageMutationResult = NonNullable<Awaited<ReturnType<typeof creationsPurchaseImage>>>
    export type CreationsPurchaseImageMutationBody = CreationsPurchaseImageBody
    export type CreationsPurchaseImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsPurchaseImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseImage>>, TError,{data: CreationsPurchaseImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsPurchaseImage>>,
        TError,
        {data: CreationsPurchaseImageBody},
        TContext
      > => {

      const mutationOptions = getCreationsPurchaseImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteImage = (
    creationsDeleteImageBody: MaybeRef<CreationsDeleteImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsDeleteImageBody = unref(creationsDeleteImageBody);
    
    return axios.post(
      `/creations/deleteImage`,
      creationsDeleteImageBody,options
    );
  }



export const getCreationsDeleteImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteImage>>, TError,{data: CreationsDeleteImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteImage>>, TError,{data: CreationsDeleteImageBody}, TContext> => {

const mutationKey = ['creationsDeleteImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteImage>>, {data: CreationsDeleteImageBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteImageMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteImage>>>
    export type CreationsDeleteImageMutationBody = CreationsDeleteImageBody
    export type CreationsDeleteImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteImage>>, TError,{data: CreationsDeleteImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteImage>>,
        TError,
        {data: CreationsDeleteImageBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteRequest = (
    creationsDeleteRequestBody: MaybeRef<CreationsDeleteRequestBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsDeleteRequestBody = unref(creationsDeleteRequestBody);
    
    return axios.post(
      `/creations/deleteRequest`,
      creationsDeleteRequestBody,options
    );
  }



export const getCreationsDeleteRequestMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext> => {

const mutationKey = ['creationsDeleteRequest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteRequest>>, {data: CreationsDeleteRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteRequest(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteRequestMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteRequest>>>
    export type CreationsDeleteRequestMutationBody = CreationsDeleteRequestBody
    export type CreationsDeleteRequestMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteRequest = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteRequest>>,
        TError,
        {data: CreationsDeleteRequestBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsSetRequestPrivacy = (
    creationsSetRequestPrivacyBody: MaybeRef<CreationsSetRequestPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsSetRequestPrivacyBody = unref(creationsSetRequestPrivacyBody);
    
    return axios.post(
      `/creations/setRequestPrivacy`,
      creationsSetRequestPrivacyBody,options
    );
  }



export const getCreationsSetRequestPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext> => {

const mutationKey = ['creationsSetRequestPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, {data: CreationsSetRequestPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsSetRequestPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsSetRequestPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>>
    export type CreationsSetRequestPrivacyMutationBody = CreationsSetRequestPrivacyBody
    export type CreationsSetRequestPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsSetRequestPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsSetRequestPrivacy>>,
        TError,
        {data: CreationsSetRequestPrivacyBody},
        TContext
      > => {

      const mutationOptions = getCreationsSetRequestPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsPackagesAvailable = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPackagesAvailable200Item[]>> => {
    
    
    return axios.get(
      `/points/packagesAvailable`,options
    );
  }


export const getPointsPackagesAvailableQueryKey = () => {
    return ['points','packagesAvailable'] as const;
    }

    
export const getPointsPackagesAvailableQueryOptions = <TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPackagesAvailableQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPackagesAvailable>>> = ({ signal }) => pointsPackagesAvailable({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData> 
}

export type PointsPackagesAvailableQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPackagesAvailable>>>
export type PointsPackagesAvailableQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPackagesAvailable<TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPackagesAvailableQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPrices200>> => {
    
    
    return axios.get(
      `/points/prices`,options
    );
  }


export const getPointsPricesQueryKey = () => {
    return ['points','prices'] as const;
    }

    
export const getPointsPricesQueryOptions = <TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPricesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPrices>>> = ({ signal }) => pointsPrices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData> 
}

export type PointsPricesQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPrices>>>
export type PointsPricesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPrices<TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPricesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsInitBuyPackage = (
    pointsInitBuyPackageBody: MaybeRef<PointsInitBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsInitBuyPackage200>> => {
    pointsInitBuyPackageBody = unref(pointsInitBuyPackageBody);
    
    return axios.post(
      `/points/initBuyPackage`,
      pointsInitBuyPackageBody,options
    );
  }



export const getPointsInitBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext> => {

const mutationKey = ['pointsInitBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsInitBuyPackage>>, {data: PointsInitBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsInitBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsInitBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsInitBuyPackage>>>
    export type PointsInitBuyPackageMutationBody = PointsInitBuyPackageBody
    export type PointsInitBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsInitBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsInitBuyPackage>>,
        TError,
        {data: PointsInitBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsInitBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsFinishBuyPackage = (
    pointsFinishBuyPackageBody: MaybeRef<PointsFinishBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsFinishBuyPackage200>> => {
    pointsFinishBuyPackageBody = unref(pointsFinishBuyPackageBody);
    
    return axios.post(
      `/points/finishBuyPackage`,
      pointsFinishBuyPackageBody,options
    );
  }



export const getPointsFinishBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext> => {

const mutationKey = ['pointsFinishBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, {data: PointsFinishBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsFinishBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsFinishBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsFinishBuyPackage>>>
    export type PointsFinishBuyPackageMutationBody = PointsFinishBuyPackageBody
    export type PointsFinishBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsFinishBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsFinishBuyPackage>>,
        TError,
        {data: PointsFinishBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsFinishBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsGetOrders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrders200>> => {
    
    
    return axios.get(
      `/points/getOrders`,options
    );
  }


export const getPointsGetOrdersQueryKey = () => {
    return ['points','getOrders'] as const;
    }

    
export const getPointsGetOrdersQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrders>>> = ({ signal }) => pointsGetOrders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData> 
}

export type PointsGetOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrders>>>
export type PointsGetOrdersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrders<TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsGetOrder = (
    params: MaybeRef<PointsGetOrderParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrder200>> => {
    params = unref(params);
    
    return axios.get(
      `/points/getOrder`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPointsGetOrderQueryKey = (params: MaybeRef<PointsGetOrderParams>,) => {
    return ['points','getOrder', ...(params ? [params]: [])] as const;
    }

    
export const getPointsGetOrderQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrder>>> = ({ signal }) => pointsGetOrder(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData> 
}

export type PointsGetOrderQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrder>>>
export type PointsGetOrderQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrder<TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrderQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGet = (
    params: MaybeRef<UserGetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGet200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/get`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetQueryKey = (params: MaybeRef<UserGetParams>,) => {
    return ['user','get', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetQueryOptions = <TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGet>>> = ({ signal }) => userGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData> 
}

export type UserGetQueryResult = NonNullable<Awaited<ReturnType<typeof userGet>>>
export type UserGetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGet<TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userProfile = (
    params: MaybeRef<UserProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/profile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserProfileQueryKey = (params: MaybeRef<UserProfileParams>,) => {
    return ['user','profile', ...(params ? [params]: [])] as const;
    }

    
export const getUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userProfile>>> = ({ signal }) => userProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData> 
}

export type UserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userProfile>>>
export type UserProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserProfile<TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userPublicProfile = (
    params: MaybeRef<UserPublicProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPublicProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/publicProfile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPublicProfileQueryKey = (params: MaybeRef<UserPublicProfileParams>,) => {
    return ['user','publicProfile', ...(params ? [params]: [])] as const;
    }

    
export const getUserPublicProfileQueryOptions = <TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPublicProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPublicProfile>>> = ({ signal }) => userPublicProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData> 
}

export type UserPublicProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userPublicProfile>>>
export type UserPublicProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPublicProfile<TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPublicProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetUsername = (
    params: MaybeRef<UserGetUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/getUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetUsernameQueryKey = (params: MaybeRef<UserGetUsernameParams>,) => {
    return ['user','getUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsername>>> = ({ signal }) => userGetUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData> 
}

export type UserGetUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userGetUsername>>>
export type UserGetUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetUsername<TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetUsername = (
    userSetUsernameBody: MaybeRef<UserSetUsernameBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetUsername200>> => {
    userSetUsernameBody = unref(userSetUsernameBody);
    
    return axios.post(
      `/user/setUsername`,
      userSetUsernameBody,options
    );
  }



export const getUserSetUsernameMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext> => {

const mutationKey = ['userSetUsername'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetUsername>>, {data: UserSetUsernameBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetUsername(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetUsernameMutationResult = NonNullable<Awaited<ReturnType<typeof userSetUsername>>>
    export type UserSetUsernameMutationBody = UserSetUsernameBody
    export type UserSetUsernameMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetUsername = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetUsername>>,
        TError,
        {data: UserSetUsernameBody},
        TContext
      > => {

      const mutationOptions = getUserSetUsernameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetBio = (
    userSetBioBody: MaybeRef<UserSetBioBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetBio200>> => {
    userSetBioBody = unref(userSetBioBody);
    
    return axios.post(
      `/user/setBio`,
      userSetBioBody,options
    );
  }



export const getUserSetBioMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext> => {

const mutationKey = ['userSetBio'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetBio>>, {data: UserSetBioBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetBio(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetBioMutationResult = NonNullable<Awaited<ReturnType<typeof userSetBio>>>
    export type UserSetBioMutationBody = UserSetBioBody
    export type UserSetBioMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetBio = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetBio>>,
        TError,
        {data: UserSetBioBody},
        TContext
      > => {

      const mutationOptions = getUserSetBioMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSendVerificationEmail = (
    userSendVerificationEmailBody: MaybeRef<UserSendVerificationEmailBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSendVerificationEmailBody = unref(userSendVerificationEmailBody);
    
    return axios.post(
      `/user/sendVerificationEmail`,
      userSendVerificationEmailBody,options
    );
  }



export const getUserSendVerificationEmailMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext> => {

const mutationKey = ['userSendVerificationEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSendVerificationEmail>>, {data: UserSendVerificationEmailBody}> = (props) => {
          const {data} = props ?? {};

          return  userSendVerificationEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSendVerificationEmailMutationResult = NonNullable<Awaited<ReturnType<typeof userSendVerificationEmail>>>
    export type UserSendVerificationEmailMutationBody = UserSendVerificationEmailBody
    export type UserSendVerificationEmailMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSendVerificationEmail = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSendVerificationEmail>>,
        TError,
        {data: UserSendVerificationEmailBody},
        TContext
      > => {

      const mutationOptions = getUserSendVerificationEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userPointsHistory = (
    params?: MaybeRef<UserPointsHistoryParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPointsHistory200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/user/pointsHistory`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPointsHistoryQueryKey = (params?: MaybeRef<UserPointsHistoryParams>,) => {
    return ['user','pointsHistory', ...(params ? [params]: [])] as const;
    }

    
export const getUserPointsHistoryQueryOptions = <TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPointsHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPointsHistory>>> = ({ signal }) => userPointsHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData> 
}

export type UserPointsHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof userPointsHistory>>>
export type UserPointsHistoryQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPointsHistory<TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPointsHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByUsername = (
    params: MaybeRef<UserFindByUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByUsernameQueryKey = (params: MaybeRef<UserFindByUsernameParams>,) => {
    return ['user','findByUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByUsername>>> = ({ signal }) => userFindByUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData> 
}

export type UserFindByUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByUsername>>>
export type UserFindByUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByUsername<TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByEmail = (
    params: MaybeRef<UserFindByEmailParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByEmail`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByEmailQueryKey = (params: MaybeRef<UserFindByEmailParams>,) => {
    return ['user','findByEmail', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByEmailQueryOptions = <TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByEmail>>> = ({ signal }) => userFindByEmail(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData> 
}

export type UserFindByEmailQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByEmail>>>
export type UserFindByEmailQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByEmail<TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByEmailQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPhone = (
    params: MaybeRef<UserFindByPhoneParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPhone`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPhoneQueryKey = (params: MaybeRef<UserFindByPhoneParams>,) => {
    return ['user','findByPhone', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPhoneQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPhoneQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPhone>>> = ({ signal }) => userFindByPhone(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData> 
}

export type UserFindByPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPhone>>>
export type UserFindByPhoneQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPhone<TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPhoneQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPrivyId = (
    params: MaybeRef<UserFindByPrivyIdParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPrivyId`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPrivyIdQueryKey = (params: MaybeRef<UserFindByPrivyIdParams>,) => {
    return ['user','findByPrivyId', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPrivyIdQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPrivyIdQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPrivyId>>> = ({ signal }) => userFindByPrivyId(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData> 
}

export type UserFindByPrivyIdQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPrivyId>>>
export type UserFindByPrivyIdQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPrivyId<TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPrivyIdQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetNotificationConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGetNotificationConfig200>> => {
    
    
    return axios.get(
      `/user/getNotificationConfig`,options
    );
  }


export const getUserGetNotificationConfigQueryKey = () => {
    return ['user','getNotificationConfig'] as const;
    }

    
export const getUserGetNotificationConfigQueryOptions = <TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetNotificationConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetNotificationConfig>>> = ({ signal }) => userGetNotificationConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData> 
}

export type UserGetNotificationConfigQueryResult = NonNullable<Awaited<ReturnType<typeof userGetNotificationConfig>>>
export type UserGetNotificationConfigQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetNotificationConfig<TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetNotificationConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetNotificationConfig = (
    userSetNotificationConfigBody: MaybeRef<UserSetNotificationConfigBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetNotificationConfig200>> => {
    userSetNotificationConfigBody = unref(userSetNotificationConfigBody);
    
    return axios.post(
      `/user/setNotificationConfig`,
      userSetNotificationConfigBody,options
    );
  }



export const getUserSetNotificationConfigMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext> => {

const mutationKey = ['userSetNotificationConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetNotificationConfig>>, {data: UserSetNotificationConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetNotificationConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetNotificationConfigMutationResult = NonNullable<Awaited<ReturnType<typeof userSetNotificationConfig>>>
    export type UserSetNotificationConfigMutationBody = UserSetNotificationConfigBody
    export type UserSetNotificationConfigMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetNotificationConfig = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetNotificationConfig>>,
        TError,
        {data: UserSetNotificationConfigBody},
        TContext
      > => {

      const mutationOptions = getUserSetNotificationConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userUnsubscribeEmailNotifications = (
    userUnsubscribeEmailNotificationsBody: MaybeRef<UserUnsubscribeEmailNotificationsBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    userUnsubscribeEmailNotificationsBody = unref(userUnsubscribeEmailNotificationsBody);
    
    return axios.post(
      `/user/unsubscribeEmailNotifications`,
      userUnsubscribeEmailNotificationsBody,options
    );
  }



export const getUserUnsubscribeEmailNotificationsMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext> => {

const mutationKey = ['userUnsubscribeEmailNotifications'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, {data: UserUnsubscribeEmailNotificationsBody}> = (props) => {
          const {data} = props ?? {};

          return  userUnsubscribeEmailNotifications(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserUnsubscribeEmailNotificationsMutationResult = NonNullable<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>>
    export type UserUnsubscribeEmailNotificationsMutationBody = UserUnsubscribeEmailNotificationsBody
    export type UserUnsubscribeEmailNotificationsMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserUnsubscribeEmailNotifications = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>,
        TError,
        {data: UserUnsubscribeEmailNotificationsBody},
        TContext
      > => {

      const mutationOptions = getUserUnsubscribeEmailNotificationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetAvatar = (
    userSetAvatarBody: MaybeRef<UserSetAvatarBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSetAvatarBody = unref(userSetAvatarBody);
    
    return axios.post(
      `/user/setAvatar`,
      userSetAvatarBody,options
    );
  }



export const getUserSetAvatarMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext> => {

const mutationKey = ['userSetAvatar'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetAvatar>>, {data: UserSetAvatarBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetAvatar(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetAvatarMutationResult = NonNullable<Awaited<ReturnType<typeof userSetAvatar>>>
    export type UserSetAvatarMutationBody = UserSetAvatarBody
    export type UserSetAvatarMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetAvatar = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetAvatar>>,
        TError,
        {data: UserSetAvatarBody},
        TContext
      > => {

      const mutationOptions = getUserSetAvatarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userAllUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAllUsers200Item[]>> => {
    
    
    return axios.get(
      `/user/allUsers`,options
    );
  }


export const getUserAllUsersQueryKey = () => {
    return ['user','allUsers'] as const;
    }

    
export const getUserAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userAllUsers>>> = ({ signal }) => userAllUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData> 
}

export type UserAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof userAllUsers>>>
export type UserAllUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserAllUsers<TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserAllUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const loginLinkInitLoginLink = (
    loginLinkInitLoginLinkBody: MaybeRef<LoginLinkInitLoginLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    loginLinkInitLoginLinkBody = unref(loginLinkInitLoginLinkBody);
    
    return axios.post(
      `/loginLink/initLoginLink`,
      loginLinkInitLoginLinkBody,options
    );
  }



export const getLoginLinkInitLoginLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext> => {

const mutationKey = ['loginLinkInitLoginLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, {data: LoginLinkInitLoginLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkInitLoginLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkInitLoginLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkInitLoginLink>>>
    export type LoginLinkInitLoginLinkMutationBody = LoginLinkInitLoginLinkBody
    export type LoginLinkInitLoginLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkInitLoginLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkInitLoginLink>>,
        TError,
        {data: LoginLinkInitLoginLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkInitLoginLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const loginLinkLoginWithLink = (
    loginLinkLoginWithLinkBody: MaybeRef<LoginLinkLoginWithLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginLinkLoginWithLink200>> => {
    loginLinkLoginWithLinkBody = unref(loginLinkLoginWithLinkBody);
    
    return axios.post(
      `/loginLink/loginWithLink`,
      loginLinkLoginWithLinkBody,options
    );
  }



export const getLoginLinkLoginWithLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext> => {

const mutationKey = ['loginLinkLoginWithLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, {data: LoginLinkLoginWithLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkLoginWithLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkLoginWithLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkLoginWithLink>>>
    export type LoginLinkLoginWithLinkMutationBody = LoginLinkLoginWithLinkBody
    export type LoginLinkLoginWithLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkLoginWithLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkLoginWithLink>>,
        TError,
        {data: LoginLinkLoginWithLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkLoginWithLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const statsUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsUsers200>> => {
    
    
    return axios.get(
      `/stats/users`,options
    );
  }


export const getStatsUsersQueryKey = () => {
    return ['stats','users'] as const;
    }

    
export const getStatsUsersQueryOptions = <TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsUsers>>> = ({ signal }) => statsUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData> 
}

export type StatsUsersQueryResult = NonNullable<Awaited<ReturnType<typeof statsUsers>>>
export type StatsUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsUsers<TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsImages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsImages200>> => {
    
    
    return axios.get(
      `/stats/images`,options
    );
  }


export const getStatsImagesQueryKey = () => {
    return ['stats','images'] as const;
    }

    
export const getStatsImagesQueryOptions = <TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsImages>>> = ({ signal }) => statsImages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData> 
}

export type StatsImagesQueryResult = NonNullable<Awaited<ReturnType<typeof statsImages>>>
export type StatsImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsImages<TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsCollections = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsCollections200>> => {
    
    
    return axios.get(
      `/stats/collections`,options
    );
  }


export const getStatsCollectionsQueryKey = () => {
    return ['stats','collections'] as const;
    }

    
export const getStatsCollectionsQueryOptions = <TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsCollectionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsCollections>>> = ({ signal }) => statsCollections({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData> 
}

export type StatsCollectionsQueryResult = NonNullable<Awaited<ReturnType<typeof statsCollections>>>
export type StatsCollectionsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsCollections<TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsCollectionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsPayments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsPayments200>> => {
    
    
    return axios.get(
      `/stats/payments`,options
    );
  }


export const getStatsPaymentsQueryKey = () => {
    return ['stats','payments'] as const;
    }

    
export const getStatsPaymentsQueryOptions = <TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsPaymentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsPayments>>> = ({ signal }) => statsPayments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData> 
}

export type StatsPaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof statsPayments>>>
export type StatsPaymentsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsPayments<TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsPaymentsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsApiMetrics = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    
    
    return axios.get(
      `/stats/apiMetrics`,options
    );
  }


export const getStatsApiMetricsQueryKey = () => {
    return ['stats','apiMetrics'] as const;
    }

    
export const getStatsApiMetricsQueryOptions = <TData = Awaited<ReturnType<typeof statsApiMetrics>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsApiMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsApiMetricsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsApiMetrics>>> = ({ signal }) => statsApiMetrics({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsApiMetrics>>, TError, TData> 
}

export type StatsApiMetricsQueryResult = NonNullable<Awaited<ReturnType<typeof statsApiMetrics>>>
export type StatsApiMetricsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsApiMetrics<TData = Awaited<ReturnType<typeof statsApiMetrics>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsApiMetrics>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsApiMetricsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsImageInUsersCollection = (
    params: MaybeRef<CollectionsImageInUsersCollectionParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/imageInUsersCollection`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsImageInUsersCollectionQueryKey = (params: MaybeRef<CollectionsImageInUsersCollectionParams>,) => {
    return ['collections','imageInUsersCollection', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsImageInUsersCollectionQueryOptions = <TData = Awaited<ReturnType<typeof collectionsImageInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsImageInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsImageInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsImageInUsersCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsImageInUsersCollection>>> = ({ signal }) => collectionsImageInUsersCollection(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsImageInUsersCollection>>, TError, TData> 
}

export type CollectionsImageInUsersCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsImageInUsersCollection>>>
export type CollectionsImageInUsersCollectionQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsImageInUsersCollection<TData = Awaited<ReturnType<typeof collectionsImageInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsImageInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsImageInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsImageInUsersCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsLikeImage = (
    collectionsLikeImageBody: MaybeRef<CollectionsLikeImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsLikeImageBody = unref(collectionsLikeImageBody);
    
    return axios.post(
      `/collections/likeImage`,
      collectionsLikeImageBody,options
    );
  }



export const getCollectionsLikeImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeImage>>, TError,{data: CollectionsLikeImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeImage>>, TError,{data: CollectionsLikeImageBody}, TContext> => {

const mutationKey = ['collectionsLikeImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsLikeImage>>, {data: CollectionsLikeImageBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsLikeImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsLikeImageMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsLikeImage>>>
    export type CollectionsLikeImageMutationBody = CollectionsLikeImageBody
    export type CollectionsLikeImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsLikeImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeImage>>, TError,{data: CollectionsLikeImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsLikeImage>>,
        TError,
        {data: CollectionsLikeImageBody},
        TContext
      > => {

      const mutationOptions = getCollectionsLikeImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsUnlikeImage = (
    collectionsUnlikeImageBody: MaybeRef<CollectionsUnlikeImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsUnlikeImageBody = unref(collectionsUnlikeImageBody);
    
    return axios.post(
      `/collections/unlikeImage`,
      collectionsUnlikeImageBody,options
    );
  }



export const getCollectionsUnlikeImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeImage>>, TError,{data: CollectionsUnlikeImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeImage>>, TError,{data: CollectionsUnlikeImageBody}, TContext> => {

const mutationKey = ['collectionsUnlikeImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsUnlikeImage>>, {data: CollectionsUnlikeImageBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsUnlikeImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsUnlikeImageMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsUnlikeImage>>>
    export type CollectionsUnlikeImageMutationBody = CollectionsUnlikeImageBody
    export type CollectionsUnlikeImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsUnlikeImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeImage>>, TError,{data: CollectionsUnlikeImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsUnlikeImage>>,
        TError,
        {data: CollectionsUnlikeImageBody},
        TContext
      > => {

      const mutationOptions = getCollectionsUnlikeImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsGetCollectionMeta = (
    params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionMeta200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionMeta`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionMetaQueryKey = (params: MaybeRef<CollectionsGetCollectionMetaParams>,) => {
    return ['collections','getCollectionMeta', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionMetaQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionMetaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>> = ({ signal }) => collectionsGetCollectionMeta(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData> 
}

export type CollectionsGetCollectionMetaQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>>
export type CollectionsGetCollectionMetaQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionMeta<TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionMetaQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsFindCollectionByName = (
    params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsFindCollectionByName200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/findCollectionByName`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsFindCollectionByNameQueryKey = (params: MaybeRef<CollectionsFindCollectionByNameParams>,) => {
    return ['collections','findCollectionByName', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsFindCollectionByNameQueryOptions = <TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsFindCollectionByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsFindCollectionByName>>> = ({ signal }) => collectionsFindCollectionByName(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData> 
}

export type CollectionsFindCollectionByNameQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsFindCollectionByName>>>
export type CollectionsFindCollectionByNameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsFindCollectionByName<TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsFindCollectionByNameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionImages = (
    params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionImages200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionImages`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionImagesQueryKey = (params: MaybeRef<CollectionsGetCollectionImagesParams>,) => {
    return ['collections','getCollectionImages', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionImagesQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionImagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionImages>>> = ({ signal }) => collectionsGetCollectionImages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData> 
}

export type CollectionsGetCollectionImagesQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionImages>>>
export type CollectionsGetCollectionImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionImages<TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionImagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoCreatePromoCode = (
    promoCreatePromoCodeBody: MaybeRef<PromoCreatePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoCreatePromoCode200>> => {
    promoCreatePromoCodeBody = unref(promoCreatePromoCodeBody);
    
    return axios.post(
      `/promo/createPromoCode`,
      promoCreatePromoCodeBody,options
    );
  }



export const getPromoCreatePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext> => {

const mutationKey = ['promoCreatePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoCreatePromoCode>>, {data: PromoCreatePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoCreatePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoCreatePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoCreatePromoCode>>>
    export type PromoCreatePromoCodeMutationBody = PromoCreatePromoCodeBody
    export type PromoCreatePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoCreatePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoCreatePromoCode>>,
        TError,
        {data: PromoCreatePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoCreatePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoDeletePromoCode = (
    promoDeletePromoCodeBody: MaybeRef<PromoDeletePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoDeletePromoCodeBody = unref(promoDeletePromoCodeBody);
    
    return axios.post(
      `/promo/deletePromoCode`,
      promoDeletePromoCodeBody,options
    );
  }



export const getPromoDeletePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext> => {

const mutationKey = ['promoDeletePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoDeletePromoCode>>, {data: PromoDeletePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoDeletePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoDeletePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoDeletePromoCode>>>
    export type PromoDeletePromoCodeMutationBody = PromoDeletePromoCodeBody
    export type PromoDeletePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoDeletePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoDeletePromoCode>>,
        TError,
        {data: PromoDeletePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoDeletePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoGetPromoCodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodes200Item[]>> => {
    
    
    return axios.get(
      `/promo/getPromoCodes`,options
    );
  }


export const getPromoGetPromoCodesQueryKey = () => {
    return ['promo','getPromoCodes'] as const;
    }

    
export const getPromoGetPromoCodesQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodes>>> = ({ signal }) => promoGetPromoCodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData> 
}

export type PromoGetPromoCodesQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodes>>>
export type PromoGetPromoCodesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodes<TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoGetPromoCodeDetails = (
    params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodeDetails200>> => {
    params = unref(params);
    
    return axios.get(
      `/promo/getPromoCodeDetails`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPromoGetPromoCodeDetailsQueryKey = (params: MaybeRef<PromoGetPromoCodeDetailsParams>,) => {
    return ['promo','getPromoCodeDetails', ...(params ? [params]: [])] as const;
    }

    
export const getPromoGetPromoCodeDetailsQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodeDetailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>> = ({ signal }) => promoGetPromoCodeDetails(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData> 
}

export type PromoGetPromoCodeDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>>
export type PromoGetPromoCodeDetailsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodeDetails<TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodeDetailsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoClaimPromoCode = (
    promoClaimPromoCodeBody: MaybeRef<PromoClaimPromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoClaimPromoCodeBody = unref(promoClaimPromoCodeBody);
    
    return axios.post(
      `/promo/claimPromoCode`,
      promoClaimPromoCodeBody,options
    );
  }



export const getPromoClaimPromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext> => {

const mutationKey = ['promoClaimPromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoClaimPromoCode>>, {data: PromoClaimPromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoClaimPromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoClaimPromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoClaimPromoCode>>>
    export type PromoClaimPromoCodeMutationBody = PromoClaimPromoCodeBody
    export type PromoClaimPromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoClaimPromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoClaimPromoCode>>,
        TError,
        {data: PromoClaimPromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoClaimPromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsSetModelName = (
    modelsSetModelNameBody: MaybeRef<ModelsSetModelNameBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsSetModelNameBody = unref(modelsSetModelNameBody);
    
    return axios.post(
      `/models/setModelName`,
      modelsSetModelNameBody,options
    );
  }



export const getModelsSetModelNameMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelName>>, TError,{data: ModelsSetModelNameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelName>>, TError,{data: ModelsSetModelNameBody}, TContext> => {

const mutationKey = ['modelsSetModelName'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsSetModelName>>, {data: ModelsSetModelNameBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsSetModelName(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsSetModelNameMutationResult = NonNullable<Awaited<ReturnType<typeof modelsSetModelName>>>
    export type ModelsSetModelNameMutationBody = ModelsSetModelNameBody
    export type ModelsSetModelNameMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsSetModelName = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelName>>, TError,{data: ModelsSetModelNameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsSetModelName>>,
        TError,
        {data: ModelsSetModelNameBody},
        TContext
      > => {

      const mutationOptions = getModelsSetModelNameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetUserModels = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetUserModels200Item[]>> => {
    
    
    return axios.get(
      `/models/getUserModels`,options
    );
  }


export const getModelsGetUserModelsQueryKey = () => {
    return ['models','getUserModels'] as const;
    }

    
export const getModelsGetUserModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetUserModelsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetUserModels>>> = ({ signal }) => modelsGetUserModels({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData> 
}

export type ModelsGetUserModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetUserModels>>>
export type ModelsGetUserModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetUserModels<TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetUserModelsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsCreateModel = (
    modelsCreateModelBody: MaybeRef<ModelsCreateModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    modelsCreateModelBody = unref(modelsCreateModelBody);
    
    return axios.post(
      `/models/createModel`,
      modelsCreateModelBody,options
    );
  }



export const getModelsCreateModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext> => {

const mutationKey = ['modelsCreateModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsCreateModel>>, {data: ModelsCreateModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsCreateModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsCreateModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsCreateModel>>>
    export type ModelsCreateModelMutationBody = ModelsCreateModelBody
    export type ModelsCreateModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsCreateModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsCreateModel>>,
        TError,
        {data: ModelsCreateModelBody},
        TContext
      > => {

      const mutationOptions = getModelsCreateModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetTrainingStatus = (
    params: MaybeRef<ModelsGetTrainingStatusParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetTrainingStatus200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getTrainingStatus`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetTrainingStatusQueryKey = (params: MaybeRef<ModelsGetTrainingStatusParams>,) => {
    return ['models','getTrainingStatus', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetTrainingStatusQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetTrainingStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetTrainingStatus>>> = ({ signal }) => modelsGetTrainingStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData> 
}

export type ModelsGetTrainingStatusQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetTrainingStatus>>>
export type ModelsGetTrainingStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetTrainingStatus<TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetTrainingStatusQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsDeleteModel = (
    modelsDeleteModelBody: MaybeRef<ModelsDeleteModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsDeleteModelBody = unref(modelsDeleteModelBody);
    
    return axios.post(
      `/models/deleteModel`,
      modelsDeleteModelBody,options
    );
  }



export const getModelsDeleteModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext> => {

const mutationKey = ['modelsDeleteModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsDeleteModel>>, {data: ModelsDeleteModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsDeleteModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsDeleteModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsDeleteModel>>>
    export type ModelsDeleteModelMutationBody = ModelsDeleteModelBody
    export type ModelsDeleteModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsDeleteModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsDeleteModel>>,
        TError,
        {data: ModelsDeleteModelBody},
        TContext
      > => {

      const mutationOptions = getModelsDeleteModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetModel = (
    params: MaybeRef<ModelsGetModelParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetModel200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getModel`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetModelQueryKey = (params: MaybeRef<ModelsGetModelParams>,) => {
    return ['models','getModel', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetModel>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetModelQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetModel>>> = ({ signal }) => modelsGetModel(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetModel>>, TError, TData> 
}

export type ModelsGetModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetModel>>>
export type ModelsGetModelQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetModel<TData = Awaited<ReturnType<typeof modelsGetModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetModel>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetModelQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsSetModelPrivacy = (
    modelsSetModelPrivacyBody: MaybeRef<ModelsSetModelPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsSetModelPrivacyBody = unref(modelsSetModelPrivacyBody);
    
    return axios.post(
      `/models/setModelPrivacy`,
      modelsSetModelPrivacyBody,options
    );
  }



export const getModelsSetModelPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext> => {

const mutationKey = ['modelsSetModelPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, {data: ModelsSetModelPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsSetModelPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsSetModelPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof modelsSetModelPrivacy>>>
    export type ModelsSetModelPrivacyMutationBody = ModelsSetModelPrivacyBody
    export type ModelsSetModelPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsSetModelPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsSetModelPrivacy>>,
        TError,
        {data: ModelsSetModelPrivacyBody},
        TContext
      > => {

      const mutationOptions = getModelsSetModelPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminLoginAsUser = (
    adminLoginAsUserBody: MaybeRef<AdminLoginAsUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    adminLoginAsUserBody = unref(adminLoginAsUserBody);
    
    return axios.post(
      `/admin/loginAsUser`,
      adminLoginAsUserBody,options
    );
  }



export const getAdminLoginAsUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext> => {

const mutationKey = ['adminLoginAsUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLoginAsUser>>, {data: AdminLoginAsUserBody}> = (props) => {
          const {data} = props ?? {};

          return  adminLoginAsUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminLoginAsUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminLoginAsUser>>>
    export type AdminLoginAsUserMutationBody = AdminLoginAsUserBody
    export type AdminLoginAsUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminLoginAsUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminLoginAsUser>>,
        TError,
        {data: AdminLoginAsUserBody},
        TContext
      > => {

      const mutationOptions = getAdminLoginAsUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const privyAuthenticate = (
    privyAuthenticateBody: MaybeRef<PrivyAuthenticateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrivyAuthenticate200>> => {
    privyAuthenticateBody = unref(privyAuthenticateBody);
    
    return axios.post(
      `/privy/authenticate`,
      privyAuthenticateBody,options
    );
  }



export const getPrivyAuthenticateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext> => {

const mutationKey = ['privyAuthenticate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof privyAuthenticate>>, {data: PrivyAuthenticateBody}> = (props) => {
          const {data} = props ?? {};

          return  privyAuthenticate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrivyAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof privyAuthenticate>>>
    export type PrivyAuthenticateMutationBody = PrivyAuthenticateBody
    export type PrivyAuthenticateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePrivyAuthenticate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof privyAuthenticate>>,
        TError,
        {data: PrivyAuthenticateBody},
        TContext
      > => {

      const mutationOptions = getPrivyAuthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsCreateSet = (
    trainingSetsCreateSetBody: MaybeRef<TrainingSetsCreateSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsCreateSet200>> => {
    trainingSetsCreateSetBody = unref(trainingSetsCreateSetBody);
    
    return axios.post(
      `/trainingSets/createSet`,
      trainingSetsCreateSetBody,options
    );
  }



export const getTrainingSetsCreateSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext> => {

const mutationKey = ['trainingSetsCreateSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsCreateSet>>, {data: TrainingSetsCreateSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsCreateSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsCreateSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsCreateSet>>>
    export type TrainingSetsCreateSetMutationBody = TrainingSetsCreateSetBody
    export type TrainingSetsCreateSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsCreateSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsCreateSet>>,
        TError,
        {data: TrainingSetsCreateSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsCreateSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsFinalizeSet = (
    trainingSetsFinalizeSetBody: MaybeRef<TrainingSetsFinalizeSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsFinalizeSetBody = unref(trainingSetsFinalizeSetBody);
    
    return axios.post(
      `/trainingSets/finalizeSet`,
      trainingSetsFinalizeSetBody,options
    );
  }



export const getTrainingSetsFinalizeSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext> => {

const mutationKey = ['trainingSetsFinalizeSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, {data: TrainingSetsFinalizeSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsFinalizeSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsFinalizeSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>>
    export type TrainingSetsFinalizeSetMutationBody = TrainingSetsFinalizeSetBody
    export type TrainingSetsFinalizeSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsFinalizeSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsFinalizeSet>>,
        TError,
        {data: TrainingSetsFinalizeSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsFinalizeSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsGetUserSets = (
    params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetUserSets200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getUserSets`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetUserSetsQueryKey = (params: MaybeRef<TrainingSetsGetUserSetsParams>,) => {
    return ['trainingSets','getUserSets', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetUserSetsQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetUserSetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetUserSets>>> = ({ signal }) => trainingSetsGetUserSets(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData> 
}

export type TrainingSetsGetUserSetsQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetUserSets>>>
export type TrainingSetsGetUserSetsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetUserSets<TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetUserSetsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsGetSet = (
    params: MaybeRef<TrainingSetsGetSetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetSet200>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getSet`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetSetQueryKey = (params: MaybeRef<TrainingSetsGetSetParams>,) => {
    return ['trainingSets','getSet', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetSetQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetSetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetSet>>> = ({ signal }) => trainingSetsGetSet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData> 
}

export type TrainingSetsGetSetQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetSet>>>
export type TrainingSetsGetSetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetSet<TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetSetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsDeleteSet = (
    trainingSetsDeleteSetBody: MaybeRef<TrainingSetsDeleteSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsDeleteSetBody = unref(trainingSetsDeleteSetBody);
    
    return axios.post(
      `/trainingSets/deleteSet`,
      trainingSetsDeleteSetBody,options
    );
  }



export const getTrainingSetsDeleteSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext> => {

const mutationKey = ['trainingSetsDeleteSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, {data: TrainingSetsDeleteSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsDeleteSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsDeleteSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsDeleteSet>>>
    export type TrainingSetsDeleteSetMutationBody = TrainingSetsDeleteSetBody
    export type TrainingSetsDeleteSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsDeleteSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsDeleteSet>>,
        TError,
        {data: TrainingSetsDeleteSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsDeleteSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsEditSet = (
    trainingSetsEditSetBody: MaybeRef<TrainingSetsEditSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsEditSetBody = unref(trainingSetsEditSetBody);
    
    return axios.post(
      `/trainingSets/editSet`,
      trainingSetsEditSetBody,options
    );
  }



export const getTrainingSetsEditSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext> => {

const mutationKey = ['trainingSetsEditSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsEditSet>>, {data: TrainingSetsEditSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsEditSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsEditSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsEditSet>>>
    export type TrainingSetsEditSetMutationBody = TrainingSetsEditSetBody
    export type TrainingSetsEditSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsEditSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsEditSet>>,
        TError,
        {data: TrainingSetsEditSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsEditSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
