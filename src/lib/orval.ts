/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Fiddl.art API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

export type ErrorBADREQUESTIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorBADREQUEST {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorBADREQUESTIssuesItem[];
}

export type ErrorUNAUTHORIZEDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorUNAUTHORIZED {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorUNAUTHORIZEDIssuesItem[];
}

export type ErrorFORBIDDENIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorFORBIDDEN {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorFORBIDDENIssuesItem[];
}

export type ErrorINTERNALSERVERERRORIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorINTERNALSERVERERROR {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorINTERNALSERVERERRORIssuesItem[];
}

export type ErrorNOTFOUNDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorNOTFOUND {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorNOTFOUNDIssuesItem[];
}

export type PkAuthRegisterStartBodyTracking = {
  utm_source?: string;
  utm_medium?: string;
  utm_campaign?: string;
  utm_term?: string;
  utm_content?: string;
  referrerUrl?: string;
  landingUrl?: string;
  gclid?: string;
  fbclid?: string;
  ttclid?: string;
  fbp?: string;
  fbc?: string;
  source?: string;
};

export type PkAuthRegisterStartBody = {
  email?: string;
  phone?: string;
  referredByUserName?: string;
  tracking?: PkAuthRegisterStartBodyTracking;
};

export type PkAuthRegisterFinishBody = {
  userId: string;
  data?: unknown;
};

export type PkAuthLoginStartBody = {
  userId: string;
};

export type PkAuthLoginFinishBody = {
  userId: string;
  data?: unknown;
};

export type CreateImageBodyModel = typeof CreateImageBodyModel[keyof typeof CreateImageBodyModel];


 
export const CreateImageBodyModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const;

export type CreateImageBodyAspectRatio = typeof CreateImageBodyAspectRatio[keyof typeof CreateImageBodyAspectRatio];


 
export const CreateImageBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateImageBody = {
  prompt: string;
  negativePrompt?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  quantity: number;
  seed?: number;
  model: CreateImageBodyModel;
  public?: boolean;
  aspectRatio?: CreateImageBodyAspectRatio;
  customModelId?: string;
  uploadedStartImageIds?: string[];
  startImageIds?: string[];
};

export type CreateImage200 = {
  ids: string[];
  id: string;
  errors: string[];
};

export type CreateVideoBodyModel = typeof CreateVideoBodyModel[keyof typeof CreateVideoBodyModel];


 
export const CreateVideoBodyModel = {
  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
} as const;

export type CreateVideoBodyAspectRatio = typeof CreateVideoBodyAspectRatio[keyof typeof CreateVideoBodyAspectRatio];


 
export const CreateVideoBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateVideoBody = {
  prompt: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  quantity: number;
  seed?: number;
  model: CreateVideoBodyModel;
  public: boolean;
  aspectRatio: CreateVideoBodyAspectRatio;
  duration: number;
  startImageId?: string;
  uploadedStartImageId?: string;
};

export type CreateVideo200VideosItemStatus = typeof CreateVideo200VideosItemStatus[keyof typeof CreateVideo200VideosItemStatus];


 
export const CreateVideo200VideosItemStatus = {
  processing: 'processing',
  previewRendering: 'previewRendering',
  ready: 'ready',
  errored: 'errored',
} as const;

export type CreateVideo200VideosItem = {
  status: CreateVideo200VideosItemStatus;
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  seed: string | null;
  errored: boolean;
  deleted: boolean;
  /** @nullable */
  deletedAt: string | null;
  nsfw: boolean;
  videoRequestId: string;
  /** @nullable */
  replicatePredictionId: string | null;
  /** @nullable */
  coconutJobId: string | null;
  /** @nullable */
  errorMessage: string | null;
};

export type CreateVideo200 = {
  id: string;
  userId: string;
  prompt: string;
  model: string;
  aspectRatio: string;
  duration: number;
  /** @nullable */
  seed: string | null;
  /** @nullable */
  negativePrompt: string | null;
  quantity: number;
  createdAt: string;
  updatedAt: string;
  public: boolean;
  deleted: boolean;
  /** @nullable */
  error: string | null;
  /** @nullable */
  startImageId: string | null;
  /** @nullable */
  uploadedStartImageId: string | null;
  videos: CreateVideo200VideosItem[];
};

export type CreateRandomPromptBodyType = typeof CreateRandomPromptBodyType[keyof typeof CreateRandomPromptBodyType];


 
export const CreateRandomPromptBodyType = {
  image: 'image',
  video: 'video',
} as const;

export type CreateRandomPromptBody = {
  theme?: string;
  type?: CreateRandomPromptBodyType;
};

export type CreateImprovePromptBodyType = typeof CreateImprovePromptBodyType[keyof typeof CreateImprovePromptBodyType];


 
export const CreateImprovePromptBodyType = {
  image: 'image',
  video: 'video',
} as const;

export type CreateImprovePromptBody = {
  prompt: string;
  type?: CreateImprovePromptBodyType;
};

export type CreateUploadImageBodyFileType = typeof CreateUploadImageBodyFileType[keyof typeof CreateUploadImageBodyFileType];


 
export const CreateUploadImageBodyFileType = {
  'image/jpeg': 'image/jpeg',
  'image/png': 'image/png',
  'image/webp': 'image/webp',
  'image/gif': 'image/gif',
} as const;

export type CreateUploadImageBody = {
  fileType: CreateUploadImageBodyFileType;
};

export type CreateUploadImage200UploadUrlFields = {[key: string]: string};

export type CreateUploadImage200UploadUrl = {
  url: string;
  fields: CreateUploadImage200UploadUrlFields;
};

export type CreateUploadImage200 = {
  uploadUrl: CreateUploadImage200UploadUrl;
  imageId: string;
};

export type CreateQueueAsyncBatchBodyRequestsItemAnyOfModel = typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfModel[keyof typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfModel];


 
export const CreateQueueAsyncBatchBodyRequestsItemAnyOfModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const;

export type CreateQueueAsyncBatchBodyRequestsItemAnyOfAspectRatio = typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfAspectRatio[keyof typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfAspectRatio];


 
export const CreateQueueAsyncBatchBodyRequestsItemAnyOfAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateQueueAsyncBatchBodyRequestsItemAnyOf = {
  prompt: string;
  negativePrompt?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  quantity: number;
  seed?: number;
  model: CreateQueueAsyncBatchBodyRequestsItemAnyOfModel;
  public?: boolean;
  aspectRatio?: CreateQueueAsyncBatchBodyRequestsItemAnyOfAspectRatio;
  customModelId?: string;
  uploadedStartImageIds?: string[];
  startImageIds?: string[];
};

export type CreateQueueAsyncBatchBodyRequestsItemAnyOfFourModel = typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfFourModel[keyof typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfFourModel];


 
export const CreateQueueAsyncBatchBodyRequestsItemAnyOfFourModel = {
  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
} as const;

export type CreateQueueAsyncBatchBodyRequestsItemAnyOfFourAspectRatio = typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfFourAspectRatio[keyof typeof CreateQueueAsyncBatchBodyRequestsItemAnyOfFourAspectRatio];


 
export const CreateQueueAsyncBatchBodyRequestsItemAnyOfFourAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateQueueAsyncBatchBodyRequestsItemAnyOfFour = {
  prompt: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  quantity: number;
  seed?: number;
  model: CreateQueueAsyncBatchBodyRequestsItemAnyOfFourModel;
  public: boolean;
  aspectRatio: CreateQueueAsyncBatchBodyRequestsItemAnyOfFourAspectRatio;
  duration: number;
  startImageId?: string;
  uploadedStartImageId?: string;
};

export type CreateQueueAsyncBatchBodyRequestsItem = CreateQueueAsyncBatchBodyRequestsItemAnyOf | CreateQueueAsyncBatchBodyRequestsItemAnyOfFour;

export type CreateQueueAsyncBatchBody = {
  /** @minItems 1 */
  requests: CreateQueueAsyncBatchBodyRequestsItem[];
  emailNotify?: boolean;
};

export type CreateQueueAsyncBatch200 = {
  batchId: string;
  accepted: number;
};

export type CreateBatchStatusParams = {
batchId: string;
};

export type CreateBatchStatus200Status = typeof CreateBatchStatus200Status[keyof typeof CreateBatchStatus200Status];


 
export const CreateBatchStatus200Status = {
  waiting: 'waiting',
  running: 'running',
  completed: 'completed',
  error: 'error',
} as const;

export type CreateBatchStatus200JobsItemType = typeof CreateBatchStatus200JobsItemType[keyof typeof CreateBatchStatus200JobsItemType];


 
export const CreateBatchStatus200JobsItemType = {
  image: 'image',
  video: 'video',
} as const;

export type CreateBatchStatus200JobsItemStatus = typeof CreateBatchStatus200JobsItemStatus[keyof typeof CreateBatchStatus200JobsItemStatus];


 
export const CreateBatchStatus200JobsItemStatus = {
  queued: 'queued',
  waitingForModel: 'waitingForModel',
  running: 'running',
  finished: 'finished',
  failed: 'failed',
} as const;

export type CreateBatchStatus200JobsItem = {
  id: string;
  type: CreateBatchStatus200JobsItemType;
  status: CreateBatchStatus200JobsItemStatus;
  errors: string[];
  imageIds?: string[];
  imageRequestId?: string;
  videoIds?: string[];
  videoRequestId?: string;
  waitingOnModelId?: string;
};

export type CreateBatchStatus200Counts = {
  total: number;
  queued: number;
  waitingForModel: number;
  running: number;
  finished: number;
  failed: number;
};

export type CreateBatchStatus200Progress = {
  completed: number;
  total: number;
  percent: number;
};

/**
 * @nullable
 */
export type CreateBatchStatus200 = {
  id: string;
  status: CreateBatchStatus200Status;
  emailNotify: boolean;
  createdAt: string;
  jobs: CreateBatchStatus200JobsItem[];
  counts: CreateBatchStatus200Counts;
  progress: CreateBatchStatus200Progress;
} | null;

export type CreationsGetCreationDataParams = {
imageId?: string;
videoId?: string;
};

/**
 * @nullable
 */
export type CreationsGetCreationData200Metadata = {
  id: string;
  createdAt: string;
  updatedAt: string;
  publishedAt: string;
  title: string;
  /** @nullable */
  description: string | null;
  publishedById: string;
  /** @nullable */
  imageId: string | null;
  /** @nullable */
  videoId: string | null;
} | null;

export type CreationsGetCreationData200 = {
  id: string;
  createdAt: string;
  nsfw: boolean;
  requestId: string;
  seed?: number;
  creatorId: string;
  numCollections: number;
  /** @nullable */
  metadata: CreationsGetCreationData200Metadata;
};

export type CreationsUserImagePurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserImagePurchasesOrder;
endDateTime?: string;
customModelId?: string;
model?: typeof CreationsUserImagePurchasesModel[keyof typeof CreationsUserImagePurchasesModel] ;
aspectRatio?: CreationsUserImagePurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserImagePurchasesOrder = typeof CreationsUserImagePurchasesOrder[keyof typeof CreationsUserImagePurchasesOrder];


 
export const CreationsUserImagePurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

 
export const CreationsUserImagePurchasesModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const
export type CreationsUserImagePurchasesAspectRatio = typeof CreationsUserImagePurchasesAspectRatio[keyof typeof CreationsUserImagePurchasesAspectRatio];


 
export const CreationsUserImagePurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsUserImagePurchases200Item = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

export type CreationsUserVideoPurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserVideoPurchasesOrder;
endDateTime?: string;
customModelId?: string;
model?: typeof CreationsUserVideoPurchasesModel[keyof typeof CreationsUserVideoPurchasesModel] ;
aspectRatio?: CreationsUserVideoPurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserVideoPurchasesOrder = typeof CreationsUserVideoPurchasesOrder[keyof typeof CreationsUserVideoPurchasesOrder];


 
export const CreationsUserVideoPurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

 
export const CreationsUserVideoPurchasesModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const
export type CreationsUserVideoPurchasesAspectRatio = typeof CreationsUserVideoPurchasesAspectRatio[keyof typeof CreationsUserVideoPurchasesAspectRatio];


 
export const CreationsUserVideoPurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsUserVideoPurchases200Item = {
  id: string;
  userId: string;
  videoId: string;
  createdAt: string;
};

export type CreationsCreateImageRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateImageRequestsOrder;
endDateTime?: string;
customModelId?: string;
model?: typeof CreationsCreateImageRequestsModel[keyof typeof CreationsCreateImageRequestsModel] ;
aspectRatio?: CreationsCreateImageRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateImageRequestsOrder = typeof CreationsCreateImageRequestsOrder[keyof typeof CreationsCreateImageRequestsOrder];


 
export const CreationsCreateImageRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

 
export const CreationsCreateImageRequestsModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const
export type CreationsCreateImageRequestsAspectRatio = typeof CreationsCreateImageRequestsAspectRatio[keyof typeof CreationsCreateImageRequestsAspectRatio];


 
export const CreationsCreateImageRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsCreateImageRequests200ItemImagesItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsCreateImageRequests200Item = {
  id: string;
  imageIds: string[];
  images: CreationsCreateImageRequests200ItemImagesItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
  meta?: string;
};

export type CreationsCreateVideoRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateVideoRequestsOrder;
endDateTime?: string;
customModelId?: string;
model?: typeof CreationsCreateVideoRequestsModel[keyof typeof CreationsCreateVideoRequestsModel] ;
aspectRatio?: CreationsCreateVideoRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateVideoRequestsOrder = typeof CreationsCreateVideoRequestsOrder[keyof typeof CreationsCreateVideoRequestsOrder];


 
export const CreationsCreateVideoRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

 
export const CreationsCreateVideoRequestsModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const
export type CreationsCreateVideoRequestsAspectRatio = typeof CreationsCreateVideoRequestsAspectRatio[keyof typeof CreationsCreateVideoRequestsAspectRatio];


 
export const CreationsCreateVideoRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsCreateVideoRequests200ItemVideosItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsCreateVideoRequests200Item = {
  id: string;
  videoIds: string[];
  videos: CreationsCreateVideoRequests200ItemVideosItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  meta?: string;
  duration?: number;
  quantity: number;
  startImageId?: string;
  uploadedStartImageId?: string;
};

export type CreationsGetMediaRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsGetMediaRequestsOrder;
endDateTime?: string;
customModelId?: string;
model?: typeof CreationsGetMediaRequestsModel[keyof typeof CreationsGetMediaRequestsModel] ;
aspectRatio?: CreationsGetMediaRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsGetMediaRequestsOrder = typeof CreationsGetMediaRequestsOrder[keyof typeof CreationsGetMediaRequestsOrder];


 
export const CreationsGetMediaRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

 
export const CreationsGetMediaRequestsModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  'sora-2': 'sora-2',
  'sora-2-pro': 'sora-2-pro',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const
export type CreationsGetMediaRequestsAspectRatio = typeof CreationsGetMediaRequestsAspectRatio[keyof typeof CreationsGetMediaRequestsAspectRatio];


 
export const CreationsGetMediaRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsGetMediaRequests200ItemAnyOfImagesItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsGetMediaRequests200ItemAnyOfMediaType = typeof CreationsGetMediaRequests200ItemAnyOfMediaType[keyof typeof CreationsGetMediaRequests200ItemAnyOfMediaType];


 
export const CreationsGetMediaRequests200ItemAnyOfMediaType = {
  image: 'image',
} as const;

export type CreationsGetMediaRequests200ItemAnyOf = {
  id: string;
  imageIds: string[];
  images: CreationsGetMediaRequests200ItemAnyOfImagesItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
  meta?: string;
  mediaType: CreationsGetMediaRequests200ItemAnyOfMediaType;
};

export type CreationsGetMediaRequests200ItemAnyOfFourVideosItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsGetMediaRequests200ItemAnyOfFourMediaType = typeof CreationsGetMediaRequests200ItemAnyOfFourMediaType[keyof typeof CreationsGetMediaRequests200ItemAnyOfFourMediaType];


 
export const CreationsGetMediaRequests200ItemAnyOfFourMediaType = {
  video: 'video',
} as const;

export type CreationsGetMediaRequests200ItemAnyOfFour = {
  id: string;
  videoIds: string[];
  videos: CreationsGetMediaRequests200ItemAnyOfFourVideosItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  meta?: string;
  duration?: number;
  quantity: number;
  startImageId?: string;
  uploadedStartImageId?: string;
  mediaType: CreationsGetMediaRequests200ItemAnyOfFourMediaType;
};

export type CreationsGetMediaRequests200Item = CreationsGetMediaRequests200ItemAnyOf | CreationsGetMediaRequests200ItemAnyOfFour;

export type CreationsGetImageRequestParams = {
imageRequestId: string;
};

export type CreationsGetImageRequest200ImagesItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsGetImageRequest200 = {
  id: string;
  imageIds: string[];
  images: CreationsGetImageRequest200ImagesItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
  meta?: string;
};

export type CreationsGetVideoRequestParams = {
videoRequestId: string;
};

export type CreationsGetVideoRequest200VideosItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsGetVideoRequest200 = {
  id: string;
  videoIds: string[];
  videos: CreationsGetVideoRequest200VideosItem[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  creatorUsername: string;
  model?: string;
  seed?: number;
  prompt?: string;
  meta?: string;
  duration?: number;
  quantity: number;
  startImageId?: string;
  uploadedStartImageId?: string;
};

export type CreationsBrowseCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsBrowseCreateRequestsOrder;
endDateTime?: string;
promptIncludes?: string;
model?: CreationsBrowseCreateRequestsModel;
aspectRatio?: CreationsBrowseCreateRequestsAspectRatio;
customModelId?: string;
randomSeed?: number;
sortMethod: CreationsBrowseCreateRequestsSortMethod;
mediaType?: CreationsBrowseCreateRequestsMediaType;
};

export type CreationsBrowseCreateRequestsOrder = typeof CreationsBrowseCreateRequestsOrder[keyof typeof CreationsBrowseCreateRequestsOrder];


 
export const CreationsBrowseCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsBrowseCreateRequestsModel = typeof CreationsBrowseCreateRequestsModel[keyof typeof CreationsBrowseCreateRequestsModel];


 
export const CreationsBrowseCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  'flux-kontext': 'flux-kontext',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
  seedream4: 'seedream4',
  seedream4k: 'seedream4k',
  'nano-banana': 'nano-banana',
} as const;

export type CreationsBrowseCreateRequestsAspectRatio = typeof CreationsBrowseCreateRequestsAspectRatio[keyof typeof CreationsBrowseCreateRequestsAspectRatio];


 
export const CreationsBrowseCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsBrowseCreateRequestsSortMethod = typeof CreationsBrowseCreateRequestsSortMethod[keyof typeof CreationsBrowseCreateRequestsSortMethod];


 
export const CreationsBrowseCreateRequestsSortMethod = {
  latest: 'latest',
  shuffle: 'shuffle',
  popular: 'popular',
} as const;

export type CreationsBrowseCreateRequestsMediaType = typeof CreationsBrowseCreateRequestsMediaType[keyof typeof CreationsBrowseCreateRequestsMediaType];


 
export const CreationsBrowseCreateRequestsMediaType = {
  image: 'image',
  video: 'video',
  all: 'all',
} as const;

export type CreationsBrowseCreateRequests200ItemMediaType = typeof CreationsBrowseCreateRequests200ItemMediaType[keyof typeof CreationsBrowseCreateRequests200ItemMediaType];


 
export const CreationsBrowseCreateRequests200ItemMediaType = {
  image: 'image',
  video: 'video',
} as const;

export type CreationsBrowseCreateRequests200ItemMediaItem = {
  id: string;
  nsfw: boolean;
};

export type CreationsBrowseCreateRequests200ItemUser = {
  id: string;
  username: string;
};

export type CreationsBrowseCreateRequests200Item = {
  mediaType: CreationsBrowseCreateRequests200ItemMediaType;
  id: string;
  createdAt: string;
  aspectRatio: string;
  media: CreationsBrowseCreateRequests200ItemMediaItem[];
  user: CreationsBrowseCreateRequests200ItemUser;
};

export type CreationsHdImageParams = {
imageId: string;
download?: boolean;
};

export type CreationsHdVideoParams = {
videoId: string;
download?: boolean;
};

export type CreationsImageSecretParams = {
imageId: string;
};

export type CreationsOriginalImageParams = {
imageId: string;
};

export type CreationsUpscaledImageParams = {
imageId: string;
};

export type CreationsPurchaseMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CreationsPublishMediaBody = {
  imageId?: string;
  videoId?: string;
  /**
   * @minLength 1
   * @maxLength 120
   */
  title: string;
  /** @maxLength 500 */
  description?: string;
};

export type CreationsPublishMedia200 = {
  id: string;
  createdAt: string;
  updatedAt: string;
  publishedAt: string;
  title: string;
  /** @nullable */
  description: string | null;
  publishedById: string;
  /** @nullable */
  imageId: string | null;
  /** @nullable */
  videoId: string | null;
};

export type CreationsDeleteMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CreationsDeleteRequestBody = {
  videoRequestId?: string;
  imageRequestId?: string;
};

export type CreationsSetRequestPrivacyBody = {
  videoRequestId?: string;
  imageRequestId?: string;
  public: boolean;
};

export type CreationsGetUserUploadedImagesParams = {
limit?: number;
offset?: number;
};

export type CreationsDeleteUploadedImageBody = {
  imageId: string;
};

export type CreationsDescribeUploadedImageParams = {
imageId: string;
};

/**
 * @nullable
 */
export type CreationsDescribeUploadedImage200SubjectGender = typeof CreationsDescribeUploadedImage200SubjectGender[keyof typeof CreationsDescribeUploadedImage200SubjectGender] | null;


 
export const CreationsDescribeUploadedImage200SubjectGender = {
  male: 'male',
  female: 'female',
  unknown: 'unknown',
} as const;

/**
 * @nullable
 */
export type CreationsDescribeUploadedImage200SubjectCategory = typeof CreationsDescribeUploadedImage200SubjectCategory[keyof typeof CreationsDescribeUploadedImage200SubjectCategory] | null;


 
export const CreationsDescribeUploadedImage200SubjectCategory = {
  human: 'human',
  animal: 'animal',
  object: 'object',
  architecture: 'architecture',
  setting: 'setting',
  style: 'style',
  dog: 'dog',
  cat: 'cat',
  other: 'other',
} as const;

export type CreationsDescribeUploadedImage200 = {
  /** @nullable */
  subjectGender: CreationsDescribeUploadedImage200SubjectGender;
  /** @nullable */
  subjectCategory: CreationsDescribeUploadedImage200SubjectCategory;
  id: string;
  createdAt: string;
  userId: string;
  /** @nullable */
  subjectDescription: string | null;
};

export type PointsPackagesAvailable200Item = {
  points: number;
  discountPct: number;
  usd: number;
};

export type PointsPrices200ImageModel = {
  ultra: number;
  'sd3-lg': number;
  core: number;
  'dall-e-3': number;
  'flux-pro-ultra': number;
  'flux-dev': number;
  'flux-pro': number;
  'flux-kontext': number;
  custom: number;
  imagen4: number;
  'imagen4-ultra': number;
  photon: number;
  recraft3: number;
  'recraft3-svg': number;
  'gpt-image-1': number;
  seedream3: number;
  seedream4: number;
  seedream4k: number;
  'nano-banana': number;
};

export type PointsPrices200Image = {
  unlock: number;
  unlockCommission: number;
  model: PointsPrices200ImageModel;
  uploadSoloImage: number;
};

export type PointsPrices200ForgeTrainBaseModel = {
  fluxDev: number;
  fluxPro: number;
  fluxProUltra: number;
  faceClone: number;
  faceForge: number;
};

export type PointsPrices200ForgeFineTuneType = {
  lora: number;
  full: number;
};

export type PointsPrices200Forge = {
  createTrainingSet: number;
  trainBaseModel: PointsPrices200ForgeTrainBaseModel;
  fineTuneType: PointsPrices200ForgeFineTuneType;
  customModelCharge: number;
  customModelOwnerComission: number;
};

export type PointsPrices200VideoModel = {
  'veo-2': number;
  'veo-3': number;
  'seedance-pro': number;
  'seedance-lite': number;
  kling: number;
  'sora-2': number;
  'sora-2-pro': number;
};

export type PointsPrices200Video = {
  unlock: number;
  unlockCommission: number;
  model: PointsPrices200VideoModel;
};

export type PointsPrices200SocialRewards = {
  linkEmail: number;
  linkTwitter: number;
  linkGoogle: number;
  linkPhone: number;
  linkTelegram: number;
};

export type PointsPrices200PromptTools = {
  improvePrompt: number;
  randomPrompt: number;
};

export type PointsPrices200 = {
  image: PointsPrices200Image;
  forge: PointsPrices200Forge;
  video: PointsPrices200Video;
  socialRewards: PointsPrices200SocialRewards;
  promptTools: PointsPrices200PromptTools;
  privateTax: number;
};

export type PointsInitBuyPackageBodyMethod = typeof PointsInitBuyPackageBodyMethod[keyof typeof PointsInitBuyPackageBodyMethod];


 
export const PointsInitBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackageBody = {
  packageId: number;
  method: PointsInitBuyPackageBodyMethod;
  discountCode?: string;
};

export type PointsInitBuyPackage200AnyOfLinksItem = {
  href: string;
  rel: string;
  method: string;
};

export type PointsInitBuyPackage200AnyOf = {
  id: string;
  status: string;
  links: PointsInitBuyPackage200AnyOfLinksItem[];
};

export type PointsInitBuyPackage200AnyOfThreeChainName = typeof PointsInitBuyPackage200AnyOfThreeChainName[keyof typeof PointsInitBuyPackage200AnyOfThreeChainName];


 
export const PointsInitBuyPackage200AnyOfThreeChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackage200AnyOfThreeTokenType = typeof PointsInitBuyPackage200AnyOfThreeTokenType[keyof typeof PointsInitBuyPackage200AnyOfThreeTokenType];


 
export const PointsInitBuyPackage200AnyOfThreeTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsInitBuyPackage200AnyOfThree = {
  chainName: PointsInitBuyPackage200AnyOfThreeChainName;
  tokenType: PointsInitBuyPackage200AnyOfThreeTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  discountCode: string | null;
};

export type PointsInitBuyPackage200AnyOfSixMethod = typeof PointsInitBuyPackage200AnyOfSixMethod[keyof typeof PointsInitBuyPackage200AnyOfSixMethod];


 
export const PointsInitBuyPackage200AnyOfSixMethod = {
  applePay: 'applePay',
  googlePay: 'googlePay',
} as const;

export type PointsInitBuyPackage200AnyOfSix = {
  paymentIntentId: string;
  clientSecret: string;
  amountUsd: number;
  currency: string;
  status: string;
  method: PointsInitBuyPackage200AnyOfSixMethod;
};

export type PointsInitBuyPackage200 = PointsInitBuyPackage200AnyOf | PointsInitBuyPackage200AnyOfThree | PointsInitBuyPackage200AnyOfSix;

export type PointsFinishBuyPackageBodyMethod = typeof PointsFinishBuyPackageBodyMethod[keyof typeof PointsFinishBuyPackageBodyMethod];


 
export const PointsFinishBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsFinishBuyPackageBody = {
  orderId: string;
  method: PointsFinishBuyPackageBodyMethod;
  trackingId?: string;
  ttclid?: string;
  ttp?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount = {
  currency_code: string;
  value: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItem = {
  reference_id: string;
  amount: PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount;
};

export type PointsFinishBuyPackage200AnyOf = {
  id: string;
  status: string;
  purchase_units: PointsFinishBuyPackage200AnyOfPurchaseUnitsItem[];
};

export type PointsFinishBuyPackage200AnyOfFour = {
  status: string;
};

export type PointsFinishBuyPackage200 = PointsFinishBuyPackage200AnyOf | PointsFinishBuyPackage200AnyOfFour;

export type PointsGetOrders200PayPalOrdersItem = {
  id: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrders200CryptoOrdersItemChainName = typeof PointsGetOrders200CryptoOrdersItemChainName[keyof typeof PointsGetOrders200CryptoOrdersItemChainName];


 
export const PointsGetOrders200CryptoOrdersItemChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrders200CryptoOrdersItem = {
  id: string;
  chainName: PointsGetOrders200CryptoOrdersItemChainName;
  tokenAmount: number;
  usdValue: number;
  confirmed: boolean;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsGetOrders200 = {
  payPalOrders: PointsGetOrders200PayPalOrdersItem[];
  cryptoOrders: PointsGetOrders200CryptoOrdersItem[];
};

export type PointsGetOrderParams = {
id: string;
method: PointsGetOrderMethod;
};

export type PointsGetOrderMethod = typeof PointsGetOrderMethod[keyof typeof PointsGetOrderMethod];


 
export const PointsGetOrderMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOf = {
  id: string;
  userId: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  packageDetailsJSON: string;
  /** @nullable */
  orderDataJSON: string | null;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  discountCode: string | null;
};

export type PointsGetOrder200AnyOfTwoChainName = typeof PointsGetOrder200AnyOfTwoChainName[keyof typeof PointsGetOrder200AnyOfTwoChainName];


 
export const PointsGetOrder200AnyOfTwoChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOfTwoTokenType = typeof PointsGetOrder200AnyOfTwoTokenType[keyof typeof PointsGetOrder200AnyOfTwoTokenType];


 
export const PointsGetOrder200AnyOfTwoTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsGetOrder200AnyOfTwo = {
  chainName: PointsGetOrder200AnyOfTwoChainName;
  tokenType: PointsGetOrder200AnyOfTwoTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  discountCode: string | null;
};

export type PointsGetOrder200 = PointsGetOrder200AnyOf | PointsGetOrder200AnyOfTwo;

export type UserGetParams = {
userId: string;
};

/**
 * @nullable
 */
export type UserGet200AvatarConfig = {
  imageId: string;
} | null;

export type UserGet200 = {
  id: string;
  banned: boolean;
  /** @nullable */
  webauthnUserID: string | null;
  /** @nullable */
  currentPassKeyChallenge: string | null;
  availablePoints: number;
  createdAt: string;
  updatedAt: string;
  spentPoints: number;
  admin: boolean;
  /** @nullable */
  referredById: string | null;
  lastNotificationSent: string;
  /** @nullable */
  privyId: string | null;
  /** @nullable */
  googleId: string | null;
  /** @nullable */
  twitterId: string | null;
  /** @nullable */
  tonId: string | null;
  /** @nullable */
  openaiId: string | null;
  /** @nullable */
  AvatarConfig: UserGet200AvatarConfig;
};

export type UserGetAffiliatePayoutDetails200 = {
  userId: string;
  /** @nullable */
  paypalEmail: string | null;
  totalPaid: number;
};

export type UserSetAffiliatePayoutDetailsBody = {
  paypalEmail: string;
};

export type UserSetAffiliatePayoutDetails200 = {
  userId: string;
  /** @nullable */
  paypalEmail: string | null;
  totalPaid: number;
};

export type UserAffiliatePayoutReceiptsParams = {
limit?: number;
offset?: number;
};

export type UserAffiliatePayoutReceipts200Item = {
  id: string;
  userId: string;
  amount: number;
  payoutDate: string;
};

export type UserProfileParams = {
userId: string;
};

export type UserProfile200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserPublicProfileParams = {
userId: string;
};

export type UserPublicProfile200Profile = {
  /** @nullable */
  username: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
};

export type UserPublicProfile200 = {
  profile: UserPublicProfile200Profile;
  imagesCreated: number;
  imagesFavorited: number;
};

export type UserGetUsernameParams = {
userId: string;
};

export type UserSetUsernameBody = {
  /**
   * @minLength 3
   * @maxLength 15
   * @pattern ^[a-zA-Z0-9_]+$
   */
  username: string;
};

export type UserSetUsername200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserSetBioBody = {
  bio: string;
};

export type UserSetBio200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserSendVerificationEmailBody = {
  email: string;
};

export type UserVerifyEmailTokenBody = {
  token: string;
};

export type UserVerifyEmailToken200 = {
  token: string;
  userId: string;
};

export type UserPointsHistoryParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: UserPointsHistoryOrder;
endDateTime?: string;
};

export type UserPointsHistoryOrder = typeof UserPointsHistoryOrder[keyof typeof UserPointsHistoryOrder];


 
export const UserPointsHistoryOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UserPointsHistory200ItemType = typeof UserPointsHistory200ItemType[keyof typeof UserPointsHistory200ItemType];


 
export const UserPointsHistory200ItemType = {
  purchase: 'purchase',
  refund: 'refund',
  comission: 'comission',
  bonus: 'bonus',
  referral: 'referral',
  commission: 'commission',
  promoCode: 'promoCode',
  createModel: 'createModel',
  cryptoDeposit: 'cryptoDeposit',
  createTrainingSet: 'createTrainingSet',
} as const;

export type UserPointsHistory200Item = {
  type: UserPointsHistory200ItemType;
  id: string;
  createdAt: string;
  /** @nullable */
  memo: string | null;
  quantity: number;
  userFinalBalance: number;
};

export type UserReferralsSummary200 = {
  invitedCount: number;
  earnedReferralPoints: number;
};

export type UserFindByUsernameParams = {
username: string;
};

export type UserFindByEmailParams = {
email: string;
};

export type UserFindByPhoneParams = {
phone: string;
};

export type UserFindByPrivyIdParams = {
privyId: string;
};

export type UserGetNotificationConfig200EmailFrequency = typeof UserGetNotificationConfig200EmailFrequency[keyof typeof UserGetNotificationConfig200EmailFrequency];


 
export const UserGetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200PhoneFrequency = typeof UserGetNotificationConfig200PhoneFrequency[keyof typeof UserGetNotificationConfig200PhoneFrequency];


 
export const UserGetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200TelegramFrequency = typeof UserGetNotificationConfig200TelegramFrequency[keyof typeof UserGetNotificationConfig200TelegramFrequency];


 
export const UserGetNotificationConfig200TelegramFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200 = {
  emailFrequency: UserGetNotificationConfig200EmailFrequency;
  phoneFrequency: UserGetNotificationConfig200PhoneFrequency;
  telegramFrequency: UserGetNotificationConfig200TelegramFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
  telegram: boolean;
};

export type UserSetNotificationConfigBodyEmailFrequency = typeof UserSetNotificationConfigBodyEmailFrequency[keyof typeof UserSetNotificationConfigBodyEmailFrequency];


 
export const UserSetNotificationConfigBodyEmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBodyPhoneFrequency = typeof UserSetNotificationConfigBodyPhoneFrequency[keyof typeof UserSetNotificationConfigBodyPhoneFrequency];


 
export const UserSetNotificationConfigBodyPhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBody = {
  email?: boolean;
  phone?: boolean;
  emailFrequency?: UserSetNotificationConfigBodyEmailFrequency;
  phoneFrequency?: UserSetNotificationConfigBodyPhoneFrequency;
};

export type UserSetNotificationConfig200EmailFrequency = typeof UserSetNotificationConfig200EmailFrequency[keyof typeof UserSetNotificationConfig200EmailFrequency];


 
export const UserSetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200PhoneFrequency = typeof UserSetNotificationConfig200PhoneFrequency[keyof typeof UserSetNotificationConfig200PhoneFrequency];


 
export const UserSetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200TelegramFrequency = typeof UserSetNotificationConfig200TelegramFrequency[keyof typeof UserSetNotificationConfig200TelegramFrequency];


 
export const UserSetNotificationConfig200TelegramFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200 = {
  emailFrequency: UserSetNotificationConfig200EmailFrequency;
  phoneFrequency: UserSetNotificationConfig200PhoneFrequency;
  telegramFrequency: UserSetNotificationConfig200TelegramFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
  telegram: boolean;
};

export type UserUnsubscribeEmailNotificationsBody = { [key: string]: unknown };

export type UserSetAvatarBodyPosition = {
  x: number;
  y: number;
};

export type UserSetAvatarBody = {
  imageId: string;
  scale: number;
  position: UserSetAvatarBodyPosition;
};

/**
 * @nullable
 */
export type UserAllUsers200ItemProfile = {
  /** @nullable */
  bio: string | null;
  /** @nullable */
  username: string | null;
} | null;

export type UserAllUsers200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  Profile: UserAllUsers200ItemProfile;
};

export type UserAuthConnections200Email = {
  linked: boolean;
  /** @nullable */
  address: string | null;
  verified: boolean;
};

export type UserAuthConnections200Telegram = {
  linked: boolean;
  /** @nullable */
  id: string | null;
  /** @nullable */
  name: string | null;
};

export type UserAuthConnections200 = {
  google: boolean;
  x: boolean;
  tonid: boolean;
  openai: boolean;
  email: UserAuthConnections200Email;
  telegram: UserAuthConnections200Telegram;
  passkeys: number;
};

export type UserOauthLinkStartUrlParams = {
provider?: UserOauthLinkStartUrlProvider;
redirect?: string;
referrer?: string;
response_format?: string;
redirect_tma?: string;
};

export type UserOauthLinkStartUrlProvider = typeof UserOauthLinkStartUrlProvider[keyof typeof UserOauthLinkStartUrlProvider];


 
export const UserOauthLinkStartUrlProvider = {
  google: 'google',
  x: 'x',
  tonid: 'tonid',
  openai: 'openai',
} as const;

export type UserOauthLinkStartUrl200 = {
  url: string;
};

export type UserUnlinkOAuthBodyProvider = typeof UserUnlinkOAuthBodyProvider[keyof typeof UserUnlinkOAuthBodyProvider];


 
export const UserUnlinkOAuthBodyProvider = {
  google: 'google',
  x: 'x',
  tonid: 'tonid',
} as const;

export type UserUnlinkOAuthBody = {
  provider: UserUnlinkOAuthBodyProvider;
};

export type UserUnlinkOAuth200 = {
  ok: boolean;
  reason?: string;
};

export type UserRequestDeleteAccountBody = {
  email?: string;
};

export type UserRequestDeleteAccount200Method = typeof UserRequestDeleteAccount200Method[keyof typeof UserRequestDeleteAccount200Method];


 
export const UserRequestDeleteAccount200Method = {
  email: 'email',
  telegram: 'telegram',
} as const;

export type UserRequestDeleteAccount200 = {
  ok: boolean;
  method?: UserRequestDeleteAccount200Method;
  reason?: string;
};

export type UserConfirmDeleteAccountBody = {
  token: string;
};

export type UserConfirmDeleteAccount200 = {
  ok: boolean;
};

export type LoginLinkInitLoginLinkBodyTracking = {
  utm_source?: string;
  utm_medium?: string;
  utm_campaign?: string;
  utm_term?: string;
  utm_content?: string;
  referrerUrl?: string;
  landingUrl?: string;
  gclid?: string;
  fbclid?: string;
  ttclid?: string;
  fbp?: string;
  fbc?: string;
  source?: string;
};

export type LoginLinkInitLoginLinkBody = {
  email?: string;
  phoneNumber?: string;
  referredBy?: string;
  tracking?: LoginLinkInitLoginLinkBodyTracking;
};

export type LoginLinkLoginWithLinkBody = {
  token: string;
};

export type LoginLinkLoginWithLink200 = {
  token: string;
  userId: string;
};

export type LoginLinkLoginWithCodeBody = {
  /**
   * @minLength 4
   * @maxLength 12
   */
  code: string;
};

export type LoginLinkLoginWithCode200 = {
  token: string;
  userId: string;
};

export type StatsUsers200 = {
  spentPoints: number;
  spentOver100Points: number;
  spentOver1000Points: number;
  spentOver10000Points: number;
  spentOver20000Points: number;
  purchasedImage: number;
  createdImage: number;
  emailVerified: number;
  phoneVerified: number;
  instagramVerified: number;
  twitterVerified: number;
  setUsername: number;
};

export type _StatsImages200AverageImageQuantityPerCreateRequestAvg = {
  /** @nullable */
  quantity: number | null;
};

export type StatsImages200AverageImageQuantityPerCreateRequest = {
  _avg: _StatsImages200AverageImageQuantityPerCreateRequestAvg;
};

export type StatsImages200 = {
  totalCreated: number;
  totalUpscaled: number;
  totalImageCreateRequests: number;
  averageImageQuantityPerCreateRequest: StatsImages200AverageImageQuantityPerCreateRequest;
  purchasedImages: number;
  totalPurchases: number;
  privateImages: number;
  imagesInAtLeastOneCollection: number;
  imageCreationFailed: number;
};

export type StatsCollections200 = {
  collectionsCreated: number;
  emptyCollections: number;
};

export type _StatsPayments200PaypalOrdersTotalPaidSum = {
  /** @nullable */
  amount: number | null;
};

export type StatsPayments200PaypalOrdersTotalPaid = {
  _sum: _StatsPayments200PaypalOrdersTotalPaidSum;
};

export type StatsPayments200 = {
  incompletePayPayPalOrders: number;
  completePayPayPalOrders: number;
  paypalOrdersTotalPaid: StatsPayments200PaypalOrdersTotalPaid;
};

export type StatsHistoryParams = {
from?: string;
to?: string;
limit?: number;
};

export type StatsHistory200SnapshotsItem = {
  bucketStart: string;
  usersSpentPointsGt0: number;
  usersSpentOver100: number;
  usersSpentOver1000: number;
  usersSpentOver10000: number;
  usersSpentOver20000: number;
  usersPurchasedImage: number;
  usersCreatedImage: number;
  usersEmailVerified: number;
  usersPhoneVerified: number;
  usersInstagramVerified: number;
  usersTwitterVerified: number;
  usersSetUsername: number;
  imagesTotalCreated: number;
  imagesTotalUpscaled: number;
  imageRequestsTotal: number;
  /** @nullable */
  imageRequestsAvgQuantity: number | null;
  imagesPurchased: number;
  purchasesTotal: number;
  imagesPrivate: number;
  imagesInAtLeastOneCollection: number;
  imagesCreationFailed: number;
  collectionsCreated: number;
  collectionsWithImages: number;
  paymentsIncompletePayPalOrders: number;
  paymentsCompletePayPalOrders: number;
  paymentsTotalPaid: number;
};

export type StatsHistory200 = {
  snapshots: StatsHistory200SnapshotsItem[];
};

export type StatsWeeklyParams = {
weeks?: number;
endAt?: string;
};

export type StatsWeekly200BucketsItemPaymentsByMethod = {
  payPal: number;
  crypto: number;
  stars: number;
};

export type StatsWeekly200BucketsItemPayments = {
  totalUsd: number;
  byMethod: StatsWeekly200BucketsItemPaymentsByMethod;
};

export type StatsWeekly200BucketsItem = {
  weekStart: string;
  activeUsers: number;
  payments: StatsWeekly200BucketsItemPayments;
};

export type StatsWeekly200 = {
  buckets: StatsWeekly200BucketsItem[];
};

export type CollectionsMediaInUsersCollectionParams = {
imageId?: string;
videoId?: string;
name: string;
};

export type CollectionsLikeMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CollectionsUnlikeMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CollectionsGetCollectionMetaParams = {
id: string;
};

export type _CollectionsGetCollectionMeta200Count = {
  Images: number;
  Favorited: number;
};

export type CollectionsGetCollectionMeta200 = {
  id: string;
  name: string;
  description: string;
  ownerId: string;
  private: boolean;
  _count: _CollectionsGetCollectionMeta200Count;
};

export type CollectionsFindCollectionByNameParams = {
ownerId: string;
collectionName: string;
};

export type CollectionsFindCollectionByName200 = {
  id: string;
};

export type CollectionsGetCollectionImagesParams = {
id: string;
limit?: number;
offset?: number;
order?: CollectionsGetCollectionImagesOrder;
startDateTime?: string;
endDateTime?: string;
model?: string;
aspectRatio?: string;
promptIncludes?: string;
};

export type CollectionsGetCollectionImagesOrder = typeof CollectionsGetCollectionImagesOrder[keyof typeof CollectionsGetCollectionImagesOrder];


 
export const CollectionsGetCollectionImagesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CollectionsGetCollectionImages200ItemImageRequest = {
  userId: string;
};

export type CollectionsGetCollectionImages200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  imageRequestId: string;
  seed: string;
  errored: boolean;
  filtered: boolean;
  deleted: boolean;
  /** @nullable */
  deletedAt: string | null;
  nsfw: boolean;
  imageRequest: CollectionsGetCollectionImages200ItemImageRequest;
};

export type CollectionsGetCollectionVideosParams = {
id: string;
limit?: number;
offset?: number;
order?: CollectionsGetCollectionVideosOrder;
startDateTime?: string;
endDateTime?: string;
model?: string;
aspectRatio?: string;
promptIncludes?: string;
};

export type CollectionsGetCollectionVideosOrder = typeof CollectionsGetCollectionVideosOrder[keyof typeof CollectionsGetCollectionVideosOrder];


 
export const CollectionsGetCollectionVideosOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CollectionsGetCollectionVideos200ItemStatus = typeof CollectionsGetCollectionVideos200ItemStatus[keyof typeof CollectionsGetCollectionVideos200ItemStatus];


 
export const CollectionsGetCollectionVideos200ItemStatus = {
  processing: 'processing',
  previewRendering: 'previewRendering',
  ready: 'ready',
  errored: 'errored',
} as const;

export type CollectionsGetCollectionVideos200ItemVideoRequest = {
  userId: string;
};

export type CollectionsGetCollectionVideos200Item = {
  status: CollectionsGetCollectionVideos200ItemStatus;
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  seed: string | null;
  errored: boolean;
  deleted: boolean;
  /** @nullable */
  deletedAt: string | null;
  nsfw: boolean;
  videoRequestId: string;
  /** @nullable */
  replicatePredictionId: string | null;
  /** @nullable */
  coconutJobId: string | null;
  /** @nullable */
  errorMessage: string | null;
  VideoRequest: CollectionsGetCollectionVideos200ItemVideoRequest;
};

export type CollectionsGetCollectionMediaParams = {
id: string;
limit?: number;
offset?: number;
order?: CollectionsGetCollectionMediaOrder;
startDateTime?: string;
endDateTime?: string;
model?: string;
aspectRatio?: string;
promptIncludes?: string;
mediaType?: CollectionsGetCollectionMediaMediaType;
};

export type CollectionsGetCollectionMediaOrder = typeof CollectionsGetCollectionMediaOrder[keyof typeof CollectionsGetCollectionMediaOrder];


 
export const CollectionsGetCollectionMediaOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CollectionsGetCollectionMediaMediaType = typeof CollectionsGetCollectionMediaMediaType[keyof typeof CollectionsGetCollectionMediaMediaType];


 
export const CollectionsGetCollectionMediaMediaType = {
  image: 'image',
  video: 'video',
  all: 'all',
} as const;

export type CollectionsGetCollectionMedia200ItemsItemMediaType = typeof CollectionsGetCollectionMedia200ItemsItemMediaType[keyof typeof CollectionsGetCollectionMedia200ItemsItemMediaType];


 
export const CollectionsGetCollectionMedia200ItemsItemMediaType = {
  image: 'image',
  video: 'video',
} as const;

export type CollectionsGetCollectionMedia200ItemsItem = {
  mediaType: CollectionsGetCollectionMedia200ItemsItemMediaType;
  id: string;
  createdAt: string;
  aspectRatio: string;
  requestId: string;
  userId: string;
};

export type CollectionsGetCollectionMedia200TotalCounts = {
  image: number;
  video: number;
  all: number;
};

export type CollectionsGetCollectionMedia200 = {
  items: CollectionsGetCollectionMedia200ItemsItem[];
  totalCounts: CollectionsGetCollectionMedia200TotalCounts;
  hasMore: boolean;
};

export type PromoCreatePromoCodeBody = {
  points: number;
};

export type PromoCreatePromoCode200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoDeletePromoCodeBody = {
  id: string;
};

export type PromoGetPromoCodes200Item = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoGetPromoCodeDetailsParams = {
id: string;
};

export type PromoGetPromoCodeDetails200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoClaimPromoCodeBody = {
  id: string;
};

export type PromoCreateAccountWithPromoBody = {
  id: string;
  referrerUsername?: string;
  email?: string;
};

export type PromoCreateAccountWithPromo200 = {
  token: string;
  userId: string;
};

export type ModelsEditModelBody = {
  id: string;
  /** @maxLength 30 */
  name: string;
  /** @maxLength 500 */
  description: string;
};

export type ModelsGetUserModelsParams = {
trainingSetId?: string;
};

export type ModelsGetUserModels200ItemStatus = typeof ModelsGetUserModels200ItemStatus[keyof typeof ModelsGetUserModels200ItemStatus];


 
export const ModelsGetUserModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetUserModels200ItemModelType = typeof ModelsGetUserModels200ItemModelType[keyof typeof ModelsGetUserModels200ItemModelType];


 
export const ModelsGetUserModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetUserModels200ItemFineTuneType = typeof ModelsGetUserModels200ItemFineTuneType[keyof typeof ModelsGetUserModels200ItemFineTuneType] | null;


 
export const ModelsGetUserModels200ItemFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetUserModels200ItemMode = typeof ModelsGetUserModels200ItemMode[keyof typeof ModelsGetUserModels200ItemMode];


 
export const ModelsGetUserModels200ItemMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetUserModels200ItemModelTagsItem = typeof ModelsGetUserModels200ItemModelTagsItem[keyof typeof ModelsGetUserModels200ItemModelTagsItem];


 
export const ModelsGetUserModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetUserModels200ItemImageRequestsItemImagesItem = {
  id: string;
};

export type ModelsGetUserModels200ItemImageRequestsItem = {
  id: string;
  images: ModelsGetUserModels200ItemImageRequestsItemImagesItem[];
};

export type ModelsGetUserModels200Item = {
  status: ModelsGetUserModels200ItemStatus;
  modelType: ModelsGetUserModels200ItemModelType;
  /** @nullable */
  fineTuneType: ModelsGetUserModels200ItemFineTuneType;
  mode: ModelsGetUserModels200ItemMode;
  modelTags: ModelsGetUserModels200ItemModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
  featured: boolean;
  imageRequests: ModelsGetUserModels200ItemImageRequestsItem[];
};

export type ModelsCreateModelBodyBaseModel = typeof ModelsCreateModelBodyBaseModel[keyof typeof ModelsCreateModelBodyBaseModel];


 
export const ModelsCreateModelBodyBaseModel = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

export type ModelsCreateModelBodyModelMode = typeof ModelsCreateModelBodyModelMode[keyof typeof ModelsCreateModelBodyModelMode];


 
export const ModelsCreateModelBodyModelMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsCreateModelBodyFineTuneType = typeof ModelsCreateModelBodyFineTuneType[keyof typeof ModelsCreateModelBodyFineTuneType];


 
export const ModelsCreateModelBodyFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsCreateModelBody = {
  name: string;
  description: string;
  baseModel: ModelsCreateModelBodyBaseModel;
  modelMode: ModelsCreateModelBodyModelMode;
  fineTuneType: ModelsCreateModelBodyFineTuneType;
  trainingSetId: string;
};

export type ModelsGetTrainingStatusParams = {
id: string;
};

export type ModelsGetTrainingStatus200Status = typeof ModelsGetTrainingStatus200Status[keyof typeof ModelsGetTrainingStatus200Status];


 
export const ModelsGetTrainingStatus200Status = {
  processing: 'processing',
  trained: 'trained',
  succeeded: 'succeeded',
  failed: 'failed',
  starting: 'starting',
} as const;

export type ModelsGetTrainingStatus200 = {
  status: ModelsGetTrainingStatus200Status;
  /** @nullable */
  error: string | null;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  elapsedTime: string;
  remainingTime: string;
};

export type ModelsDeleteModelBody = {
  id: string;
};

export type ModelsGetCustomModelParams = {
id: string;
};

export type ModelsGetCustomModel200Status = typeof ModelsGetCustomModel200Status[keyof typeof ModelsGetCustomModel200Status];


 
export const ModelsGetCustomModel200Status = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetCustomModel200ModelType = typeof ModelsGetCustomModel200ModelType[keyof typeof ModelsGetCustomModel200ModelType];


 
export const ModelsGetCustomModel200ModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetCustomModel200FineTuneType = typeof ModelsGetCustomModel200FineTuneType[keyof typeof ModelsGetCustomModel200FineTuneType] | null;


 
export const ModelsGetCustomModel200FineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetCustomModel200Mode = typeof ModelsGetCustomModel200Mode[keyof typeof ModelsGetCustomModel200Mode];


 
export const ModelsGetCustomModel200Mode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetCustomModel200ModelTagsItem = typeof ModelsGetCustomModel200ModelTagsItem[keyof typeof ModelsGetCustomModel200ModelTagsItem];


 
export const ModelsGetCustomModel200ModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetCustomModel200 = {
  status: ModelsGetCustomModel200Status;
  modelType: ModelsGetCustomModel200ModelType;
  /** @nullable */
  fineTuneType: ModelsGetCustomModel200FineTuneType;
  mode: ModelsGetCustomModel200Mode;
  modelTags: ModelsGetCustomModel200ModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
  featured: boolean;
};

export type ModelsGetPublicModelsParams = {
page?: number;
tag?: ModelsGetPublicModelsTag;
creatorId?: string;
};

export type ModelsGetPublicModelsTag = typeof ModelsGetPublicModelsTag[keyof typeof ModelsGetPublicModelsTag];


 
export const ModelsGetPublicModelsTag = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetPublicModels200ItemStatus = typeof ModelsGetPublicModels200ItemStatus[keyof typeof ModelsGetPublicModels200ItemStatus];


 
export const ModelsGetPublicModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetPublicModels200ItemModelType = typeof ModelsGetPublicModels200ItemModelType[keyof typeof ModelsGetPublicModels200ItemModelType];


 
export const ModelsGetPublicModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetPublicModels200ItemFineTuneType = typeof ModelsGetPublicModels200ItemFineTuneType[keyof typeof ModelsGetPublicModels200ItemFineTuneType] | null;


 
export const ModelsGetPublicModels200ItemFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetPublicModels200ItemMode = typeof ModelsGetPublicModels200ItemMode[keyof typeof ModelsGetPublicModels200ItemMode];


 
export const ModelsGetPublicModels200ItemMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetPublicModels200ItemModelTagsItem = typeof ModelsGetPublicModels200ItemModelTagsItem[keyof typeof ModelsGetPublicModels200ItemModelTagsItem];


 
export const ModelsGetPublicModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetPublicModels200Item = {
  status: ModelsGetPublicModels200ItemStatus;
  modelType: ModelsGetPublicModels200ItemModelType;
  /** @nullable */
  fineTuneType: ModelsGetPublicModels200ItemFineTuneType;
  mode: ModelsGetPublicModels200ItemMode;
  modelTags: ModelsGetPublicModels200ItemModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
  featured: boolean;
  previewMediaId?: string;
};

export type ModelsGetBaseModelsParams = {
page?: number;
};

export type ModelsGetBaseModels200ItemModelTagsItem = typeof ModelsGetBaseModels200ItemModelTagsItem[keyof typeof ModelsGetBaseModels200ItemModelTagsItem];


 
export const ModelsGetBaseModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetBaseModels200Item = {
  modelTags: ModelsGetBaseModels200ItemModelTagsItem[];
  slug: string;
  updatedAt: string;
  name: string;
  /** @nullable */
  description: string | null;
  featured: boolean;
  /** @nullable */
  blogLink: string | null;
  /** @nullable */
  longDescription: string | null;
  previewMediaId?: string;
};

export type ModelsGetModelByNameParams = {
name: string;
customModelId?: string;
includeMedia?: number;
};

export type ModelsGetModelByName200CustomModelCreator = {
  id: string;
  userName: string;
};

export type ModelsGetModelByName200ModelModelTagsItem = typeof ModelsGetModelByName200ModelModelTagsItem[keyof typeof ModelsGetModelByName200ModelModelTagsItem];


 
export const ModelsGetModelByName200ModelModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetModelByName200Model = {
  modelTags: ModelsGetModelByName200ModelModelTagsItem[];
  slug: string;
  updatedAt: string;
  name: string;
  /** @nullable */
  description: string | null;
  featured: boolean;
  /** @nullable */
  blogLink: string | null;
  /** @nullable */
  longDescription: string | null;
};

export type ModelsGetModelByName200MediaItem = {
  id: string;
  meta: string;
  creatorUsername?: string;
};

export type ModelsGetModelByName200 = {
  customModelCreator?: ModelsGetModelByName200CustomModelCreator;
  model: ModelsGetModelByName200Model;
  media?: ModelsGetModelByName200MediaItem[];
};

export type ModelsSetModelPrivacyBody = {
  id: string;
  public: boolean;
};

export type AdminLoginAsUserBody = {
  id: string;
};

export type AdminBanUserBody = {
  userId: string;
  reason?: string;
};

export type AdminBanUser200Stats = {
  images: number;
  videos: number;
  imageRequests: number;
  videoRequests: number;
  uploadedImages: number;
};

export type AdminBanUser200 = {
  stats: AdminBanUser200Stats;
};

export type AdminListUsersParams = {
limit?: number;
offset?: number;
search?: string;
includeBanned?: boolean;
sortBy?: AdminListUsersSortBy;
sortDir?: AdminListUsersSortDir;
};

export type AdminListUsersSortBy = typeof AdminListUsersSortBy[keyof typeof AdminListUsersSortBy];


 
export const AdminListUsersSortBy = {
  lastActiveAt: 'lastActiveAt',
  spentPoints: 'spentPoints',
  availablePoints: 'availablePoints',
  createdAt: 'createdAt',
  updatedAt: 'updatedAt',
} as const;

export type AdminListUsersSortDir = typeof AdminListUsersSortDir[keyof typeof AdminListUsersSortDir];


 
export const AdminListUsersSortDir = {
  asc: 'asc',
  desc: 'desc',
} as const;

/**
 * @nullable
 */
export type AdminListUsers200UsersItemProfile = {
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  /** @nullable */
  emailVerified: boolean | null;
  /** @nullable */
  phone: string | null;
  /** @nullable */
  phoneVerified: boolean | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
  /** @nullable */
  twitter: string | null;
  /** @nullable */
  twitterVerified: boolean | null;
  /** @nullable */
  instagram: string | null;
  /** @nullable */
  instagramVerified: boolean | null;
  /** @nullable */
  pangeaAccount: string | null;
  /** @nullable */
  privyId: string | null;
} | null;

export type AdminListUsers200UsersItemStats = {
  imageRequests: number;
  imageRequestsFinished: number;
  images: number;
  videoRequests: number;
  videos: number;
  imagePurchases: number;
  videoPurchases: number;
  customModels: number;
  trainingSets: number;
};

export type AdminListUsers200UsersItem = {
  id: string;
  createdAt: string;
  updatedAt: string;
  banned: boolean;
  admin: boolean;
  availablePoints: number;
  spentPoints: number;
  lastActiveAt: string;
  /** @nullable */
  profile: AdminListUsers200UsersItemProfile;
  wallets: string[];
  stats: AdminListUsers200UsersItemStats;
};

export type AdminListUsers200 = {
  total: number;
  users: AdminListUsers200UsersItem[];
};

export type AdminListPaymentsParams = {
limit?: number;
offset?: number;
startDateTime?: string;
endDateTime?: string;
method?: AdminListPaymentsMethod;
userId?: string;
status?: string;
};

export type AdminListPaymentsMethod = typeof AdminListPaymentsMethod[keyof typeof AdminListPaymentsMethod];


 
export const AdminListPaymentsMethod = {
  payPal: 'payPal',
  crypto: 'crypto',
  stars: 'stars',
} as const;

export type AdminListPayments200ItemsItemMethod = typeof AdminListPayments200ItemsItemMethod[keyof typeof AdminListPayments200ItemsItemMethod];


 
export const AdminListPayments200ItemsItemMethod = {
  payPal: 'payPal',
  crypto: 'crypto',
  stars: 'stars',
} as const;

/**
 * @nullable
 */
export type AdminListPayments200ItemsItemUser = {
  id: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
} | null;

/**
 * @nullable
 */
export type AdminListPayments200ItemsItemPackage = {
  points: number;
  usd: number;
  discountPct: number;
} | null;

export type AdminListPayments200ItemsItemDetails = {
  orderID?: string;
  currency?: string;
  chainName?: string;
  tokenAmount?: number;
  tokenType?: string;
  /** @nullable */
  transactionId?: string | null;
  /** @nullable */
  memo?: string | null;
  destWallet?: string;
  /** @nullable */
  senderWallet?: string | null;
  packageId?: number;
  stars?: number;
};

export type AdminListPayments200ItemsItem = {
  id: string;
  method: AdminListPayments200ItemsItemMethod;
  /** @nullable */
  user: AdminListPayments200ItemsItemUser;
  /** @nullable */
  amountUsd: number | null;
  /** @nullable */
  points: number | null;
  status: string;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
  /** @nullable */
  discountCode?: string | null;
  /** @nullable */
  package?: AdminListPayments200ItemsItemPackage;
  details?: AdminListPayments200ItemsItemDetails;
};

export type AdminListPayments200 = {
  total: number;
  items: AdminListPayments200ItemsItem[];
};

export type AdminListMissionClaimsParams = {
limit?: number;
offset?: number;
startDateTime?: string;
endDateTime?: string;
userId?: string;
missionId?: string;
};

/**
 * @nullable
 */
export type AdminListMissionClaims200ItemsItemUser = {
  id: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
} | null;

export type AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfType = typeof AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfType[keyof typeof AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfType];


 
export const AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfType = {
  points: 'points',
} as const;

export type AdminListMissionClaims200ItemsItemMissionRewardsItemOneOf = {
  type: AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfType;
  /** @minimum 0 */
  amount: number;
  memo?: string;
};

export type AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThreeType = typeof AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThreeType[keyof typeof AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThreeType];


 
export const AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThreeType = {
  badge: 'badge',
} as const;

export type AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThree = {
  type: AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThreeType;
  badgeId: string;
};

export type AdminListMissionClaims200ItemsItemMissionRewardsItem = AdminListMissionClaims200ItemsItemMissionRewardsItemOneOf | AdminListMissionClaims200ItemsItemMissionRewardsItemOneOfThree;

/**
 * @nullable
 */
export type AdminListMissionClaims200ItemsItemMission = {
  id: string;
  description: string;
  rewards: AdminListMissionClaims200ItemsItemMissionRewardsItem[];
} | null;

export type AdminListMissionClaims200ItemsItem = {
  id: string;
  missionId: string;
  claimKey: string;
  createdAt: string;
  /** @nullable */
  user: AdminListMissionClaims200ItemsItemUser;
  /** @nullable */
  mission: AdminListMissionClaims200ItemsItemMission;
};

export type AdminListMissionClaims200 = {
  total: number;
  items: AdminListMissionClaims200ItemsItem[];
};

export type AdminListTrainingSetThumbnailsParams = {
limit?: number;
offset?: number;
account?: string;
startDateTime?: string;
endDateTime?: string;
};

/**
 * @nullable
 */
export type AdminListTrainingSetThumbnails200ItemsItemUser = {
  id: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
} | null;

export type AdminListTrainingSetThumbnails200ItemsItem = {
  thumbnailId: string;
  trainingSetId: string;
  createdAt: string;
  url: string;
  /** @nullable */
  user: AdminListTrainingSetThumbnails200ItemsItemUser;
};

export type AdminListTrainingSetThumbnails200 = {
  total: number;
  items: AdminListTrainingSetThumbnails200ItemsItem[];
};

export type AdminListUploadedImagesParams = {
limit?: number;
offset?: number;
account?: string;
startDateTime?: string;
endDateTime?: string;
};

/**
 * @nullable
 */
export type AdminListUploadedImages200ItemsItemUser = {
  id: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  /** @nullable */
  telegramId: string | null;
  /** @nullable */
  telegramName: string | null;
} | null;

export type AdminListUploadedImages200ItemsItem = {
  id: string;
  createdAt: string;
  url: string;
  /** @nullable */
  user: AdminListUploadedImages200ItemsItemUser;
};

export type AdminListUploadedImages200 = {
  total: number;
  items: AdminListUploadedImages200ItemsItem[];
};

export type AdminDiscountCodesList200Item = {
  code: string;
  discount: number;
  createdAt: string;
  used: number;
  maximumUses: number;
  /** @nullable */
  linkedUserId: string | null;
  totalUsdSpent: number;
  totalUsdSaved: number;
  affiliatePaid: number;
  affiliatePayoutPending: number;
};

export type AdminDiscountCodeCreateBody = {
  /** @minLength 1 */
  code: string;
  /**
   * @minimum 0
   * @maximum 0.95
   */
  discount: number;
  /** @minimum 1 */
  maximumUses: number;
  /** @nullable */
  linkedUserId?: string | null;
};

export type AdminDiscountCodeCreate200 = {
  code: string;
  discount: number;
  createdAt: string;
  used: number;
  maximumUses: number;
  /** @nullable */
  linkedUserId: string | null;
  totalUsdSpent: number;
  totalUsdSaved: number;
  affiliatePaid: number;
  affiliatePayoutPending: number;
};

export type AdminDiscountCodeUpdateBody = {
  /** @minLength 1 */
  code: string;
  /**
   * @minimum 0
   * @maximum 0.95
   */
  discount?: number;
  /** @minimum 1 */
  maximumUses?: number;
  /** @nullable */
  linkedUserId?: string | null;
};

export type AdminDiscountCodeUpdate200 = {
  code: string;
  discount: number;
  createdAt: string;
  used: number;
  maximumUses: number;
  /** @nullable */
  linkedUserId: string | null;
  totalUsdSpent: number;
  totalUsdSaved: number;
  affiliatePaid: number;
  affiliatePayoutPending: number;
};

export type AdminAffiliatePayoutDetailsForUserParams = {
userId: string;
};

export type AdminAffiliatePayoutDetailsForUser200 = {
  userId: string;
  /** @nullable */
  paypalEmail: string | null;
  totalPaid: number;
};

export type AdminAffiliatePayoutUserBody = {
  userId: string;
};

export type AdminAffiliatePayoutUser200Receipt = {
  id: string;
  userId: string;
  amount: number;
  payoutDate: string;
};

export type AdminAffiliatePayoutUser200 = {
  receipt: AdminAffiliatePayoutUser200Receipt;
  codesUpdated: number;
};

export type AdminAffiliatePayoutReceiptsParams = {
limit?: number;
offset?: number;
};

export type AdminAffiliatePayoutReceipts200Item = {
  id: string;
  userId: string;
  amount: number;
  payoutDate: string;
};

export type AdminDiscountCodeDeleteBody = {
  /** @minLength 1 */
  code: string;
};

export type AdminDiscountCodeDelete200 = {
  ok: boolean;
};

export type TonomyAuthLoginOrRegisterBody = {
  jwtString: string;
  referrerUsername?: string;
};

export type TonomyAuthLoginOrRegister200 = {
  token: string;
  userId: string;
};

export type PrivyAuthenticateBody = {
  accessToken: string;
  referrerUsername?: string;
};

export type PrivyAuthenticate200 = {
  token: string;
  userId: string;
};

export type PrivyLinkCurrentUserBody = {
  accessToken: string;
};

export type PrivyLinkCurrentUser200 = {
  token: string;
  userId: string;
};

export type PromptTemplatesListParams = {
tag?: string;
kind?: PromptTemplatesListKind;
page?: number;
pageSize?: number;
};

export type PromptTemplatesListKind = typeof PromptTemplatesListKind[keyof typeof PromptTemplatesListKind];


 
export const PromptTemplatesListKind = {
  subject: 'subject',
  setting: 'setting',
  style: 'style',
  mood: 'mood',
} as const;

export type PromptTemplatesList200ItemKind = typeof PromptTemplatesList200ItemKind[keyof typeof PromptTemplatesList200ItemKind];


 
export const PromptTemplatesList200ItemKind = {
  subject: 'subject',
  setting: 'setting',
  style: 'style',
  mood: 'mood',
} as const;

export type PromptTemplatesList200ItemSlots = {[key: string]: string | string[]};

export type PromptTemplatesList200Item = {
  id: string;
  name: string;
  kind: PromptTemplatesList200ItemKind;
  tags: string[];
  /** @nullable */
  previewUrl: string | null;
  /** @nullable */
  previewUrlMale: string | null;
  /** @nullable */
  previewUrlFemale: string | null;
  slots: PromptTemplatesList200ItemSlots;
};

export type TrainingSetsCreateSetBody = {
  /** @maxLength 100 */
  name: string;
  /** @maxLength 1400 */
  description: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  numImages: number;
  /** @maximum 800 */
  zipSizeMb: number;
};

export type TrainingSetsCreateSet200SignedZipUploadDataFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedZipUploadData = {
  url: string;
  fields: TrainingSetsCreateSet200SignedZipUploadDataFields;
};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItem = {
  url: string;
  fields: TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields;
};

export type TrainingSetsCreateSet200 = {
  trainingSetId: string;
  signedZipUploadData: TrainingSetsCreateSet200SignedZipUploadData;
  signedThumbnailUploadDatas: TrainingSetsCreateSet200SignedThumbnailUploadDatasItem[];
};

export type TrainingSetsFinalizeSetBody = {
  trainingSetId: string;
};

export type TrainingSetsGetUserSetsParams = {
userId: string;
};

/**
 * @nullable
 */
export type TrainingSetsGetUserSets200ItemSubjectGender = typeof TrainingSetsGetUserSets200ItemSubjectGender[keyof typeof TrainingSetsGetUserSets200ItemSubjectGender] | null;


 
export const TrainingSetsGetUserSets200ItemSubjectGender = {
  male: 'male',
  female: 'female',
  unknown: 'unknown',
} as const;

/**
 * @nullable
 */
export type TrainingSetsGetUserSets200ItemSubjectCategory = typeof TrainingSetsGetUserSets200ItemSubjectCategory[keyof typeof TrainingSetsGetUserSets200ItemSubjectCategory] | null;


 
export const TrainingSetsGetUserSets200ItemSubjectCategory = {
  human: 'human',
  animal: 'animal',
  object: 'object',
  architecture: 'architecture',
  setting: 'setting',
  style: 'style',
  dog: 'dog',
  cat: 'cat',
  other: 'other',
} as const;

export type TrainingSetsGetUserSets200Item = {
  /** @nullable */
  subjectGender: TrainingSetsGetUserSets200ItemSubjectGender;
  /** @nullable */
  subjectCategory: TrainingSetsGetUserSets200ItemSubjectCategory;
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  /** @nullable */
  description: string | null;
  deleted: boolean;
  updatedAt: string;
  /** @nullable */
  subjectDescription: string | null;
};

export type TrainingSetsGetSetParams = {
trainingSetId: string;
};

/**
 * @nullable
 */
export type TrainingSetsGetSet200SubjectGender = typeof TrainingSetsGetSet200SubjectGender[keyof typeof TrainingSetsGetSet200SubjectGender] | null;


 
export const TrainingSetsGetSet200SubjectGender = {
  male: 'male',
  female: 'female',
  unknown: 'unknown',
} as const;

/**
 * @nullable
 */
export type TrainingSetsGetSet200SubjectCategory = typeof TrainingSetsGetSet200SubjectCategory[keyof typeof TrainingSetsGetSet200SubjectCategory] | null;


 
export const TrainingSetsGetSet200SubjectCategory = {
  human: 'human',
  animal: 'animal',
  object: 'object',
  architecture: 'architecture',
  setting: 'setting',
  style: 'style',
  dog: 'dog',
  cat: 'cat',
  other: 'other',
} as const;

export type TrainingSetsGetSet200 = {
  /** @nullable */
  subjectGender: TrainingSetsGetSet200SubjectGender;
  /** @nullable */
  subjectCategory: TrainingSetsGetSet200SubjectCategory;
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  /** @nullable */
  description: string | null;
  deleted: boolean;
  updatedAt: string;
  /** @nullable */
  subjectDescription: string | null;
};

export type TrainingSetsDeleteSetBody = {
  trainingSetId: string;
};

export type TrainingSetsEditSetBody = {
  trainingSetId: string;
  /** @maxLength 32 */
  newName: string;
  /** @maxLength 400 */
  newDescription: string;
};

export type TrainingSetsDescribeSetParams = {
trainingSetId: string;
};

/**
 * @nullable
 */
export type TrainingSetsDescribeSet200SubjectGender = typeof TrainingSetsDescribeSet200SubjectGender[keyof typeof TrainingSetsDescribeSet200SubjectGender] | null;


 
export const TrainingSetsDescribeSet200SubjectGender = {
  male: 'male',
  female: 'female',
  unknown: 'unknown',
} as const;

/**
 * @nullable
 */
export type TrainingSetsDescribeSet200SubjectCategory = typeof TrainingSetsDescribeSet200SubjectCategory[keyof typeof TrainingSetsDescribeSet200SubjectCategory] | null;


 
export const TrainingSetsDescribeSet200SubjectCategory = {
  human: 'human',
  animal: 'animal',
  object: 'object',
  architecture: 'architecture',
  setting: 'setting',
  style: 'style',
  dog: 'dog',
  cat: 'cat',
  other: 'other',
} as const;

export type TrainingSetsDescribeSet200 = {
  /** @nullable */
  subjectGender: TrainingSetsDescribeSet200SubjectGender;
  /** @nullable */
  subjectCategory: TrainingSetsDescribeSet200SubjectCategory;
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  /** @nullable */
  description: string | null;
  deleted: boolean;
  updatedAt: string;
  /** @nullable */
  subjectDescription: string | null;
};

export type UpvotesGetWallet200 = {
  allowance: number;
  usedToday: number;
  remainingToday: number;
  resetAt: string;
};

export type UpvotesUpvoteBody = {
  imageId?: string;
  videoId?: string;
};

export type UpvotesUpvote200 = {
  allowance: number;
  remainingToday: number;
};

export type UpvotesGetMediaUpvoteCountParams = {
imageId?: string;
videoId?: string;
since?: string;
};

export type UpvotesGetMediaUpvoteCount200 = {
  total: number;
};

export type UpvotesDownvoteBody = {
  imageId?: string;
  videoId?: string;
};

export type UpvotesDownvote200 = {
  hidden: boolean;
};

export type UpvotesUnhideBody = {
  imageId?: string;
  videoId?: string;
};

export type UpvotesUnhide200 = {
  hidden: boolean;
};

export type UpvotesGetHiddenListParams = {
limit?: number;
offset?: number;
};

export type UpvotesGetHiddenList200 = {
  images: string[];
  videos: string[];
};

export type PopularityBatchBodyItemsItemMediaType = typeof PopularityBatchBodyItemsItemMediaType[keyof typeof PopularityBatchBodyItemsItemMediaType];


 
export const PopularityBatchBodyItemsItemMediaType = {
  image: 'image',
  video: 'video',
} as const;

export type PopularityBatchBodyItemsItem = {
  id: string;
  mediaType: PopularityBatchBodyItemsItemMediaType;
};

export type PopularityBatchBody = {
  /**
   * @minItems 1
   * @maxItems 100
   */
  items: PopularityBatchBodyItemsItem[];
  /**
   * @minimum 1
   * @maximum 365
   */
  upvotesSinceDays?: number;
};

export type PopularityBatch200Item = {
  id: string;
  favorites: number;
  upvotes: number;
  downvotes: number;
  commentsCount: number;
  isFavoritedByMe?: boolean;
  isUpvotedByMe?: boolean;
  hidden?: boolean;
};

export type EventsPublicEventsParams = {
since?: string;
limit?: number;
types?: string | string[];
};

export type EventsPublicEvents200ItemType = typeof EventsPublicEvents200ItemType[keyof typeof EventsPublicEvents200ItemType];


 
export const EventsPublicEvents200ItemType = {
  likedImage: 'likedImage',
  likedVideo: 'likedVideo',
  unlikedVideo: 'unlikedVideo',
  addedImageToCollection: 'addedImageToCollection',
  unlockedImage: 'unlockedImage',
  unlockedVideo: 'unlockedVideo',
  unlikedImage: 'unlikedImage',
  removedImageFromCollection: 'removedImageFromCollection',
  referredUser: 'referredUser',
  missionCompleted: 'missionCompleted',
  earnedComission: 'earnedComission',
  creationCommented: 'creationCommented',
  commentMentioned: 'commentMentioned',
  asyncError: 'asyncError',
} as const;

export type EventsPublicEvents200Item = {
  type: EventsPublicEvents200ItemType;
  id: string;
  createdAt: string;
  dataJSON: string;
  originUserId: string;
  /** @nullable */
  originUsername: string | null;
  seen?: boolean;
};

export type EventsPrivateEventsParams = {
since?: string;
limit?: number;
includeSeen?: boolean;
types?: string | string[];
};

export type EventsPrivateEvents200ItemType = typeof EventsPrivateEvents200ItemType[keyof typeof EventsPrivateEvents200ItemType];


 
export const EventsPrivateEvents200ItemType = {
  likedImage: 'likedImage',
  likedVideo: 'likedVideo',
  unlikedVideo: 'unlikedVideo',
  addedImageToCollection: 'addedImageToCollection',
  unlockedImage: 'unlockedImage',
  unlockedVideo: 'unlockedVideo',
  unlikedImage: 'unlikedImage',
  removedImageFromCollection: 'removedImageFromCollection',
  referredUser: 'referredUser',
  missionCompleted: 'missionCompleted',
  earnedComission: 'earnedComission',
  creationCommented: 'creationCommented',
  commentMentioned: 'commentMentioned',
  asyncError: 'asyncError',
} as const;

export type EventsPrivateEvents200Item = {
  type: EventsPrivateEvents200ItemType;
  id: string;
  createdAt: string;
  dataJSON: string;
  originUserId: string;
  /** @nullable */
  originUsername: string | null;
  seen?: boolean;
};

export type EventsMarkEventSeenBody = {
  eventId: string;
};

export type MissionsList200ItemRewardsItemOneOfType = typeof MissionsList200ItemRewardsItemOneOfType[keyof typeof MissionsList200ItemRewardsItemOneOfType];


 
export const MissionsList200ItemRewardsItemOneOfType = {
  points: 'points',
} as const;

export type MissionsList200ItemRewardsItemOneOf = {
  type: MissionsList200ItemRewardsItemOneOfType;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  amount: number;
  memo?: string;
};

export type MissionsList200ItemRewardsItemOneOfThreeType = typeof MissionsList200ItemRewardsItemOneOfThreeType[keyof typeof MissionsList200ItemRewardsItemOneOfThreeType];


 
export const MissionsList200ItemRewardsItemOneOfThreeType = {
  badge: 'badge',
} as const;

export type MissionsList200ItemRewardsItemOneOfThree = {
  type: MissionsList200ItemRewardsItemOneOfThreeType;
  badgeId: string;
};

export type MissionsList200ItemRewardsItem = MissionsList200ItemRewardsItemOneOf | MissionsList200ItemRewardsItemOneOfThree;

export type MissionsList200Item = {
  id: string;
  description: string;
  rewards: MissionsList200ItemRewardsItem[];
  /**
   * @minimum 0
   * @maximum 100
   */
  activeUsersEarnedPct?: number;
};

export type MissionsProgressParams = {
missionId: string;
userId?: string;
};

export type MissionsProgress200 = {
  missionId: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
};

export type MissionsIsClaimedParams = {
missionId: string;
userId?: string;
};

export type MissionsIsClaimed200 = {
  missionId: string;
  claimed: boolean;
  claimKey: string;
  claimedAt?: string;
};

export type MissionsClaimBody = {
  missionId: string;
  userId?: string;
};

export type MissionsClaim200RewardsAwardedItemOneOfType = typeof MissionsClaim200RewardsAwardedItemOneOfType[keyof typeof MissionsClaim200RewardsAwardedItemOneOfType];


 
export const MissionsClaim200RewardsAwardedItemOneOfType = {
  points: 'points',
} as const;

export type MissionsClaim200RewardsAwardedItemOneOf = {
  type: MissionsClaim200RewardsAwardedItemOneOfType;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  amount: number;
  memo?: string;
};

export type MissionsClaim200RewardsAwardedItemOneOfThreeType = typeof MissionsClaim200RewardsAwardedItemOneOfThreeType[keyof typeof MissionsClaim200RewardsAwardedItemOneOfThreeType];


 
export const MissionsClaim200RewardsAwardedItemOneOfThreeType = {
  badge: 'badge',
} as const;

export type MissionsClaim200RewardsAwardedItemOneOfThree = {
  type: MissionsClaim200RewardsAwardedItemOneOfThreeType;
  badgeId: string;
};

export type MissionsClaim200RewardsAwardedItem = MissionsClaim200RewardsAwardedItemOneOf | MissionsClaim200RewardsAwardedItemOneOfThree;

export type MissionsClaim200 = {
  awarded: boolean;
  missionId: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  rewardsAwarded?: MissionsClaim200RewardsAwardedItem[];
  reason?: string;
};

export type MissionsStatusParams = {
missionId: string;
userId?: string;
};

export type MissionsStatus200 = {
  missionId: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  claimed: boolean;
  claimKey: string;
  claimedAt?: string;
};

export type MissionsStatusesParams = {
userId?: string;
};

export type MissionsStatuses200StatusesItem = {
  missionId: string;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  claimed: boolean;
  claimKey: string;
  claimedAt?: string;
};

export type MissionsStatuses200 = {
  statuses: MissionsStatuses200StatusesItem[];
  completed: string[];
  claimed: string[];
};

export type BadgesList200Item = {
  id: string;
  imageUrl: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
  /** @minimum 0 */
  holders: number;
};

export type BadgesForUserParams = {
userId?: string;
};

export type BadgesForUser200ItemBadge = {
  id: string;
  imageUrl: string;
  /** @nullable */
  name?: string | null;
  /** @nullable */
  description?: string | null;
};

export type BadgesForUser200Item = {
  id: string;
  createdAt: string;
  badge: BadgesForUser200ItemBadge;
};

export type TelegramPackages200Item = {
  id: number;
  points: number;
  discountPct: number;
  stars: number;
};

export type TelegramCreateDeepLinkBody = {
  ref?: string;
};

export type TelegramCreateDeepLink200 = {
  deepLink: string;
  id: string;
  expiresIn: number;
};

export type TelegramCreateBuyDeepLinkBody = {
  packageId: number;
  ref?: string;
};

export type TelegramCreateBuyDeepLink200 = {
  deepLink: string;
  id: string;
  expiresIn: number;
};

export type TelegramCreateStarsInvoiceBody = {
  packageId: number;
};

export type TelegramCreateStarsInvoice200 = {
  invoiceLink: string;
  payload: string;
  stars: number;
  points: number;
};

export type TelegramWebAppLoginBody = {
  initData: string;
};

export type TelegramWebAppLogin200 = {
  token: string;
  userId: string;
};

export type TelegramCheckWebAppLinkParams = {
initData: string;
};

export type TelegramCheckWebAppLink200 = {
  linked: boolean;
};

/**
 * @nullable
 */
export type TelegramLinkStatus200Data = unknown | null;

export type TelegramLinkStatus200 = {
  linked: boolean;
  /** @nullable */
  data?: TelegramLinkStatus200Data;
};

export type TelegramCreateDeviceLoginBody = {
  ref?: string;
};

export type TelegramCreateDeviceLogin200 = {
  deepLink: string;
  id: string;
  expiresIn: number;
  clientNonce: string;
};

export type TelegramExchangeDeviceLoginBody = {
  id: string;
  clientNonce: string;
};

export type TelegramExchangeDeviceLogin200 = {
  token: string;
  userId: string;
};

export type TelegramConfirmDeviceLoginBody = {
  id: string;
  clientNonce: string;
  /** @pattern ^\d{6}$ */
  code: string;
};

export type TelegramConfirmDeviceLogin200 = {
  token: string;
  userId: string;
};

export type TelegramUnlinkBody = { [key: string]: unknown };

export type TelegramUnlink200 = {
  ok: boolean;
};

export type DiscountsValidateParams = {
code: string;
packageId: number;
};

/**
 * @nullable
 */
export type DiscountsValidate200Reason = typeof DiscountsValidate200Reason[keyof typeof DiscountsValidate200Reason] | null;


 
export const DiscountsValidate200Reason = {
  not_found: 'not_found',
  exhausted: 'exhausted',
} as const;

export type DiscountsValidate200Pricing = {
  packageId: number;
  baseUsd: number;
  finalUsd: number;
  packageDiscountPct: number;
  codeDiscountPct: number;
  points: number;
};

export type DiscountsValidate200 = {
  ok: boolean;
  /** @nullable */
  reason: DiscountsValidate200Reason;
  /** @nullable */
  code: string | null;
  discountPct: number;
  pricing: DiscountsValidate200Pricing;
};

export type DiscountsMyCodes200Item = {
  code: string;
  discount: number;
  createdAt: string;
  used: number;
  maximumUses: number;
  /** @nullable */
  linkedUserId: string | null;
  totalUsdSpent: number;
  totalUsdSaved: number;
  affiliatePaid: number;
  affiliatePayoutPending: number;
  active: boolean;
  remainingUses: number;
  uniqueUsers: number;
  /** @nullable */
  lastUsedAt: string | null;
};

export type CommentsCountParams = {
imageId?: string;
videoId?: string;
};

export type CommentsCount200 = {
  count: number;
};

export type CommentsListParams = {
imageId?: string;
videoId?: string;
limit?: number;
before?: string;
};

export type CommentsList200CommentsItemAuthor = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsList200CommentsItemMentionsItem = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsList200CommentsItem = {
  id: string;
  createdAt: string;
  updatedAt: string;
  content: string;
  userId: string;
  /** @nullable */
  imageId: string | null;
  /** @nullable */
  videoId: string | null;
  author: CommentsList200CommentsItemAuthor;
  mentions: CommentsList200CommentsItemMentionsItem[];
  edited: boolean;
};

export type CommentsList200 = {
  comments: CommentsList200CommentsItem[];
};

export type CommentsCreateBody = {
  imageId?: string;
  videoId?: string;
  /**
   * @minLength 1
   * @maxLength 500
   */
  content: string;
};

export type CommentsCreate200Author = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsCreate200MentionsItem = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsCreate200 = {
  id: string;
  createdAt: string;
  updatedAt: string;
  content: string;
  userId: string;
  /** @nullable */
  imageId: string | null;
  /** @nullable */
  videoId: string | null;
  author: CommentsCreate200Author;
  mentions: CommentsCreate200MentionsItem[];
  edited: boolean;
};

export type CommentsEditBody = {
  commentId: string;
  /**
   * @minLength 1
   * @maxLength 500
   */
  content: string;
};

export type CommentsEdit200Author = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsEdit200MentionsItem = {
  id: string;
  /** @nullable */
  username: string | null;
};

export type CommentsEdit200 = {
  id: string;
  createdAt: string;
  updatedAt: string;
  content: string;
  userId: string;
  /** @nullable */
  imageId: string | null;
  /** @nullable */
  videoId: string | null;
  author: CommentsEdit200Author;
  mentions: CommentsEdit200MentionsItem[];
  edited: boolean;
};

export type CommentsDeleteBody = {
  commentId: string;
};

export type CommentsDelete200 = {
  success: boolean;
};

export type TiktokCompleteRegistrationBody = {
  ttclid?: string;
  ttp?: string;
  userAgent?: string;
  eventId?: string;
  trackingId?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type TiktokCompleteRegistration200 = {
  ok: boolean;
};

export type MarketingAddToCartBodyContentsItem = {
  id: string;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  quantity?: number;
  item_price?: number;
  title?: string;
};

export type MarketingAddToCartBody = {
  /**
   * @minLength 3
   * @maxLength 3
   */
  currency: string;
  /** @minimum 0 */
  value: number;
  content_type?: string;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  num_items?: number;
  contents: MarketingAddToCartBodyContentsItem[];
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingAddToCart200 = {
  ok: boolean;
};

export type MarketingInitiateCheckoutBodyContentsItem = {
  id: string;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  quantity?: number;
  item_price?: number;
  title?: string;
};

export type MarketingInitiateCheckoutBody = {
  /**
   * @minLength 3
   * @maxLength 3
   */
  currency: string;
  /** @minimum 0 */
  value: number;
  content_type?: string;
  /**
   * @minimum 0
   * @exclusiveMinimum
   */
  num_items?: number;
  contents: MarketingInitiateCheckoutBodyContentsItem[];
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingInitiateCheckout200 = {
  ok: boolean;
};

export type MarketingCreateImageStartBody = {
  /** @minLength 1 */
  model: string;
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingCreateImageStart200 = {
  ok: boolean;
};

export type MarketingCreateImageSuccessBody = {
  /** @minLength 1 */
  model: string;
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingCreateImageSuccess200 = {
  ok: boolean;
};

export type MarketingCreateVideoStartBody = {
  /** @minLength 1 */
  model: string;
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingCreateVideoStart200 = {
  ok: boolean;
};

export type MarketingCreateVideoSuccessBody = {
  /** @minLength 1 */
  model: string;
  eventId?: string;
  userAgent?: string;
  fbp?: string;
  fbc?: string;
  eventSourceUrl?: string;
};

export type MarketingCreateVideoSuccess200 = {
  ok: boolean;
};

export const pkAuthRegisterStart = (
    pkAuthRegisterStartBody: MaybeRef<PkAuthRegisterStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterStartBody = unref(pkAuthRegisterStartBody);
    
    return axios.post(
      `/pkAuth/registerStart`,
      pkAuthRegisterStartBody,options
    );
  }



export const getPkAuthRegisterStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext> => {

const mutationKey = ['pkAuthRegisterStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterStart>>, {data: PkAuthRegisterStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterStart>>>
    export type PkAuthRegisterStartMutationBody = PkAuthRegisterStartBody
    export type PkAuthRegisterStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterStart>>,
        TError,
        {data: PkAuthRegisterStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthRegisterFinish = (
    pkAuthRegisterFinishBody: MaybeRef<PkAuthRegisterFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterFinishBody = unref(pkAuthRegisterFinishBody);
    
    return axios.post(
      `/pkAuth/registerFinish`,
      pkAuthRegisterFinishBody,options
    );
  }



export const getPkAuthRegisterFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext> => {

const mutationKey = ['pkAuthRegisterFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, {data: PkAuthRegisterFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterFinish>>>
    export type PkAuthRegisterFinishMutationBody = PkAuthRegisterFinishBody
    export type PkAuthRegisterFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterFinish>>,
        TError,
        {data: PkAuthRegisterFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginStart = (
    pkAuthLoginStartBody: MaybeRef<PkAuthLoginStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginStartBody = unref(pkAuthLoginStartBody);
    
    return axios.post(
      `/pkAuth/loginStart`,
      pkAuthLoginStartBody,options
    );
  }



export const getPkAuthLoginStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext> => {

const mutationKey = ['pkAuthLoginStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginStart>>, {data: PkAuthLoginStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginStart>>>
    export type PkAuthLoginStartMutationBody = PkAuthLoginStartBody
    export type PkAuthLoginStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginStart>>,
        TError,
        {data: PkAuthLoginStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginFinish = (
    pkAuthLoginFinishBody: MaybeRef<PkAuthLoginFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginFinishBody = unref(pkAuthLoginFinishBody);
    
    return axios.post(
      `/pkAuth/loginFinish`,
      pkAuthLoginFinishBody,options
    );
  }



export const getPkAuthLoginFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext> => {

const mutationKey = ['pkAuthLoginFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginFinish>>, {data: PkAuthLoginFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginFinish>>>
    export type PkAuthLoginFinishMutationBody = PkAuthLoginFinishBody
    export type PkAuthLoginFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginFinish>>,
        TError,
        {data: PkAuthLoginFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImage = (
    createImageBody: MaybeRef<CreateImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateImage200>> => {
    createImageBody = unref(createImageBody);
    
    return axios.post(
      `/create/image`,
      createImageBody,options
    );
  }



export const getCreateImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext> => {

const mutationKey = ['createImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImage>>, {data: CreateImageBody}> = (props) => {
          const {data} = props ?? {};

          return  createImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImageMutationResult = NonNullable<Awaited<ReturnType<typeof createImage>>>
    export type CreateImageMutationBody = CreateImageBody
    export type CreateImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImage>>,
        TError,
        {data: CreateImageBody},
        TContext
      > => {

      const mutationOptions = getCreateImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createVideo = (
    createVideoBody: MaybeRef<CreateVideoBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateVideo200>> => {
    createVideoBody = unref(createVideoBody);
    
    return axios.post(
      `/create/video`,
      createVideoBody,options
    );
  }



export const getCreateVideoMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext> => {

const mutationKey = ['createVideo'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVideo>>, {data: CreateVideoBody}> = (props) => {
          const {data} = props ?? {};

          return  createVideo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateVideoMutationResult = NonNullable<Awaited<ReturnType<typeof createVideo>>>
    export type CreateVideoMutationBody = CreateVideoBody
    export type CreateVideoMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateVideo = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createVideo>>,
        TError,
        {data: CreateVideoBody},
        TContext
      > => {

      const mutationOptions = getCreateVideoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createRandomPrompt = (
    createRandomPromptBody: MaybeRef<CreateRandomPromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createRandomPromptBody = unref(createRandomPromptBody);
    
    return axios.post(
      `/create/randomPrompt`,
      createRandomPromptBody,options
    );
  }



export const getCreateRandomPromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext> => {

const mutationKey = ['createRandomPrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRandomPrompt>>, {data: CreateRandomPromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createRandomPrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRandomPromptMutationResult = NonNullable<Awaited<ReturnType<typeof createRandomPrompt>>>
    export type CreateRandomPromptMutationBody = CreateRandomPromptBody
    export type CreateRandomPromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateRandomPrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createRandomPrompt>>,
        TError,
        {data: CreateRandomPromptBody},
        TContext
      > => {

      const mutationOptions = getCreateRandomPromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImprovePrompt = (
    createImprovePromptBody: MaybeRef<CreateImprovePromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createImprovePromptBody = unref(createImprovePromptBody);
    
    return axios.post(
      `/create/improvePrompt`,
      createImprovePromptBody,options
    );
  }



export const getCreateImprovePromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext> => {

const mutationKey = ['createImprovePrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImprovePrompt>>, {data: CreateImprovePromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createImprovePrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImprovePromptMutationResult = NonNullable<Awaited<ReturnType<typeof createImprovePrompt>>>
    export type CreateImprovePromptMutationBody = CreateImprovePromptBody
    export type CreateImprovePromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImprovePrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImprovePrompt>>,
        TError,
        {data: CreateImprovePromptBody},
        TContext
      > => {

      const mutationOptions = getCreateImprovePromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createUploadImage = (
    createUploadImageBody: MaybeRef<CreateUploadImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateUploadImage200>> => {
    createUploadImageBody = unref(createUploadImageBody);
    
    return axios.post(
      `/create/uploadImage`,
      createUploadImageBody,options
    );
  }



export const getCreateUploadImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUploadImage>>, TError,{data: CreateUploadImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createUploadImage>>, TError,{data: CreateUploadImageBody}, TContext> => {

const mutationKey = ['createUploadImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUploadImage>>, {data: CreateUploadImageBody}> = (props) => {
          const {data} = props ?? {};

          return  createUploadImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUploadImageMutationResult = NonNullable<Awaited<ReturnType<typeof createUploadImage>>>
    export type CreateUploadImageMutationBody = CreateUploadImageBody
    export type CreateUploadImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateUploadImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUploadImage>>, TError,{data: CreateUploadImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createUploadImage>>,
        TError,
        {data: CreateUploadImageBody},
        TContext
      > => {

      const mutationOptions = getCreateUploadImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createQueueAsyncBatch = (
    createQueueAsyncBatchBody: MaybeRef<CreateQueueAsyncBatchBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateQueueAsyncBatch200>> => {
    createQueueAsyncBatchBody = unref(createQueueAsyncBatchBody);
    
    return axios.post(
      `/create/queueAsyncBatch`,
      createQueueAsyncBatchBody,options
    );
  }



export const getCreateQueueAsyncBatchMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQueueAsyncBatch>>, TError,{data: CreateQueueAsyncBatchBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createQueueAsyncBatch>>, TError,{data: CreateQueueAsyncBatchBody}, TContext> => {

const mutationKey = ['createQueueAsyncBatch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createQueueAsyncBatch>>, {data: CreateQueueAsyncBatchBody}> = (props) => {
          const {data} = props ?? {};

          return  createQueueAsyncBatch(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateQueueAsyncBatchMutationResult = NonNullable<Awaited<ReturnType<typeof createQueueAsyncBatch>>>
    export type CreateQueueAsyncBatchMutationBody = CreateQueueAsyncBatchBody
    export type CreateQueueAsyncBatchMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateQueueAsyncBatch = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createQueueAsyncBatch>>, TError,{data: CreateQueueAsyncBatchBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createQueueAsyncBatch>>,
        TError,
        {data: CreateQueueAsyncBatchBody},
        TContext
      > => {

      const mutationOptions = getCreateQueueAsyncBatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createBatchStatus = (
    params: MaybeRef<CreateBatchStatusParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateBatchStatus200>> => {
    params = unref(params);
    
    return axios.get(
      `/create/batchStatus`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreateBatchStatusQueryKey = (params: MaybeRef<CreateBatchStatusParams>,) => {
    return ['create','batchStatus', ...(params ? [params]: [])] as const;
    }

    
export const getCreateBatchStatusQueryOptions = <TData = Awaited<ReturnType<typeof createBatchStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreateBatchStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof createBatchStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreateBatchStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof createBatchStatus>>> = ({ signal }) => createBatchStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof createBatchStatus>>, TError, TData> 
}

export type CreateBatchStatusQueryResult = NonNullable<Awaited<ReturnType<typeof createBatchStatus>>>
export type CreateBatchStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreateBatchStatus<TData = Awaited<ReturnType<typeof createBatchStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreateBatchStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof createBatchStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreateBatchStatusQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetCreationData = (
    params?: MaybeRef<CreationsGetCreationDataParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetCreationData200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getCreationData`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetCreationDataQueryKey = (params?: MaybeRef<CreationsGetCreationDataParams>,) => {
    return ['creations','getCreationData', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetCreationDataQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetCreationData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsGetCreationDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetCreationDataQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetCreationData>>> = ({ signal }) => creationsGetCreationData(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData> 
}

export type CreationsGetCreationDataQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetCreationData>>>
export type CreationsGetCreationDataQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetCreationData<TData = Awaited<ReturnType<typeof creationsGetCreationData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsGetCreationDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetCreationDataQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUserImagePurchases = (
    params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsUserImagePurchases200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/userImagePurchases`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUserImagePurchasesQueryKey = (params?: MaybeRef<CreationsUserImagePurchasesParams>,) => {
    return ['creations','userImagePurchases', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUserImagePurchasesQueryOptions = <TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUserImagePurchasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUserImagePurchases>>> = ({ signal }) => creationsUserImagePurchases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData> 
}

export type CreationsUserImagePurchasesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUserImagePurchases>>>
export type CreationsUserImagePurchasesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUserImagePurchases<TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUserImagePurchasesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUserVideoPurchases = (
    params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsUserVideoPurchases200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/userVideoPurchases`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUserVideoPurchasesQueryKey = (params?: MaybeRef<CreationsUserVideoPurchasesParams>,) => {
    return ['creations','userVideoPurchases', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUserVideoPurchasesQueryOptions = <TData = Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUserVideoPurchasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUserVideoPurchases>>> = ({ signal }) => creationsUserVideoPurchases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData> 
}

export type CreationsUserVideoPurchasesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUserVideoPurchases>>>
export type CreationsUserVideoPurchasesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUserVideoPurchases<TData = Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUserVideoPurchasesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateImageRequests = (
    params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateImageRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createImageRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateImageRequestsQueryKey = (params?: MaybeRef<CreationsCreateImageRequestsParams>,) => {
    return ['creations','createImageRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateImageRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateImageRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateImageRequests>>> = ({ signal }) => creationsCreateImageRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData> 
}

export type CreationsCreateImageRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateImageRequests>>>
export type CreationsCreateImageRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateImageRequests<TData = Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateImageRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateVideoRequests = (
    params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateVideoRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createVideoRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateVideoRequestsQueryKey = (params?: MaybeRef<CreationsCreateVideoRequestsParams>,) => {
    return ['creations','createVideoRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateVideoRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateVideoRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateVideoRequests>>> = ({ signal }) => creationsCreateVideoRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData> 
}

export type CreationsCreateVideoRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateVideoRequests>>>
export type CreationsCreateVideoRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateVideoRequests<TData = Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateVideoRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetMediaRequests = (
    params?: MaybeRef<CreationsGetMediaRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetMediaRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getMediaRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetMediaRequestsQueryKey = (params?: MaybeRef<CreationsGetMediaRequestsParams>,) => {
    return ['creations','getMediaRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetMediaRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetMediaRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsGetMediaRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetMediaRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetMediaRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetMediaRequests>>> = ({ signal }) => creationsGetMediaRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetMediaRequests>>, TError, TData> 
}

export type CreationsGetMediaRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetMediaRequests>>>
export type CreationsGetMediaRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetMediaRequests<TData = Awaited<ReturnType<typeof creationsGetMediaRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsGetMediaRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetMediaRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetMediaRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetImageRequest = (
    params: MaybeRef<CreationsGetImageRequestParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetImageRequest200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getImageRequest`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetImageRequestQueryKey = (params: MaybeRef<CreationsGetImageRequestParams>,) => {
    return ['creations','getImageRequest', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetImageRequestQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetImageRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsGetImageRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetImageRequestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetImageRequest>>> = ({ signal }) => creationsGetImageRequest(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData> 
}

export type CreationsGetImageRequestQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetImageRequest>>>
export type CreationsGetImageRequestQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetImageRequest<TData = Awaited<ReturnType<typeof creationsGetImageRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsGetImageRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetImageRequestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetVideoRequest = (
    params: MaybeRef<CreationsGetVideoRequestParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetVideoRequest200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getVideoRequest`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetVideoRequestQueryKey = (params: MaybeRef<CreationsGetVideoRequestParams>,) => {
    return ['creations','getVideoRequest', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetVideoRequestQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsGetVideoRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetVideoRequestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetVideoRequest>>> = ({ signal }) => creationsGetVideoRequest(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData> 
}

export type CreationsGetVideoRequestQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetVideoRequest>>>
export type CreationsGetVideoRequestQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetVideoRequest<TData = Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsGetVideoRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetVideoRequestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsBrowseCreateRequests = (
    params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsBrowseCreateRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/browseCreateRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsBrowseCreateRequestsQueryKey = (params: MaybeRef<CreationsBrowseCreateRequestsParams>,) => {
    return ['creations','browseCreateRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsBrowseCreateRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsBrowseCreateRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>> = ({ signal }) => creationsBrowseCreateRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData> 
}

export type CreationsBrowseCreateRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>>
export type CreationsBrowseCreateRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsBrowseCreateRequests<TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsBrowseCreateRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsHdImage = (
    params: MaybeRef<CreationsHdImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/hdImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsHdImageQueryKey = (params: MaybeRef<CreationsHdImageParams>,) => {
    return ['creations','hdImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsHdImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsHdImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsHdImage>>> = ({ signal }) => creationsHdImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData> 
}

export type CreationsHdImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsHdImage>>>
export type CreationsHdImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsHdImage<TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsHdImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsHdVideo = (
    params: MaybeRef<CreationsHdVideoParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/hdVideo`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsHdVideoQueryKey = (params: MaybeRef<CreationsHdVideoParams>,) => {
    return ['creations','hdVideo', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsHdVideoQueryOptions = <TData = Awaited<ReturnType<typeof creationsHdVideo>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsHdVideoParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsHdVideoQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsHdVideo>>> = ({ signal }) => creationsHdVideo(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData> 
}

export type CreationsHdVideoQueryResult = NonNullable<Awaited<ReturnType<typeof creationsHdVideo>>>
export type CreationsHdVideoQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsHdVideo<TData = Awaited<ReturnType<typeof creationsHdVideo>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsHdVideoParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsHdVideoQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsImageSecret = (
    params: MaybeRef<CreationsImageSecretParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/imageSecret`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsImageSecretQueryKey = (params: MaybeRef<CreationsImageSecretParams>,) => {
    return ['creations','imageSecret', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsImageSecretQueryOptions = <TData = Awaited<ReturnType<typeof creationsImageSecret>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsImageSecretParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsImageSecret>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsImageSecretQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsImageSecret>>> = ({ signal }) => creationsImageSecret(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsImageSecret>>, TError, TData> 
}

export type CreationsImageSecretQueryResult = NonNullable<Awaited<ReturnType<typeof creationsImageSecret>>>
export type CreationsImageSecretQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsImageSecret<TData = Awaited<ReturnType<typeof creationsImageSecret>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsImageSecretParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsImageSecret>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsImageSecretQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsOriginalImage = (
    params: MaybeRef<CreationsOriginalImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/originalImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsOriginalImageQueryKey = (params: MaybeRef<CreationsOriginalImageParams>,) => {
    return ['creations','originalImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsOriginalImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsOriginalImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsOriginalImage>>> = ({ signal }) => creationsOriginalImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData> 
}

export type CreationsOriginalImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsOriginalImage>>>
export type CreationsOriginalImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsOriginalImage<TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsOriginalImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUpscaledImage = (
    params: MaybeRef<CreationsUpscaledImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/upscaledImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUpscaledImageQueryKey = (params: MaybeRef<CreationsUpscaledImageParams>,) => {
    return ['creations','upscaledImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUpscaledImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUpscaledImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUpscaledImage>>> = ({ signal }) => creationsUpscaledImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData> 
}

export type CreationsUpscaledImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUpscaledImage>>>
export type CreationsUpscaledImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUpscaledImage<TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUpscaledImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsPurchaseMedia = (
    creationsPurchaseMediaBody: MaybeRef<CreationsPurchaseMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsPurchaseMediaBody = unref(creationsPurchaseMediaBody);
    
    return axios.post(
      `/creations/purchaseMedia`,
      creationsPurchaseMediaBody,options
    );
  }



export const getCreationsPurchaseMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext> => {

const mutationKey = ['creationsPurchaseMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsPurchaseMedia>>, {data: CreationsPurchaseMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsPurchaseMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsPurchaseMediaMutationResult = NonNullable<Awaited<ReturnType<typeof creationsPurchaseMedia>>>
    export type CreationsPurchaseMediaMutationBody = CreationsPurchaseMediaBody
    export type CreationsPurchaseMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsPurchaseMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsPurchaseMedia>>,
        TError,
        {data: CreationsPurchaseMediaBody},
        TContext
      > => {

      const mutationOptions = getCreationsPurchaseMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsPublishMedia = (
    creationsPublishMediaBody: MaybeRef<CreationsPublishMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsPublishMedia200>> => {
    creationsPublishMediaBody = unref(creationsPublishMediaBody);
    
    return axios.post(
      `/creations/publishMedia`,
      creationsPublishMediaBody,options
    );
  }



export const getCreationsPublishMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPublishMedia>>, TError,{data: CreationsPublishMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsPublishMedia>>, TError,{data: CreationsPublishMediaBody}, TContext> => {

const mutationKey = ['creationsPublishMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsPublishMedia>>, {data: CreationsPublishMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsPublishMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsPublishMediaMutationResult = NonNullable<Awaited<ReturnType<typeof creationsPublishMedia>>>
    export type CreationsPublishMediaMutationBody = CreationsPublishMediaBody
    export type CreationsPublishMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsPublishMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPublishMedia>>, TError,{data: CreationsPublishMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsPublishMedia>>,
        TError,
        {data: CreationsPublishMediaBody},
        TContext
      > => {

      const mutationOptions = getCreationsPublishMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteMedia = (
    creationsDeleteMediaBody: MaybeRef<CreationsDeleteMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsDeleteMediaBody = unref(creationsDeleteMediaBody);
    
    return axios.post(
      `/creations/deleteMedia`,
      creationsDeleteMediaBody,options
    );
  }



export const getCreationsDeleteMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext> => {

const mutationKey = ['creationsDeleteMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteMedia>>, {data: CreationsDeleteMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteMediaMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteMedia>>>
    export type CreationsDeleteMediaMutationBody = CreationsDeleteMediaBody
    export type CreationsDeleteMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteMedia>>,
        TError,
        {data: CreationsDeleteMediaBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteRequest = (
    creationsDeleteRequestBody: MaybeRef<CreationsDeleteRequestBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsDeleteRequestBody = unref(creationsDeleteRequestBody);
    
    return axios.post(
      `/creations/deleteRequest`,
      creationsDeleteRequestBody,options
    );
  }



export const getCreationsDeleteRequestMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext> => {

const mutationKey = ['creationsDeleteRequest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteRequest>>, {data: CreationsDeleteRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteRequest(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteRequestMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteRequest>>>
    export type CreationsDeleteRequestMutationBody = CreationsDeleteRequestBody
    export type CreationsDeleteRequestMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteRequest = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteRequest>>,
        TError,
        {data: CreationsDeleteRequestBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsSetRequestPrivacy = (
    creationsSetRequestPrivacyBody: MaybeRef<CreationsSetRequestPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsSetRequestPrivacyBody = unref(creationsSetRequestPrivacyBody);
    
    return axios.post(
      `/creations/setRequestPrivacy`,
      creationsSetRequestPrivacyBody,options
    );
  }



export const getCreationsSetRequestPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext> => {

const mutationKey = ['creationsSetRequestPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, {data: CreationsSetRequestPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsSetRequestPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsSetRequestPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>>
    export type CreationsSetRequestPrivacyMutationBody = CreationsSetRequestPrivacyBody
    export type CreationsSetRequestPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsSetRequestPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsSetRequestPrivacy>>,
        TError,
        {data: CreationsSetRequestPrivacyBody},
        TContext
      > => {

      const mutationOptions = getCreationsSetRequestPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsGetUserUploadedImages = (
    params?: MaybeRef<CreationsGetUserUploadedImagesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getUserUploadedImages`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetUserUploadedImagesQueryKey = (params?: MaybeRef<CreationsGetUserUploadedImagesParams>,) => {
    return ['creations','getUserUploadedImages', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetUserUploadedImagesQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetUserUploadedImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsGetUserUploadedImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetUserUploadedImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetUserUploadedImagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetUserUploadedImages>>> = ({ signal }) => creationsGetUserUploadedImages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetUserUploadedImages>>, TError, TData> 
}

export type CreationsGetUserUploadedImagesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetUserUploadedImages>>>
export type CreationsGetUserUploadedImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetUserUploadedImages<TData = Awaited<ReturnType<typeof creationsGetUserUploadedImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsGetUserUploadedImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetUserUploadedImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetUserUploadedImagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsDeleteUploadedImage = (
    creationsDeleteUploadedImageBody: MaybeRef<CreationsDeleteUploadedImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsDeleteUploadedImageBody = unref(creationsDeleteUploadedImageBody);
    
    return axios.post(
      `/creations/deleteUploadedImage`,
      creationsDeleteUploadedImageBody,options
    );
  }



export const getCreationsDeleteUploadedImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteUploadedImage>>, TError,{data: CreationsDeleteUploadedImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteUploadedImage>>, TError,{data: CreationsDeleteUploadedImageBody}, TContext> => {

const mutationKey = ['creationsDeleteUploadedImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteUploadedImage>>, {data: CreationsDeleteUploadedImageBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteUploadedImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteUploadedImageMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteUploadedImage>>>
    export type CreationsDeleteUploadedImageMutationBody = CreationsDeleteUploadedImageBody
    export type CreationsDeleteUploadedImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteUploadedImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteUploadedImage>>, TError,{data: CreationsDeleteUploadedImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteUploadedImage>>,
        TError,
        {data: CreationsDeleteUploadedImageBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteUploadedImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDescribeUploadedImage = (
    params: MaybeRef<CreationsDescribeUploadedImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsDescribeUploadedImage200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/describeUploadedImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsDescribeUploadedImageQueryKey = (params: MaybeRef<CreationsDescribeUploadedImageParams>,) => {
    return ['creations','describeUploadedImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsDescribeUploadedImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsDescribeUploadedImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsDescribeUploadedImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsDescribeUploadedImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsDescribeUploadedImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsDescribeUploadedImage>>> = ({ signal }) => creationsDescribeUploadedImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsDescribeUploadedImage>>, TError, TData> 
}

export type CreationsDescribeUploadedImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsDescribeUploadedImage>>>
export type CreationsDescribeUploadedImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsDescribeUploadedImage<TData = Awaited<ReturnType<typeof creationsDescribeUploadedImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsDescribeUploadedImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsDescribeUploadedImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsDescribeUploadedImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsPackagesAvailable = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPackagesAvailable200Item[]>> => {
    
    
    return axios.get(
      `/points/packagesAvailable`,options
    );
  }


export const getPointsPackagesAvailableQueryKey = () => {
    return ['points','packagesAvailable'] as const;
    }

    
export const getPointsPackagesAvailableQueryOptions = <TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPackagesAvailableQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPackagesAvailable>>> = ({ signal }) => pointsPackagesAvailable({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData> 
}

export type PointsPackagesAvailableQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPackagesAvailable>>>
export type PointsPackagesAvailableQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPackagesAvailable<TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPackagesAvailableQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPrices200>> => {
    
    
    return axios.get(
      `/points/prices`,options
    );
  }


export const getPointsPricesQueryKey = () => {
    return ['points','prices'] as const;
    }

    
export const getPointsPricesQueryOptions = <TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPricesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPrices>>> = ({ signal }) => pointsPrices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData> 
}

export type PointsPricesQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPrices>>>
export type PointsPricesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPrices<TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPricesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsInitBuyPackage = (
    pointsInitBuyPackageBody: MaybeRef<PointsInitBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsInitBuyPackage200>> => {
    pointsInitBuyPackageBody = unref(pointsInitBuyPackageBody);
    
    return axios.post(
      `/points/initBuyPackage`,
      pointsInitBuyPackageBody,options
    );
  }



export const getPointsInitBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext> => {

const mutationKey = ['pointsInitBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsInitBuyPackage>>, {data: PointsInitBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsInitBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsInitBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsInitBuyPackage>>>
    export type PointsInitBuyPackageMutationBody = PointsInitBuyPackageBody
    export type PointsInitBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsInitBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsInitBuyPackage>>,
        TError,
        {data: PointsInitBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsInitBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsFinishBuyPackage = (
    pointsFinishBuyPackageBody: MaybeRef<PointsFinishBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsFinishBuyPackage200>> => {
    pointsFinishBuyPackageBody = unref(pointsFinishBuyPackageBody);
    
    return axios.post(
      `/points/finishBuyPackage`,
      pointsFinishBuyPackageBody,options
    );
  }



export const getPointsFinishBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext> => {

const mutationKey = ['pointsFinishBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, {data: PointsFinishBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsFinishBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsFinishBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsFinishBuyPackage>>>
    export type PointsFinishBuyPackageMutationBody = PointsFinishBuyPackageBody
    export type PointsFinishBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsFinishBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsFinishBuyPackage>>,
        TError,
        {data: PointsFinishBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsFinishBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsGetOrders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrders200>> => {
    
    
    return axios.get(
      `/points/getOrders`,options
    );
  }


export const getPointsGetOrdersQueryKey = () => {
    return ['points','getOrders'] as const;
    }

    
export const getPointsGetOrdersQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrders>>> = ({ signal }) => pointsGetOrders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData> 
}

export type PointsGetOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrders>>>
export type PointsGetOrdersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrders<TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsGetOrder = (
    params: MaybeRef<PointsGetOrderParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrder200>> => {
    params = unref(params);
    
    return axios.get(
      `/points/getOrder`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPointsGetOrderQueryKey = (params: MaybeRef<PointsGetOrderParams>,) => {
    return ['points','getOrder', ...(params ? [params]: [])] as const;
    }

    
export const getPointsGetOrderQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrder>>> = ({ signal }) => pointsGetOrder(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData> 
}

export type PointsGetOrderQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrder>>>
export type PointsGetOrderQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrder<TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrderQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGet = (
    params: MaybeRef<UserGetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGet200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/get`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetQueryKey = (params: MaybeRef<UserGetParams>,) => {
    return ['user','get', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetQueryOptions = <TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGet>>> = ({ signal }) => userGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData> 
}

export type UserGetQueryResult = NonNullable<Awaited<ReturnType<typeof userGet>>>
export type UserGetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGet<TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetAffiliatePayoutDetails = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGetAffiliatePayoutDetails200>> => {
    
    
    return axios.get(
      `/user/getAffiliatePayoutDetails`,options
    );
  }


export const getUserGetAffiliatePayoutDetailsQueryKey = () => {
    return ['user','getAffiliatePayoutDetails'] as const;
    }

    
export const getUserGetAffiliatePayoutDetailsQueryOptions = <TData = Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetAffiliatePayoutDetailsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>> = ({ signal }) => userGetAffiliatePayoutDetails({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>, TError, TData> 
}

export type UserGetAffiliatePayoutDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>>
export type UserGetAffiliatePayoutDetailsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetAffiliatePayoutDetails<TData = Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetAffiliatePayoutDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetAffiliatePayoutDetailsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetAffiliatePayoutDetails = (
    userSetAffiliatePayoutDetailsBody: MaybeRef<UserSetAffiliatePayoutDetailsBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetAffiliatePayoutDetails200>> => {
    userSetAffiliatePayoutDetailsBody = unref(userSetAffiliatePayoutDetailsBody);
    
    return axios.post(
      `/user/setAffiliatePayoutDetails`,
      userSetAffiliatePayoutDetailsBody,options
    );
  }



export const getUserSetAffiliatePayoutDetailsMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>, TError,{data: UserSetAffiliatePayoutDetailsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>, TError,{data: UserSetAffiliatePayoutDetailsBody}, TContext> => {

const mutationKey = ['userSetAffiliatePayoutDetails'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>, {data: UserSetAffiliatePayoutDetailsBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetAffiliatePayoutDetails(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetAffiliatePayoutDetailsMutationResult = NonNullable<Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>>
    export type UserSetAffiliatePayoutDetailsMutationBody = UserSetAffiliatePayoutDetailsBody
    export type UserSetAffiliatePayoutDetailsMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetAffiliatePayoutDetails = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>, TError,{data: UserSetAffiliatePayoutDetailsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetAffiliatePayoutDetails>>,
        TError,
        {data: UserSetAffiliatePayoutDetailsBody},
        TContext
      > => {

      const mutationOptions = getUserSetAffiliatePayoutDetailsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userAffiliatePayoutReceipts = (
    params?: MaybeRef<UserAffiliatePayoutReceiptsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAffiliatePayoutReceipts200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/user/affiliatePayoutReceipts`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserAffiliatePayoutReceiptsQueryKey = (params?: MaybeRef<UserAffiliatePayoutReceiptsParams>,) => {
    return ['user','affiliatePayoutReceipts', ...(params ? [params]: [])] as const;
    }

    
export const getUserAffiliatePayoutReceiptsQueryOptions = <TData = Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UserAffiliatePayoutReceiptsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserAffiliatePayoutReceiptsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>> = ({ signal }) => userAffiliatePayoutReceipts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>, TError, TData> 
}

export type UserAffiliatePayoutReceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>>
export type UserAffiliatePayoutReceiptsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserAffiliatePayoutReceipts<TData = Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UserAffiliatePayoutReceiptsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAffiliatePayoutReceipts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserAffiliatePayoutReceiptsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userProfile = (
    params: MaybeRef<UserProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/profile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserProfileQueryKey = (params: MaybeRef<UserProfileParams>,) => {
    return ['user','profile', ...(params ? [params]: [])] as const;
    }

    
export const getUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userProfile>>> = ({ signal }) => userProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData> 
}

export type UserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userProfile>>>
export type UserProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserProfile<TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userPublicProfile = (
    params: MaybeRef<UserPublicProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPublicProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/publicProfile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPublicProfileQueryKey = (params: MaybeRef<UserPublicProfileParams>,) => {
    return ['user','publicProfile', ...(params ? [params]: [])] as const;
    }

    
export const getUserPublicProfileQueryOptions = <TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPublicProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPublicProfile>>> = ({ signal }) => userPublicProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData> 
}

export type UserPublicProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userPublicProfile>>>
export type UserPublicProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPublicProfile<TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPublicProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetUsername = (
    params: MaybeRef<UserGetUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/getUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetUsernameQueryKey = (params: MaybeRef<UserGetUsernameParams>,) => {
    return ['user','getUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsername>>> = ({ signal }) => userGetUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData> 
}

export type UserGetUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userGetUsername>>>
export type UserGetUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetUsername<TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetUsername = (
    userSetUsernameBody: MaybeRef<UserSetUsernameBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetUsername200>> => {
    userSetUsernameBody = unref(userSetUsernameBody);
    
    return axios.post(
      `/user/setUsername`,
      userSetUsernameBody,options
    );
  }



export const getUserSetUsernameMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext> => {

const mutationKey = ['userSetUsername'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetUsername>>, {data: UserSetUsernameBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetUsername(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetUsernameMutationResult = NonNullable<Awaited<ReturnType<typeof userSetUsername>>>
    export type UserSetUsernameMutationBody = UserSetUsernameBody
    export type UserSetUsernameMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetUsername = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetUsername>>,
        TError,
        {data: UserSetUsernameBody},
        TContext
      > => {

      const mutationOptions = getUserSetUsernameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetBio = (
    userSetBioBody: MaybeRef<UserSetBioBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetBio200>> => {
    userSetBioBody = unref(userSetBioBody);
    
    return axios.post(
      `/user/setBio`,
      userSetBioBody,options
    );
  }



export const getUserSetBioMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext> => {

const mutationKey = ['userSetBio'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetBio>>, {data: UserSetBioBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetBio(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetBioMutationResult = NonNullable<Awaited<ReturnType<typeof userSetBio>>>
    export type UserSetBioMutationBody = UserSetBioBody
    export type UserSetBioMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetBio = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetBio>>,
        TError,
        {data: UserSetBioBody},
        TContext
      > => {

      const mutationOptions = getUserSetBioMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSendVerificationEmail = (
    userSendVerificationEmailBody: MaybeRef<UserSendVerificationEmailBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSendVerificationEmailBody = unref(userSendVerificationEmailBody);
    
    return axios.post(
      `/user/sendVerificationEmail`,
      userSendVerificationEmailBody,options
    );
  }



export const getUserSendVerificationEmailMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext> => {

const mutationKey = ['userSendVerificationEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSendVerificationEmail>>, {data: UserSendVerificationEmailBody}> = (props) => {
          const {data} = props ?? {};

          return  userSendVerificationEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSendVerificationEmailMutationResult = NonNullable<Awaited<ReturnType<typeof userSendVerificationEmail>>>
    export type UserSendVerificationEmailMutationBody = UserSendVerificationEmailBody
    export type UserSendVerificationEmailMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSendVerificationEmail = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSendVerificationEmail>>,
        TError,
        {data: UserSendVerificationEmailBody},
        TContext
      > => {

      const mutationOptions = getUserSendVerificationEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userVerifyEmailToken = (
    userVerifyEmailTokenBody: MaybeRef<UserVerifyEmailTokenBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserVerifyEmailToken200>> => {
    userVerifyEmailTokenBody = unref(userVerifyEmailTokenBody);
    
    return axios.post(
      `/user/verifyEmailToken`,
      userVerifyEmailTokenBody,options
    );
  }



export const getUserVerifyEmailTokenMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userVerifyEmailToken>>, TError,{data: UserVerifyEmailTokenBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userVerifyEmailToken>>, TError,{data: UserVerifyEmailTokenBody}, TContext> => {

const mutationKey = ['userVerifyEmailToken'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userVerifyEmailToken>>, {data: UserVerifyEmailTokenBody}> = (props) => {
          const {data} = props ?? {};

          return  userVerifyEmailToken(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserVerifyEmailTokenMutationResult = NonNullable<Awaited<ReturnType<typeof userVerifyEmailToken>>>
    export type UserVerifyEmailTokenMutationBody = UserVerifyEmailTokenBody
    export type UserVerifyEmailTokenMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserVerifyEmailToken = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userVerifyEmailToken>>, TError,{data: UserVerifyEmailTokenBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userVerifyEmailToken>>,
        TError,
        {data: UserVerifyEmailTokenBody},
        TContext
      > => {

      const mutationOptions = getUserVerifyEmailTokenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userPointsHistory = (
    params?: MaybeRef<UserPointsHistoryParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPointsHistory200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/user/pointsHistory`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPointsHistoryQueryKey = (params?: MaybeRef<UserPointsHistoryParams>,) => {
    return ['user','pointsHistory', ...(params ? [params]: [])] as const;
    }

    
export const getUserPointsHistoryQueryOptions = <TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPointsHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPointsHistory>>> = ({ signal }) => userPointsHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData> 
}

export type UserPointsHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof userPointsHistory>>>
export type UserPointsHistoryQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPointsHistory<TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPointsHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userReferralsSummary = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserReferralsSummary200>> => {
    
    
    return axios.get(
      `/user/referralsSummary`,options
    );
  }


export const getUserReferralsSummaryQueryKey = () => {
    return ['user','referralsSummary'] as const;
    }

    
export const getUserReferralsSummaryQueryOptions = <TData = Awaited<ReturnType<typeof userReferralsSummary>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userReferralsSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserReferralsSummaryQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userReferralsSummary>>> = ({ signal }) => userReferralsSummary({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userReferralsSummary>>, TError, TData> 
}

export type UserReferralsSummaryQueryResult = NonNullable<Awaited<ReturnType<typeof userReferralsSummary>>>
export type UserReferralsSummaryQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserReferralsSummary<TData = Awaited<ReturnType<typeof userReferralsSummary>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userReferralsSummary>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserReferralsSummaryQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByUsername = (
    params: MaybeRef<UserFindByUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByUsernameQueryKey = (params: MaybeRef<UserFindByUsernameParams>,) => {
    return ['user','findByUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByUsername>>> = ({ signal }) => userFindByUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData> 
}

export type UserFindByUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByUsername>>>
export type UserFindByUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByUsername<TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByEmail = (
    params: MaybeRef<UserFindByEmailParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByEmail`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByEmailQueryKey = (params: MaybeRef<UserFindByEmailParams>,) => {
    return ['user','findByEmail', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByEmailQueryOptions = <TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByEmail>>> = ({ signal }) => userFindByEmail(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData> 
}

export type UserFindByEmailQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByEmail>>>
export type UserFindByEmailQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByEmail<TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByEmailQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPhone = (
    params: MaybeRef<UserFindByPhoneParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPhone`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPhoneQueryKey = (params: MaybeRef<UserFindByPhoneParams>,) => {
    return ['user','findByPhone', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPhoneQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPhoneQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPhone>>> = ({ signal }) => userFindByPhone(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData> 
}

export type UserFindByPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPhone>>>
export type UserFindByPhoneQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPhone<TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPhoneQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPrivyId = (
    params: MaybeRef<UserFindByPrivyIdParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPrivyId`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPrivyIdQueryKey = (params: MaybeRef<UserFindByPrivyIdParams>,) => {
    return ['user','findByPrivyId', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPrivyIdQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPrivyIdQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPrivyId>>> = ({ signal }) => userFindByPrivyId(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData> 
}

export type UserFindByPrivyIdQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPrivyId>>>
export type UserFindByPrivyIdQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPrivyId<TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPrivyIdQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetNotificationConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGetNotificationConfig200>> => {
    
    
    return axios.get(
      `/user/getNotificationConfig`,options
    );
  }


export const getUserGetNotificationConfigQueryKey = () => {
    return ['user','getNotificationConfig'] as const;
    }

    
export const getUserGetNotificationConfigQueryOptions = <TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetNotificationConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetNotificationConfig>>> = ({ signal }) => userGetNotificationConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData> 
}

export type UserGetNotificationConfigQueryResult = NonNullable<Awaited<ReturnType<typeof userGetNotificationConfig>>>
export type UserGetNotificationConfigQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetNotificationConfig<TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetNotificationConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetNotificationConfig = (
    userSetNotificationConfigBody: MaybeRef<UserSetNotificationConfigBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetNotificationConfig200>> => {
    userSetNotificationConfigBody = unref(userSetNotificationConfigBody);
    
    return axios.post(
      `/user/setNotificationConfig`,
      userSetNotificationConfigBody,options
    );
  }



export const getUserSetNotificationConfigMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext> => {

const mutationKey = ['userSetNotificationConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetNotificationConfig>>, {data: UserSetNotificationConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetNotificationConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetNotificationConfigMutationResult = NonNullable<Awaited<ReturnType<typeof userSetNotificationConfig>>>
    export type UserSetNotificationConfigMutationBody = UserSetNotificationConfigBody
    export type UserSetNotificationConfigMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetNotificationConfig = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetNotificationConfig>>,
        TError,
        {data: UserSetNotificationConfigBody},
        TContext
      > => {

      const mutationOptions = getUserSetNotificationConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userUnsubscribeEmailNotifications = (
    userUnsubscribeEmailNotificationsBody: MaybeRef<UserUnsubscribeEmailNotificationsBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    userUnsubscribeEmailNotificationsBody = unref(userUnsubscribeEmailNotificationsBody);
    
    return axios.post(
      `/user/unsubscribeEmailNotifications`,
      userUnsubscribeEmailNotificationsBody,options
    );
  }



export const getUserUnsubscribeEmailNotificationsMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext> => {

const mutationKey = ['userUnsubscribeEmailNotifications'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, {data: UserUnsubscribeEmailNotificationsBody}> = (props) => {
          const {data} = props ?? {};

          return  userUnsubscribeEmailNotifications(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserUnsubscribeEmailNotificationsMutationResult = NonNullable<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>>
    export type UserUnsubscribeEmailNotificationsMutationBody = UserUnsubscribeEmailNotificationsBody
    export type UserUnsubscribeEmailNotificationsMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserUnsubscribeEmailNotifications = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>,
        TError,
        {data: UserUnsubscribeEmailNotificationsBody},
        TContext
      > => {

      const mutationOptions = getUserUnsubscribeEmailNotificationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetAvatar = (
    userSetAvatarBody: MaybeRef<UserSetAvatarBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSetAvatarBody = unref(userSetAvatarBody);
    
    return axios.post(
      `/user/setAvatar`,
      userSetAvatarBody,options
    );
  }



export const getUserSetAvatarMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext> => {

const mutationKey = ['userSetAvatar'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetAvatar>>, {data: UserSetAvatarBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetAvatar(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetAvatarMutationResult = NonNullable<Awaited<ReturnType<typeof userSetAvatar>>>
    export type UserSetAvatarMutationBody = UserSetAvatarBody
    export type UserSetAvatarMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetAvatar = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetAvatar>>,
        TError,
        {data: UserSetAvatarBody},
        TContext
      > => {

      const mutationOptions = getUserSetAvatarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userAllUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAllUsers200Item[]>> => {
    
    
    return axios.get(
      `/user/allUsers`,options
    );
  }


export const getUserAllUsersQueryKey = () => {
    return ['user','allUsers'] as const;
    }

    
export const getUserAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userAllUsers>>> = ({ signal }) => userAllUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData> 
}

export type UserAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof userAllUsers>>>
export type UserAllUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserAllUsers<TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserAllUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userAuthConnections = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAuthConnections200>> => {
    
    
    return axios.get(
      `/user/authConnections`,options
    );
  }


export const getUserAuthConnectionsQueryKey = () => {
    return ['user','authConnections'] as const;
    }

    
export const getUserAuthConnectionsQueryOptions = <TData = Awaited<ReturnType<typeof userAuthConnections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAuthConnections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserAuthConnectionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userAuthConnections>>> = ({ signal }) => userAuthConnections({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userAuthConnections>>, TError, TData> 
}

export type UserAuthConnectionsQueryResult = NonNullable<Awaited<ReturnType<typeof userAuthConnections>>>
export type UserAuthConnectionsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserAuthConnections<TData = Awaited<ReturnType<typeof userAuthConnections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAuthConnections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserAuthConnectionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userOauthLinkStartUrl = (
    params?: MaybeRef<UserOauthLinkStartUrlParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserOauthLinkStartUrl200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/oauthLinkStartUrl`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserOauthLinkStartUrlQueryKey = (params?: MaybeRef<UserOauthLinkStartUrlParams>,) => {
    return ['user','oauthLinkStartUrl', ...(params ? [params]: [])] as const;
    }

    
export const getUserOauthLinkStartUrlQueryOptions = <TData = Awaited<ReturnType<typeof userOauthLinkStartUrl>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UserOauthLinkStartUrlParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userOauthLinkStartUrl>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserOauthLinkStartUrlQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userOauthLinkStartUrl>>> = ({ signal }) => userOauthLinkStartUrl(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userOauthLinkStartUrl>>, TError, TData> 
}

export type UserOauthLinkStartUrlQueryResult = NonNullable<Awaited<ReturnType<typeof userOauthLinkStartUrl>>>
export type UserOauthLinkStartUrlQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserOauthLinkStartUrl<TData = Awaited<ReturnType<typeof userOauthLinkStartUrl>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UserOauthLinkStartUrlParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userOauthLinkStartUrl>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserOauthLinkStartUrlQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userUnlinkOAuth = (
    userUnlinkOAuthBody: MaybeRef<UserUnlinkOAuthBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserUnlinkOAuth200>> => {
    userUnlinkOAuthBody = unref(userUnlinkOAuthBody);
    
    return axios.post(
      `/user/unlinkOAuth`,
      userUnlinkOAuthBody,options
    );
  }



export const getUserUnlinkOAuthMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnlinkOAuth>>, TError,{data: UserUnlinkOAuthBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userUnlinkOAuth>>, TError,{data: UserUnlinkOAuthBody}, TContext> => {

const mutationKey = ['userUnlinkOAuth'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userUnlinkOAuth>>, {data: UserUnlinkOAuthBody}> = (props) => {
          const {data} = props ?? {};

          return  userUnlinkOAuth(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserUnlinkOAuthMutationResult = NonNullable<Awaited<ReturnType<typeof userUnlinkOAuth>>>
    export type UserUnlinkOAuthMutationBody = UserUnlinkOAuthBody
    export type UserUnlinkOAuthMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserUnlinkOAuth = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnlinkOAuth>>, TError,{data: UserUnlinkOAuthBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userUnlinkOAuth>>,
        TError,
        {data: UserUnlinkOAuthBody},
        TContext
      > => {

      const mutationOptions = getUserUnlinkOAuthMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userRequestDeleteAccount = (
    userRequestDeleteAccountBody?: MaybeRef<UserRequestDeleteAccountBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserRequestDeleteAccount200>> => {
    userRequestDeleteAccountBody = unref(userRequestDeleteAccountBody);
    
    return axios.post(
      `/user/requestDeleteAccount`,
      userRequestDeleteAccountBody,options
    );
  }



export const getUserRequestDeleteAccountMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userRequestDeleteAccount>>, TError,{data: UserRequestDeleteAccountBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userRequestDeleteAccount>>, TError,{data: UserRequestDeleteAccountBody}, TContext> => {

const mutationKey = ['userRequestDeleteAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userRequestDeleteAccount>>, {data: UserRequestDeleteAccountBody}> = (props) => {
          const {data} = props ?? {};

          return  userRequestDeleteAccount(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserRequestDeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof userRequestDeleteAccount>>>
    export type UserRequestDeleteAccountMutationBody = UserRequestDeleteAccountBody
    export type UserRequestDeleteAccountMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserRequestDeleteAccount = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userRequestDeleteAccount>>, TError,{data: UserRequestDeleteAccountBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userRequestDeleteAccount>>,
        TError,
        {data: UserRequestDeleteAccountBody},
        TContext
      > => {

      const mutationOptions = getUserRequestDeleteAccountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userConfirmDeleteAccount = (
    userConfirmDeleteAccountBody: MaybeRef<UserConfirmDeleteAccountBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserConfirmDeleteAccount200>> => {
    userConfirmDeleteAccountBody = unref(userConfirmDeleteAccountBody);
    
    return axios.post(
      `/user/confirmDeleteAccount`,
      userConfirmDeleteAccountBody,options
    );
  }



export const getUserConfirmDeleteAccountMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userConfirmDeleteAccount>>, TError,{data: UserConfirmDeleteAccountBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userConfirmDeleteAccount>>, TError,{data: UserConfirmDeleteAccountBody}, TContext> => {

const mutationKey = ['userConfirmDeleteAccount'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userConfirmDeleteAccount>>, {data: UserConfirmDeleteAccountBody}> = (props) => {
          const {data} = props ?? {};

          return  userConfirmDeleteAccount(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserConfirmDeleteAccountMutationResult = NonNullable<Awaited<ReturnType<typeof userConfirmDeleteAccount>>>
    export type UserConfirmDeleteAccountMutationBody = UserConfirmDeleteAccountBody
    export type UserConfirmDeleteAccountMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserConfirmDeleteAccount = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userConfirmDeleteAccount>>, TError,{data: UserConfirmDeleteAccountBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userConfirmDeleteAccount>>,
        TError,
        {data: UserConfirmDeleteAccountBody},
        TContext
      > => {

      const mutationOptions = getUserConfirmDeleteAccountMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const loginLinkInitLoginLink = (
    loginLinkInitLoginLinkBody: MaybeRef<LoginLinkInitLoginLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    loginLinkInitLoginLinkBody = unref(loginLinkInitLoginLinkBody);
    
    return axios.post(
      `/loginLink/initLoginLink`,
      loginLinkInitLoginLinkBody,options
    );
  }



export const getLoginLinkInitLoginLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext> => {

const mutationKey = ['loginLinkInitLoginLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, {data: LoginLinkInitLoginLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkInitLoginLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkInitLoginLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkInitLoginLink>>>
    export type LoginLinkInitLoginLinkMutationBody = LoginLinkInitLoginLinkBody
    export type LoginLinkInitLoginLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkInitLoginLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkInitLoginLink>>,
        TError,
        {data: LoginLinkInitLoginLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkInitLoginLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const loginLinkLoginWithLink = (
    loginLinkLoginWithLinkBody: MaybeRef<LoginLinkLoginWithLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginLinkLoginWithLink200>> => {
    loginLinkLoginWithLinkBody = unref(loginLinkLoginWithLinkBody);
    
    return axios.post(
      `/loginLink/loginWithLink`,
      loginLinkLoginWithLinkBody,options
    );
  }



export const getLoginLinkLoginWithLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext> => {

const mutationKey = ['loginLinkLoginWithLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, {data: LoginLinkLoginWithLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkLoginWithLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkLoginWithLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkLoginWithLink>>>
    export type LoginLinkLoginWithLinkMutationBody = LoginLinkLoginWithLinkBody
    export type LoginLinkLoginWithLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkLoginWithLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkLoginWithLink>>,
        TError,
        {data: LoginLinkLoginWithLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkLoginWithLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const loginLinkLoginWithCode = (
    loginLinkLoginWithCodeBody: MaybeRef<LoginLinkLoginWithCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginLinkLoginWithCode200>> => {
    loginLinkLoginWithCodeBody = unref(loginLinkLoginWithCodeBody);
    
    return axios.post(
      `/loginLink/loginWithCode`,
      loginLinkLoginWithCodeBody,options
    );
  }



export const getLoginLinkLoginWithCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithCode>>, TError,{data: LoginLinkLoginWithCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithCode>>, TError,{data: LoginLinkLoginWithCodeBody}, TContext> => {

const mutationKey = ['loginLinkLoginWithCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkLoginWithCode>>, {data: LoginLinkLoginWithCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkLoginWithCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkLoginWithCodeMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkLoginWithCode>>>
    export type LoginLinkLoginWithCodeMutationBody = LoginLinkLoginWithCodeBody
    export type LoginLinkLoginWithCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkLoginWithCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithCode>>, TError,{data: LoginLinkLoginWithCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkLoginWithCode>>,
        TError,
        {data: LoginLinkLoginWithCodeBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkLoginWithCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const statsUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsUsers200>> => {
    
    
    return axios.get(
      `/stats/users`,options
    );
  }


export const getStatsUsersQueryKey = () => {
    return ['stats','users'] as const;
    }

    
export const getStatsUsersQueryOptions = <TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsUsers>>> = ({ signal }) => statsUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData> 
}

export type StatsUsersQueryResult = NonNullable<Awaited<ReturnType<typeof statsUsers>>>
export type StatsUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsUsers<TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsImages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsImages200>> => {
    
    
    return axios.get(
      `/stats/images`,options
    );
  }


export const getStatsImagesQueryKey = () => {
    return ['stats','images'] as const;
    }

    
export const getStatsImagesQueryOptions = <TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsImages>>> = ({ signal }) => statsImages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData> 
}

export type StatsImagesQueryResult = NonNullable<Awaited<ReturnType<typeof statsImages>>>
export type StatsImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsImages<TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsCollections = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsCollections200>> => {
    
    
    return axios.get(
      `/stats/collections`,options
    );
  }


export const getStatsCollectionsQueryKey = () => {
    return ['stats','collections'] as const;
    }

    
export const getStatsCollectionsQueryOptions = <TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsCollectionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsCollections>>> = ({ signal }) => statsCollections({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData> 
}

export type StatsCollectionsQueryResult = NonNullable<Awaited<ReturnType<typeof statsCollections>>>
export type StatsCollectionsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsCollections<TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsCollectionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsPayments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsPayments200>> => {
    
    
    return axios.get(
      `/stats/payments`,options
    );
  }


export const getStatsPaymentsQueryKey = () => {
    return ['stats','payments'] as const;
    }

    
export const getStatsPaymentsQueryOptions = <TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsPaymentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsPayments>>> = ({ signal }) => statsPayments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData> 
}

export type StatsPaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof statsPayments>>>
export type StatsPaymentsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsPayments<TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsPaymentsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsHistory = (
    params?: MaybeRef<StatsHistoryParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsHistory200>> => {
    params = unref(params);
    
    return axios.get(
      `/stats/history`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getStatsHistoryQueryKey = (params?: MaybeRef<StatsHistoryParams>,) => {
    return ['stats','history', ...(params ? [params]: [])] as const;
    }

    
export const getStatsHistoryQueryOptions = <TData = Awaited<ReturnType<typeof statsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<StatsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsHistory>>> = ({ signal }) => statsHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsHistory>>, TError, TData> 
}

export type StatsHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof statsHistory>>>
export type StatsHistoryQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsHistory<TData = Awaited<ReturnType<typeof statsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<StatsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsWeekly = (
    params?: MaybeRef<StatsWeeklyParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsWeekly200>> => {
    params = unref(params);
    
    return axios.get(
      `/stats/weekly`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getStatsWeeklyQueryKey = (params?: MaybeRef<StatsWeeklyParams>,) => {
    return ['stats','weekly', ...(params ? [params]: [])] as const;
    }

    
export const getStatsWeeklyQueryOptions = <TData = Awaited<ReturnType<typeof statsWeekly>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<StatsWeeklyParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsWeekly>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsWeeklyQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsWeekly>>> = ({ signal }) => statsWeekly(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsWeekly>>, TError, TData> 
}

export type StatsWeeklyQueryResult = NonNullable<Awaited<ReturnType<typeof statsWeekly>>>
export type StatsWeeklyQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsWeekly<TData = Awaited<ReturnType<typeof statsWeekly>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<StatsWeeklyParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsWeekly>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsWeeklyQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsMediaInUsersCollection = (
    params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/mediaInUsersCollection`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsMediaInUsersCollectionQueryKey = (params: MaybeRef<CollectionsMediaInUsersCollectionParams>,) => {
    return ['collections','mediaInUsersCollection', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsMediaInUsersCollectionQueryOptions = <TData = Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsMediaInUsersCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>> = ({ signal }) => collectionsMediaInUsersCollection(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData> 
}

export type CollectionsMediaInUsersCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>>
export type CollectionsMediaInUsersCollectionQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsMediaInUsersCollection<TData = Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsMediaInUsersCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsLikeMedia = (
    collectionsLikeMediaBody: MaybeRef<CollectionsLikeMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsLikeMediaBody = unref(collectionsLikeMediaBody);
    
    return axios.post(
      `/collections/likeMedia`,
      collectionsLikeMediaBody,options
    );
  }



export const getCollectionsLikeMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext> => {

const mutationKey = ['collectionsLikeMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsLikeMedia>>, {data: CollectionsLikeMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsLikeMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsLikeMediaMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsLikeMedia>>>
    export type CollectionsLikeMediaMutationBody = CollectionsLikeMediaBody
    export type CollectionsLikeMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsLikeMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsLikeMedia>>,
        TError,
        {data: CollectionsLikeMediaBody},
        TContext
      > => {

      const mutationOptions = getCollectionsLikeMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsUnlikeMedia = (
    collectionsUnlikeMediaBody: MaybeRef<CollectionsUnlikeMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsUnlikeMediaBody = unref(collectionsUnlikeMediaBody);
    
    return axios.post(
      `/collections/unlikeMedia`,
      collectionsUnlikeMediaBody,options
    );
  }



export const getCollectionsUnlikeMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext> => {

const mutationKey = ['collectionsUnlikeMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, {data: CollectionsUnlikeMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsUnlikeMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsUnlikeMediaMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsUnlikeMedia>>>
    export type CollectionsUnlikeMediaMutationBody = CollectionsUnlikeMediaBody
    export type CollectionsUnlikeMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsUnlikeMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsUnlikeMedia>>,
        TError,
        {data: CollectionsUnlikeMediaBody},
        TContext
      > => {

      const mutationOptions = getCollectionsUnlikeMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsGetCollectionMeta = (
    params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionMeta200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionMeta`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionMetaQueryKey = (params: MaybeRef<CollectionsGetCollectionMetaParams>,) => {
    return ['collections','getCollectionMeta', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionMetaQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionMetaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>> = ({ signal }) => collectionsGetCollectionMeta(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData> 
}

export type CollectionsGetCollectionMetaQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>>
export type CollectionsGetCollectionMetaQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionMeta<TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionMetaQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsFindCollectionByName = (
    params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsFindCollectionByName200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/findCollectionByName`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsFindCollectionByNameQueryKey = (params: MaybeRef<CollectionsFindCollectionByNameParams>,) => {
    return ['collections','findCollectionByName', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsFindCollectionByNameQueryOptions = <TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsFindCollectionByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsFindCollectionByName>>> = ({ signal }) => collectionsFindCollectionByName(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData> 
}

export type CollectionsFindCollectionByNameQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsFindCollectionByName>>>
export type CollectionsFindCollectionByNameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsFindCollectionByName<TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsFindCollectionByNameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionImages = (
    params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionImages200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionImages`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionImagesQueryKey = (params: MaybeRef<CollectionsGetCollectionImagesParams>,) => {
    return ['collections','getCollectionImages', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionImagesQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionImagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionImages>>> = ({ signal }) => collectionsGetCollectionImages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData> 
}

export type CollectionsGetCollectionImagesQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionImages>>>
export type CollectionsGetCollectionImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionImages<TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionImagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionVideos = (
    params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionVideos200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionVideos`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionVideosQueryKey = (params: MaybeRef<CollectionsGetCollectionVideosParams>,) => {
    return ['collections','getCollectionVideos', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionVideosQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionVideosQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>> = ({ signal }) => collectionsGetCollectionVideos(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData> 
}

export type CollectionsGetCollectionVideosQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>>
export type CollectionsGetCollectionVideosQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionVideos<TData = Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionVideosQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionMedia = (
    params: MaybeRef<CollectionsGetCollectionMediaParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionMedia200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionMedia`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionMediaQueryKey = (params: MaybeRef<CollectionsGetCollectionMediaParams>,) => {
    return ['collections','getCollectionMedia', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionMediaQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionMedia>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionMediaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMedia>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionMediaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionMedia>>> = ({ signal }) => collectionsGetCollectionMedia(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMedia>>, TError, TData> 
}

export type CollectionsGetCollectionMediaQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionMedia>>>
export type CollectionsGetCollectionMediaQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionMedia<TData = Awaited<ReturnType<typeof collectionsGetCollectionMedia>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionMediaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMedia>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionMediaQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoCreatePromoCode = (
    promoCreatePromoCodeBody: MaybeRef<PromoCreatePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoCreatePromoCode200>> => {
    promoCreatePromoCodeBody = unref(promoCreatePromoCodeBody);
    
    return axios.post(
      `/promo/createPromoCode`,
      promoCreatePromoCodeBody,options
    );
  }



export const getPromoCreatePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext> => {

const mutationKey = ['promoCreatePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoCreatePromoCode>>, {data: PromoCreatePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoCreatePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoCreatePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoCreatePromoCode>>>
    export type PromoCreatePromoCodeMutationBody = PromoCreatePromoCodeBody
    export type PromoCreatePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoCreatePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoCreatePromoCode>>,
        TError,
        {data: PromoCreatePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoCreatePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoDeletePromoCode = (
    promoDeletePromoCodeBody: MaybeRef<PromoDeletePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoDeletePromoCodeBody = unref(promoDeletePromoCodeBody);
    
    return axios.post(
      `/promo/deletePromoCode`,
      promoDeletePromoCodeBody,options
    );
  }



export const getPromoDeletePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext> => {

const mutationKey = ['promoDeletePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoDeletePromoCode>>, {data: PromoDeletePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoDeletePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoDeletePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoDeletePromoCode>>>
    export type PromoDeletePromoCodeMutationBody = PromoDeletePromoCodeBody
    export type PromoDeletePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoDeletePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoDeletePromoCode>>,
        TError,
        {data: PromoDeletePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoDeletePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoGetPromoCodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodes200Item[]>> => {
    
    
    return axios.get(
      `/promo/getPromoCodes`,options
    );
  }


export const getPromoGetPromoCodesQueryKey = () => {
    return ['promo','getPromoCodes'] as const;
    }

    
export const getPromoGetPromoCodesQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodes>>> = ({ signal }) => promoGetPromoCodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData> 
}

export type PromoGetPromoCodesQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodes>>>
export type PromoGetPromoCodesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodes<TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoGetPromoCodeDetails = (
    params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodeDetails200>> => {
    params = unref(params);
    
    return axios.get(
      `/promo/getPromoCodeDetails`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPromoGetPromoCodeDetailsQueryKey = (params: MaybeRef<PromoGetPromoCodeDetailsParams>,) => {
    return ['promo','getPromoCodeDetails', ...(params ? [params]: [])] as const;
    }

    
export const getPromoGetPromoCodeDetailsQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodeDetailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>> = ({ signal }) => promoGetPromoCodeDetails(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData> 
}

export type PromoGetPromoCodeDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>>
export type PromoGetPromoCodeDetailsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodeDetails<TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodeDetailsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoClaimPromoCode = (
    promoClaimPromoCodeBody: MaybeRef<PromoClaimPromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoClaimPromoCodeBody = unref(promoClaimPromoCodeBody);
    
    return axios.post(
      `/promo/claimPromoCode`,
      promoClaimPromoCodeBody,options
    );
  }



export const getPromoClaimPromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext> => {

const mutationKey = ['promoClaimPromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoClaimPromoCode>>, {data: PromoClaimPromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoClaimPromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoClaimPromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoClaimPromoCode>>>
    export type PromoClaimPromoCodeMutationBody = PromoClaimPromoCodeBody
    export type PromoClaimPromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoClaimPromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoClaimPromoCode>>,
        TError,
        {data: PromoClaimPromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoClaimPromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoCreateAccountWithPromo = (
    promoCreateAccountWithPromoBody: MaybeRef<PromoCreateAccountWithPromoBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoCreateAccountWithPromo200>> => {
    promoCreateAccountWithPromoBody = unref(promoCreateAccountWithPromoBody);
    
    return axios.post(
      `/promo/createAccountWithPromo`,
      promoCreateAccountWithPromoBody,options
    );
  }



export const getPromoCreateAccountWithPromoMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreateAccountWithPromo>>, TError,{data: PromoCreateAccountWithPromoBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoCreateAccountWithPromo>>, TError,{data: PromoCreateAccountWithPromoBody}, TContext> => {

const mutationKey = ['promoCreateAccountWithPromo'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoCreateAccountWithPromo>>, {data: PromoCreateAccountWithPromoBody}> = (props) => {
          const {data} = props ?? {};

          return  promoCreateAccountWithPromo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoCreateAccountWithPromoMutationResult = NonNullable<Awaited<ReturnType<typeof promoCreateAccountWithPromo>>>
    export type PromoCreateAccountWithPromoMutationBody = PromoCreateAccountWithPromoBody
    export type PromoCreateAccountWithPromoMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoCreateAccountWithPromo = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreateAccountWithPromo>>, TError,{data: PromoCreateAccountWithPromoBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoCreateAccountWithPromo>>,
        TError,
        {data: PromoCreateAccountWithPromoBody},
        TContext
      > => {

      const mutationOptions = getPromoCreateAccountWithPromoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsEditModel = (
    modelsEditModelBody: MaybeRef<ModelsEditModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsEditModelBody = unref(modelsEditModelBody);
    
    return axios.post(
      `/models/editModel`,
      modelsEditModelBody,options
    );
  }



export const getModelsEditModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext> => {

const mutationKey = ['modelsEditModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsEditModel>>, {data: ModelsEditModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsEditModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsEditModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsEditModel>>>
    export type ModelsEditModelMutationBody = ModelsEditModelBody
    export type ModelsEditModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsEditModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsEditModel>>,
        TError,
        {data: ModelsEditModelBody},
        TContext
      > => {

      const mutationOptions = getModelsEditModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetUserModels = (
    params?: MaybeRef<ModelsGetUserModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetUserModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getUserModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetUserModelsQueryKey = (params?: MaybeRef<ModelsGetUserModelsParams>,) => {
    return ['models','getUserModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetUserModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetUserModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetUserModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetUserModels>>> = ({ signal }) => modelsGetUserModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData> 
}

export type ModelsGetUserModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetUserModels>>>
export type ModelsGetUserModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetUserModels<TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetUserModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetUserModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsCreateModel = (
    modelsCreateModelBody: MaybeRef<ModelsCreateModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    modelsCreateModelBody = unref(modelsCreateModelBody);
    
    return axios.post(
      `/models/createModel`,
      modelsCreateModelBody,options
    );
  }



export const getModelsCreateModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext> => {

const mutationKey = ['modelsCreateModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsCreateModel>>, {data: ModelsCreateModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsCreateModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsCreateModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsCreateModel>>>
    export type ModelsCreateModelMutationBody = ModelsCreateModelBody
    export type ModelsCreateModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsCreateModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsCreateModel>>,
        TError,
        {data: ModelsCreateModelBody},
        TContext
      > => {

      const mutationOptions = getModelsCreateModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetTrainingStatus = (
    params: MaybeRef<ModelsGetTrainingStatusParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetTrainingStatus200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getTrainingStatus`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetTrainingStatusQueryKey = (params: MaybeRef<ModelsGetTrainingStatusParams>,) => {
    return ['models','getTrainingStatus', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetTrainingStatusQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetTrainingStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetTrainingStatus>>> = ({ signal }) => modelsGetTrainingStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData> 
}

export type ModelsGetTrainingStatusQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetTrainingStatus>>>
export type ModelsGetTrainingStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetTrainingStatus<TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetTrainingStatusQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsDeleteModel = (
    modelsDeleteModelBody: MaybeRef<ModelsDeleteModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsDeleteModelBody = unref(modelsDeleteModelBody);
    
    return axios.post(
      `/models/deleteModel`,
      modelsDeleteModelBody,options
    );
  }



export const getModelsDeleteModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext> => {

const mutationKey = ['modelsDeleteModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsDeleteModel>>, {data: ModelsDeleteModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsDeleteModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsDeleteModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsDeleteModel>>>
    export type ModelsDeleteModelMutationBody = ModelsDeleteModelBody
    export type ModelsDeleteModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsDeleteModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsDeleteModel>>,
        TError,
        {data: ModelsDeleteModelBody},
        TContext
      > => {

      const mutationOptions = getModelsDeleteModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetCustomModel = (
    params: MaybeRef<ModelsGetCustomModelParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetCustomModel200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getCustomModel`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetCustomModelQueryKey = (params: MaybeRef<ModelsGetCustomModelParams>,) => {
    return ['models','getCustomModel', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetCustomModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetCustomModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetCustomModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetCustomModelQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetCustomModel>>> = ({ signal }) => modelsGetCustomModel(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData> 
}

export type ModelsGetCustomModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetCustomModel>>>
export type ModelsGetCustomModelQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetCustomModel<TData = Awaited<ReturnType<typeof modelsGetCustomModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetCustomModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetCustomModelQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsGetPublicModels = (
    params?: MaybeRef<ModelsGetPublicModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetPublicModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getPublicModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetPublicModelsQueryKey = (params?: MaybeRef<ModelsGetPublicModelsParams>,) => {
    return ['models','getPublicModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetPublicModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetPublicModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetPublicModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetPublicModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetPublicModels>>> = ({ signal }) => modelsGetPublicModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData> 
}

export type ModelsGetPublicModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetPublicModels>>>
export type ModelsGetPublicModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetPublicModels<TData = Awaited<ReturnType<typeof modelsGetPublicModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetPublicModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetPublicModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsGetBaseModels = (
    params?: MaybeRef<ModelsGetBaseModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetBaseModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getBaseModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetBaseModelsQueryKey = (params?: MaybeRef<ModelsGetBaseModelsParams>,) => {
    return ['models','getBaseModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetBaseModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetBaseModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetBaseModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetBaseModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetBaseModels>>> = ({ signal }) => modelsGetBaseModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData> 
}

export type ModelsGetBaseModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetBaseModels>>>
export type ModelsGetBaseModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetBaseModels<TData = Awaited<ReturnType<typeof modelsGetBaseModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetBaseModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetBaseModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsGetModelByName = (
    params: MaybeRef<ModelsGetModelByNameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetModelByName200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getModelByName`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetModelByNameQueryKey = (params: MaybeRef<ModelsGetModelByNameParams>,) => {
    return ['models','getModelByName', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetModelByNameQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetModelByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetModelByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetModelByName>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetModelByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetModelByName>>> = ({ signal }) => modelsGetModelByName(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetModelByName>>, TError, TData> 
}

export type ModelsGetModelByNameQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetModelByName>>>
export type ModelsGetModelByNameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetModelByName<TData = Awaited<ReturnType<typeof modelsGetModelByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetModelByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetModelByName>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetModelByNameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsSetModelPrivacy = (
    modelsSetModelPrivacyBody: MaybeRef<ModelsSetModelPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsSetModelPrivacyBody = unref(modelsSetModelPrivacyBody);
    
    return axios.post(
      `/models/setModelPrivacy`,
      modelsSetModelPrivacyBody,options
    );
  }



export const getModelsSetModelPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext> => {

const mutationKey = ['modelsSetModelPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, {data: ModelsSetModelPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsSetModelPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsSetModelPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof modelsSetModelPrivacy>>>
    export type ModelsSetModelPrivacyMutationBody = ModelsSetModelPrivacyBody
    export type ModelsSetModelPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsSetModelPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsSetModelPrivacy>>,
        TError,
        {data: ModelsSetModelPrivacyBody},
        TContext
      > => {

      const mutationOptions = getModelsSetModelPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminLoginAsUser = (
    adminLoginAsUserBody: MaybeRef<AdminLoginAsUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    adminLoginAsUserBody = unref(adminLoginAsUserBody);
    
    return axios.post(
      `/admin/loginAsUser`,
      adminLoginAsUserBody,options
    );
  }



export const getAdminLoginAsUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext> => {

const mutationKey = ['adminLoginAsUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLoginAsUser>>, {data: AdminLoginAsUserBody}> = (props) => {
          const {data} = props ?? {};

          return  adminLoginAsUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminLoginAsUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminLoginAsUser>>>
    export type AdminLoginAsUserMutationBody = AdminLoginAsUserBody
    export type AdminLoginAsUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminLoginAsUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminLoginAsUser>>,
        TError,
        {data: AdminLoginAsUserBody},
        TContext
      > => {

      const mutationOptions = getAdminLoginAsUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminBanUser = (
    adminBanUserBody: MaybeRef<AdminBanUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminBanUser200>> => {
    adminBanUserBody = unref(adminBanUserBody);
    
    return axios.post(
      `/admin/banUser`,
      adminBanUserBody,options
    );
  }



export const getAdminBanUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminBanUser>>, TError,{data: AdminBanUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminBanUser>>, TError,{data: AdminBanUserBody}, TContext> => {

const mutationKey = ['adminBanUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminBanUser>>, {data: AdminBanUserBody}> = (props) => {
          const {data} = props ?? {};

          return  adminBanUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminBanUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminBanUser>>>
    export type AdminBanUserMutationBody = AdminBanUserBody
    export type AdminBanUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminBanUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminBanUser>>, TError,{data: AdminBanUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminBanUser>>,
        TError,
        {data: AdminBanUserBody},
        TContext
      > => {

      const mutationOptions = getAdminBanUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminListUsers = (
    params?: MaybeRef<AdminListUsersParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminListUsers200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/listUsers`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminListUsersQueryKey = (params?: MaybeRef<AdminListUsersParams>,) => {
    return ['admin','listUsers', ...(params ? [params]: [])] as const;
    }

    
export const getAdminListUsersQueryOptions = <TData = Awaited<ReturnType<typeof adminListUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminListUsersParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminListUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListUsers>>> = ({ signal }) => adminListUsers(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListUsers>>, TError, TData> 
}

export type AdminListUsersQueryResult = NonNullable<Awaited<ReturnType<typeof adminListUsers>>>
export type AdminListUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminListUsers<TData = Awaited<ReturnType<typeof adminListUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminListUsersParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListUsersQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminListPayments = (
    params?: MaybeRef<AdminListPaymentsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminListPayments200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/listPayments`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminListPaymentsQueryKey = (params?: MaybeRef<AdminListPaymentsParams>,) => {
    return ['admin','listPayments', ...(params ? [params]: [])] as const;
    }

    
export const getAdminListPaymentsQueryOptions = <TData = Awaited<ReturnType<typeof adminListPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminListPaymentsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminListPaymentsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListPayments>>> = ({ signal }) => adminListPayments(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListPayments>>, TError, TData> 
}

export type AdminListPaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof adminListPayments>>>
export type AdminListPaymentsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminListPayments<TData = Awaited<ReturnType<typeof adminListPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminListPaymentsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListPaymentsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminListMissionClaims = (
    params?: MaybeRef<AdminListMissionClaimsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminListMissionClaims200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/listMissionClaims`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminListMissionClaimsQueryKey = (params?: MaybeRef<AdminListMissionClaimsParams>,) => {
    return ['admin','listMissionClaims', ...(params ? [params]: [])] as const;
    }

    
export const getAdminListMissionClaimsQueryOptions = <TData = Awaited<ReturnType<typeof adminListMissionClaims>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminListMissionClaimsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListMissionClaims>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminListMissionClaimsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListMissionClaims>>> = ({ signal }) => adminListMissionClaims(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListMissionClaims>>, TError, TData> 
}

export type AdminListMissionClaimsQueryResult = NonNullable<Awaited<ReturnType<typeof adminListMissionClaims>>>
export type AdminListMissionClaimsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminListMissionClaims<TData = Awaited<ReturnType<typeof adminListMissionClaims>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminListMissionClaimsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListMissionClaims>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListMissionClaimsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminListTrainingSetThumbnails = (
    params?: MaybeRef<AdminListTrainingSetThumbnailsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminListTrainingSetThumbnails200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/listTrainingSetThumbnails`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminListTrainingSetThumbnailsQueryKey = (params?: MaybeRef<AdminListTrainingSetThumbnailsParams>,) => {
    return ['admin','listTrainingSetThumbnails', ...(params ? [params]: [])] as const;
    }

    
export const getAdminListTrainingSetThumbnailsQueryOptions = <TData = Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminListTrainingSetThumbnailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminListTrainingSetThumbnailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>> = ({ signal }) => adminListTrainingSetThumbnails(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>, TError, TData> 
}

export type AdminListTrainingSetThumbnailsQueryResult = NonNullable<Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>>
export type AdminListTrainingSetThumbnailsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminListTrainingSetThumbnails<TData = Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminListTrainingSetThumbnailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListTrainingSetThumbnails>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListTrainingSetThumbnailsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminListUploadedImages = (
    params?: MaybeRef<AdminListUploadedImagesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminListUploadedImages200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/listUploadedImages`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminListUploadedImagesQueryKey = (params?: MaybeRef<AdminListUploadedImagesParams>,) => {
    return ['admin','listUploadedImages', ...(params ? [params]: [])] as const;
    }

    
export const getAdminListUploadedImagesQueryOptions = <TData = Awaited<ReturnType<typeof adminListUploadedImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminListUploadedImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListUploadedImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminListUploadedImagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminListUploadedImages>>> = ({ signal }) => adminListUploadedImages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminListUploadedImages>>, TError, TData> 
}

export type AdminListUploadedImagesQueryResult = NonNullable<Awaited<ReturnType<typeof adminListUploadedImages>>>
export type AdminListUploadedImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminListUploadedImages<TData = Awaited<ReturnType<typeof adminListUploadedImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminListUploadedImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminListUploadedImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminListUploadedImagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminDiscountCodesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDiscountCodesList200Item[]>> => {
    
    
    return axios.get(
      `/admin/discountCodesList`,options
    );
  }


export const getAdminDiscountCodesListQueryKey = () => {
    return ['admin','discountCodesList'] as const;
    }

    
export const getAdminDiscountCodesListQueryOptions = <TData = Awaited<ReturnType<typeof adminDiscountCodesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDiscountCodesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminDiscountCodesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminDiscountCodesList>>> = ({ signal }) => adminDiscountCodesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminDiscountCodesList>>, TError, TData> 
}

export type AdminDiscountCodesListQueryResult = NonNullable<Awaited<ReturnType<typeof adminDiscountCodesList>>>
export type AdminDiscountCodesListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminDiscountCodesList<TData = Awaited<ReturnType<typeof adminDiscountCodesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminDiscountCodesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminDiscountCodesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminDiscountCodeCreate = (
    adminDiscountCodeCreateBody: MaybeRef<AdminDiscountCodeCreateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDiscountCodeCreate200>> => {
    adminDiscountCodeCreateBody = unref(adminDiscountCodeCreateBody);
    
    return axios.post(
      `/admin/discountCodeCreate`,
      adminDiscountCodeCreateBody,options
    );
  }



export const getAdminDiscountCodeCreateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeCreate>>, TError,{data: AdminDiscountCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeCreate>>, TError,{data: AdminDiscountCodeCreateBody}, TContext> => {

const mutationKey = ['adminDiscountCodeCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminDiscountCodeCreate>>, {data: AdminDiscountCodeCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  adminDiscountCodeCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminDiscountCodeCreateMutationResult = NonNullable<Awaited<ReturnType<typeof adminDiscountCodeCreate>>>
    export type AdminDiscountCodeCreateMutationBody = AdminDiscountCodeCreateBody
    export type AdminDiscountCodeCreateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminDiscountCodeCreate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeCreate>>, TError,{data: AdminDiscountCodeCreateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminDiscountCodeCreate>>,
        TError,
        {data: AdminDiscountCodeCreateBody},
        TContext
      > => {

      const mutationOptions = getAdminDiscountCodeCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminDiscountCodeUpdate = (
    adminDiscountCodeUpdateBody: MaybeRef<AdminDiscountCodeUpdateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDiscountCodeUpdate200>> => {
    adminDiscountCodeUpdateBody = unref(adminDiscountCodeUpdateBody);
    
    return axios.post(
      `/admin/discountCodeUpdate`,
      adminDiscountCodeUpdateBody,options
    );
  }



export const getAdminDiscountCodeUpdateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeUpdate>>, TError,{data: AdminDiscountCodeUpdateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeUpdate>>, TError,{data: AdminDiscountCodeUpdateBody}, TContext> => {

const mutationKey = ['adminDiscountCodeUpdate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminDiscountCodeUpdate>>, {data: AdminDiscountCodeUpdateBody}> = (props) => {
          const {data} = props ?? {};

          return  adminDiscountCodeUpdate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminDiscountCodeUpdateMutationResult = NonNullable<Awaited<ReturnType<typeof adminDiscountCodeUpdate>>>
    export type AdminDiscountCodeUpdateMutationBody = AdminDiscountCodeUpdateBody
    export type AdminDiscountCodeUpdateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminDiscountCodeUpdate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeUpdate>>, TError,{data: AdminDiscountCodeUpdateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminDiscountCodeUpdate>>,
        TError,
        {data: AdminDiscountCodeUpdateBody},
        TContext
      > => {

      const mutationOptions = getAdminDiscountCodeUpdateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminAffiliatePayoutDetailsForUser = (
    params: MaybeRef<AdminAffiliatePayoutDetailsForUserParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminAffiliatePayoutDetailsForUser200>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/affiliatePayoutDetailsForUser`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminAffiliatePayoutDetailsForUserQueryKey = (params: MaybeRef<AdminAffiliatePayoutDetailsForUserParams>,) => {
    return ['admin','affiliatePayoutDetailsForUser', ...(params ? [params]: [])] as const;
    }

    
export const getAdminAffiliatePayoutDetailsForUserQueryOptions = <TData = Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<AdminAffiliatePayoutDetailsForUserParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminAffiliatePayoutDetailsForUserQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>> = ({ signal }) => adminAffiliatePayoutDetailsForUser(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>, TError, TData> 
}

export type AdminAffiliatePayoutDetailsForUserQueryResult = NonNullable<Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>>
export type AdminAffiliatePayoutDetailsForUserQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminAffiliatePayoutDetailsForUser<TData = Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<AdminAffiliatePayoutDetailsForUserParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutDetailsForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminAffiliatePayoutDetailsForUserQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminAffiliatePayoutUser = (
    adminAffiliatePayoutUserBody: MaybeRef<AdminAffiliatePayoutUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminAffiliatePayoutUser200>> => {
    adminAffiliatePayoutUserBody = unref(adminAffiliatePayoutUserBody);
    
    return axios.post(
      `/admin/affiliatePayoutUser`,
      adminAffiliatePayoutUserBody,options
    );
  }



export const getAdminAffiliatePayoutUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAffiliatePayoutUser>>, TError,{data: AdminAffiliatePayoutUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminAffiliatePayoutUser>>, TError,{data: AdminAffiliatePayoutUserBody}, TContext> => {

const mutationKey = ['adminAffiliatePayoutUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminAffiliatePayoutUser>>, {data: AdminAffiliatePayoutUserBody}> = (props) => {
          const {data} = props ?? {};

          return  adminAffiliatePayoutUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminAffiliatePayoutUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminAffiliatePayoutUser>>>
    export type AdminAffiliatePayoutUserMutationBody = AdminAffiliatePayoutUserBody
    export type AdminAffiliatePayoutUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminAffiliatePayoutUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminAffiliatePayoutUser>>, TError,{data: AdminAffiliatePayoutUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminAffiliatePayoutUser>>,
        TError,
        {data: AdminAffiliatePayoutUserBody},
        TContext
      > => {

      const mutationOptions = getAdminAffiliatePayoutUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminAffiliatePayoutReceipts = (
    params?: MaybeRef<AdminAffiliatePayoutReceiptsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminAffiliatePayoutReceipts200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/admin/affiliatePayoutReceipts`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getAdminAffiliatePayoutReceiptsQueryKey = (params?: MaybeRef<AdminAffiliatePayoutReceiptsParams>,) => {
    return ['admin','affiliatePayoutReceipts', ...(params ? [params]: [])] as const;
    }

    
export const getAdminAffiliatePayoutReceiptsQueryOptions = <TData = Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<AdminAffiliatePayoutReceiptsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getAdminAffiliatePayoutReceiptsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>> = ({ signal }) => adminAffiliatePayoutReceipts(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>, TError, TData> 
}

export type AdminAffiliatePayoutReceiptsQueryResult = NonNullable<Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>>
export type AdminAffiliatePayoutReceiptsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useAdminAffiliatePayoutReceipts<TData = Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<AdminAffiliatePayoutReceiptsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof adminAffiliatePayoutReceipts>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getAdminAffiliatePayoutReceiptsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const adminDiscountCodeDelete = (
    adminDiscountCodeDeleteBody: MaybeRef<AdminDiscountCodeDeleteBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AdminDiscountCodeDelete200>> => {
    adminDiscountCodeDeleteBody = unref(adminDiscountCodeDeleteBody);
    
    return axios.post(
      `/admin/discountCodeDelete`,
      adminDiscountCodeDeleteBody,options
    );
  }



export const getAdminDiscountCodeDeleteMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeDelete>>, TError,{data: AdminDiscountCodeDeleteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeDelete>>, TError,{data: AdminDiscountCodeDeleteBody}, TContext> => {

const mutationKey = ['adminDiscountCodeDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminDiscountCodeDelete>>, {data: AdminDiscountCodeDeleteBody}> = (props) => {
          const {data} = props ?? {};

          return  adminDiscountCodeDelete(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminDiscountCodeDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof adminDiscountCodeDelete>>>
    export type AdminDiscountCodeDeleteMutationBody = AdminDiscountCodeDeleteBody
    export type AdminDiscountCodeDeleteMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminDiscountCodeDelete = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminDiscountCodeDelete>>, TError,{data: AdminDiscountCodeDeleteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminDiscountCodeDelete>>,
        TError,
        {data: AdminDiscountCodeDeleteBody},
        TContext
      > => {

      const mutationOptions = getAdminDiscountCodeDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tonomyAuthLoginOrRegister = (
    tonomyAuthLoginOrRegisterBody: MaybeRef<TonomyAuthLoginOrRegisterBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TonomyAuthLoginOrRegister200>> => {
    tonomyAuthLoginOrRegisterBody = unref(tonomyAuthLoginOrRegisterBody);
    
    return axios.post(
      `/tonomyAuth/loginOrRegister`,
      tonomyAuthLoginOrRegisterBody,options
    );
  }



export const getTonomyAuthLoginOrRegisterMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>, TError,{data: TonomyAuthLoginOrRegisterBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>, TError,{data: TonomyAuthLoginOrRegisterBody}, TContext> => {

const mutationKey = ['tonomyAuthLoginOrRegister'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>, {data: TonomyAuthLoginOrRegisterBody}> = (props) => {
          const {data} = props ?? {};

          return  tonomyAuthLoginOrRegister(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TonomyAuthLoginOrRegisterMutationResult = NonNullable<Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>>
    export type TonomyAuthLoginOrRegisterMutationBody = TonomyAuthLoginOrRegisterBody
    export type TonomyAuthLoginOrRegisterMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTonomyAuthLoginOrRegister = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>, TError,{data: TonomyAuthLoginOrRegisterBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof tonomyAuthLoginOrRegister>>,
        TError,
        {data: TonomyAuthLoginOrRegisterBody},
        TContext
      > => {

      const mutationOptions = getTonomyAuthLoginOrRegisterMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const privyAuthenticate = (
    privyAuthenticateBody: MaybeRef<PrivyAuthenticateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrivyAuthenticate200>> => {
    privyAuthenticateBody = unref(privyAuthenticateBody);
    
    return axios.post(
      `/privy/authenticate`,
      privyAuthenticateBody,options
    );
  }



export const getPrivyAuthenticateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext> => {

const mutationKey = ['privyAuthenticate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof privyAuthenticate>>, {data: PrivyAuthenticateBody}> = (props) => {
          const {data} = props ?? {};

          return  privyAuthenticate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrivyAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof privyAuthenticate>>>
    export type PrivyAuthenticateMutationBody = PrivyAuthenticateBody
    export type PrivyAuthenticateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePrivyAuthenticate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof privyAuthenticate>>,
        TError,
        {data: PrivyAuthenticateBody},
        TContext
      > => {

      const mutationOptions = getPrivyAuthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const privyLinkCurrentUser = (
    privyLinkCurrentUserBody: MaybeRef<PrivyLinkCurrentUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrivyLinkCurrentUser200>> => {
    privyLinkCurrentUserBody = unref(privyLinkCurrentUserBody);
    
    return axios.post(
      `/privy/linkCurrentUser`,
      privyLinkCurrentUserBody,options
    );
  }



export const getPrivyLinkCurrentUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyLinkCurrentUser>>, TError,{data: PrivyLinkCurrentUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof privyLinkCurrentUser>>, TError,{data: PrivyLinkCurrentUserBody}, TContext> => {

const mutationKey = ['privyLinkCurrentUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof privyLinkCurrentUser>>, {data: PrivyLinkCurrentUserBody}> = (props) => {
          const {data} = props ?? {};

          return  privyLinkCurrentUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrivyLinkCurrentUserMutationResult = NonNullable<Awaited<ReturnType<typeof privyLinkCurrentUser>>>
    export type PrivyLinkCurrentUserMutationBody = PrivyLinkCurrentUserBody
    export type PrivyLinkCurrentUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePrivyLinkCurrentUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyLinkCurrentUser>>, TError,{data: PrivyLinkCurrentUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof privyLinkCurrentUser>>,
        TError,
        {data: PrivyLinkCurrentUserBody},
        TContext
      > => {

      const mutationOptions = getPrivyLinkCurrentUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promptTemplatesList = (
    params?: MaybeRef<PromptTemplatesListParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromptTemplatesList200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/promptTemplates/list`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPromptTemplatesListQueryKey = (params?: MaybeRef<PromptTemplatesListParams>,) => {
    return ['promptTemplates','list', ...(params ? [params]: [])] as const;
    }

    
export const getPromptTemplatesListQueryOptions = <TData = Awaited<ReturnType<typeof promptTemplatesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<PromptTemplatesListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptTemplatesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromptTemplatesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promptTemplatesList>>> = ({ signal }) => promptTemplatesList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promptTemplatesList>>, TError, TData> 
}

export type PromptTemplatesListQueryResult = NonNullable<Awaited<ReturnType<typeof promptTemplatesList>>>
export type PromptTemplatesListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromptTemplatesList<TData = Awaited<ReturnType<typeof promptTemplatesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<PromptTemplatesListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promptTemplatesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromptTemplatesListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsCreateSet = (
    trainingSetsCreateSetBody: MaybeRef<TrainingSetsCreateSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsCreateSet200>> => {
    trainingSetsCreateSetBody = unref(trainingSetsCreateSetBody);
    
    return axios.post(
      `/trainingSets/createSet`,
      trainingSetsCreateSetBody,options
    );
  }



export const getTrainingSetsCreateSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext> => {

const mutationKey = ['trainingSetsCreateSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsCreateSet>>, {data: TrainingSetsCreateSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsCreateSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsCreateSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsCreateSet>>>
    export type TrainingSetsCreateSetMutationBody = TrainingSetsCreateSetBody
    export type TrainingSetsCreateSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsCreateSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsCreateSet>>,
        TError,
        {data: TrainingSetsCreateSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsCreateSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsFinalizeSet = (
    trainingSetsFinalizeSetBody: MaybeRef<TrainingSetsFinalizeSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsFinalizeSetBody = unref(trainingSetsFinalizeSetBody);
    
    return axios.post(
      `/trainingSets/finalizeSet`,
      trainingSetsFinalizeSetBody,options
    );
  }



export const getTrainingSetsFinalizeSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext> => {

const mutationKey = ['trainingSetsFinalizeSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, {data: TrainingSetsFinalizeSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsFinalizeSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsFinalizeSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>>
    export type TrainingSetsFinalizeSetMutationBody = TrainingSetsFinalizeSetBody
    export type TrainingSetsFinalizeSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsFinalizeSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsFinalizeSet>>,
        TError,
        {data: TrainingSetsFinalizeSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsFinalizeSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsGetUserSets = (
    params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetUserSets200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getUserSets`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetUserSetsQueryKey = (params: MaybeRef<TrainingSetsGetUserSetsParams>,) => {
    return ['trainingSets','getUserSets', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetUserSetsQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetUserSetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetUserSets>>> = ({ signal }) => trainingSetsGetUserSets(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData> 
}

export type TrainingSetsGetUserSetsQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetUserSets>>>
export type TrainingSetsGetUserSetsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetUserSets<TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetUserSetsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsGetSet = (
    params: MaybeRef<TrainingSetsGetSetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetSet200>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getSet`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetSetQueryKey = (params: MaybeRef<TrainingSetsGetSetParams>,) => {
    return ['trainingSets','getSet', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetSetQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetSetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetSet>>> = ({ signal }) => trainingSetsGetSet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData> 
}

export type TrainingSetsGetSetQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetSet>>>
export type TrainingSetsGetSetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetSet<TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetSetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsDeleteSet = (
    trainingSetsDeleteSetBody: MaybeRef<TrainingSetsDeleteSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsDeleteSetBody = unref(trainingSetsDeleteSetBody);
    
    return axios.post(
      `/trainingSets/deleteSet`,
      trainingSetsDeleteSetBody,options
    );
  }



export const getTrainingSetsDeleteSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext> => {

const mutationKey = ['trainingSetsDeleteSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, {data: TrainingSetsDeleteSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsDeleteSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsDeleteSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsDeleteSet>>>
    export type TrainingSetsDeleteSetMutationBody = TrainingSetsDeleteSetBody
    export type TrainingSetsDeleteSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsDeleteSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsDeleteSet>>,
        TError,
        {data: TrainingSetsDeleteSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsDeleteSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsEditSet = (
    trainingSetsEditSetBody: MaybeRef<TrainingSetsEditSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsEditSetBody = unref(trainingSetsEditSetBody);
    
    return axios.post(
      `/trainingSets/editSet`,
      trainingSetsEditSetBody,options
    );
  }



export const getTrainingSetsEditSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext> => {

const mutationKey = ['trainingSetsEditSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsEditSet>>, {data: TrainingSetsEditSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsEditSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsEditSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsEditSet>>>
    export type TrainingSetsEditSetMutationBody = TrainingSetsEditSetBody
    export type TrainingSetsEditSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsEditSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsEditSet>>,
        TError,
        {data: TrainingSetsEditSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsEditSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsDescribeSet = (
    params: MaybeRef<TrainingSetsDescribeSetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsDescribeSet200>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/describeSet`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsDescribeSetQueryKey = (params: MaybeRef<TrainingSetsDescribeSetParams>,) => {
    return ['trainingSets','describeSet', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsDescribeSetQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsDescribeSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsDescribeSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsDescribeSet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsDescribeSetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsDescribeSet>>> = ({ signal }) => trainingSetsDescribeSet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsDescribeSet>>, TError, TData> 
}

export type TrainingSetsDescribeSetQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsDescribeSet>>>
export type TrainingSetsDescribeSetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsDescribeSet<TData = Awaited<ReturnType<typeof trainingSetsDescribeSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsDescribeSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsDescribeSet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsDescribeSetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const upvotesGetWallet = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesGetWallet200>> => {
    
    
    return axios.get(
      `/upvotes/getWallet`,options
    );
  }


export const getUpvotesGetWalletQueryKey = () => {
    return ['upvotes','getWallet'] as const;
    }

    
export const getUpvotesGetWalletQueryOptions = <TData = Awaited<ReturnType<typeof upvotesGetWallet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetWallet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUpvotesGetWalletQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof upvotesGetWallet>>> = ({ signal }) => upvotesGetWallet({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof upvotesGetWallet>>, TError, TData> 
}

export type UpvotesGetWalletQueryResult = NonNullable<Awaited<ReturnType<typeof upvotesGetWallet>>>
export type UpvotesGetWalletQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUpvotesGetWallet<TData = Awaited<ReturnType<typeof upvotesGetWallet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetWallet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUpvotesGetWalletQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const upvotesUpvote = (
    upvotesUpvoteBody: MaybeRef<UpvotesUpvoteBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesUpvote200>> => {
    upvotesUpvoteBody = unref(upvotesUpvoteBody);
    
    return axios.post(
      `/upvotes/upvote`,
      upvotesUpvoteBody,options
    );
  }



export const getUpvotesUpvoteMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesUpvote>>, TError,{data: UpvotesUpvoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof upvotesUpvote>>, TError,{data: UpvotesUpvoteBody}, TContext> => {

const mutationKey = ['upvotesUpvote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upvotesUpvote>>, {data: UpvotesUpvoteBody}> = (props) => {
          const {data} = props ?? {};

          return  upvotesUpvote(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpvotesUpvoteMutationResult = NonNullable<Awaited<ReturnType<typeof upvotesUpvote>>>
    export type UpvotesUpvoteMutationBody = UpvotesUpvoteBody
    export type UpvotesUpvoteMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUpvotesUpvote = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesUpvote>>, TError,{data: UpvotesUpvoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof upvotesUpvote>>,
        TError,
        {data: UpvotesUpvoteBody},
        TContext
      > => {

      const mutationOptions = getUpvotesUpvoteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const upvotesGetMediaUpvoteCount = (
    params?: MaybeRef<UpvotesGetMediaUpvoteCountParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesGetMediaUpvoteCount200>> => {
    params = unref(params);
    
    return axios.get(
      `/upvotes/getMediaUpvoteCount`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUpvotesGetMediaUpvoteCountQueryKey = (params?: MaybeRef<UpvotesGetMediaUpvoteCountParams>,) => {
    return ['upvotes','getMediaUpvoteCount', ...(params ? [params]: [])] as const;
    }

    
export const getUpvotesGetMediaUpvoteCountQueryOptions = <TData = Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UpvotesGetMediaUpvoteCountParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUpvotesGetMediaUpvoteCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>> = ({ signal }) => upvotesGetMediaUpvoteCount(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>, TError, TData> 
}

export type UpvotesGetMediaUpvoteCountQueryResult = NonNullable<Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>>
export type UpvotesGetMediaUpvoteCountQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUpvotesGetMediaUpvoteCount<TData = Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UpvotesGetMediaUpvoteCountParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetMediaUpvoteCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUpvotesGetMediaUpvoteCountQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const upvotesDownvote = (
    upvotesDownvoteBody: MaybeRef<UpvotesDownvoteBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesDownvote200>> => {
    upvotesDownvoteBody = unref(upvotesDownvoteBody);
    
    return axios.post(
      `/upvotes/downvote`,
      upvotesDownvoteBody,options
    );
  }



export const getUpvotesDownvoteMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesDownvote>>, TError,{data: UpvotesDownvoteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof upvotesDownvote>>, TError,{data: UpvotesDownvoteBody}, TContext> => {

const mutationKey = ['upvotesDownvote'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upvotesDownvote>>, {data: UpvotesDownvoteBody}> = (props) => {
          const {data} = props ?? {};

          return  upvotesDownvote(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpvotesDownvoteMutationResult = NonNullable<Awaited<ReturnType<typeof upvotesDownvote>>>
    export type UpvotesDownvoteMutationBody = UpvotesDownvoteBody
    export type UpvotesDownvoteMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUpvotesDownvote = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesDownvote>>, TError,{data: UpvotesDownvoteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof upvotesDownvote>>,
        TError,
        {data: UpvotesDownvoteBody},
        TContext
      > => {

      const mutationOptions = getUpvotesDownvoteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const upvotesUnhide = (
    upvotesUnhideBody: MaybeRef<UpvotesUnhideBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesUnhide200>> => {
    upvotesUnhideBody = unref(upvotesUnhideBody);
    
    return axios.post(
      `/upvotes/unhide`,
      upvotesUnhideBody,options
    );
  }



export const getUpvotesUnhideMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesUnhide>>, TError,{data: UpvotesUnhideBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof upvotesUnhide>>, TError,{data: UpvotesUnhideBody}, TContext> => {

const mutationKey = ['upvotesUnhide'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof upvotesUnhide>>, {data: UpvotesUnhideBody}> = (props) => {
          const {data} = props ?? {};

          return  upvotesUnhide(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpvotesUnhideMutationResult = NonNullable<Awaited<ReturnType<typeof upvotesUnhide>>>
    export type UpvotesUnhideMutationBody = UpvotesUnhideBody
    export type UpvotesUnhideMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUpvotesUnhide = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof upvotesUnhide>>, TError,{data: UpvotesUnhideBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof upvotesUnhide>>,
        TError,
        {data: UpvotesUnhideBody},
        TContext
      > => {

      const mutationOptions = getUpvotesUnhideMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const upvotesGetHiddenList = (
    params?: MaybeRef<UpvotesGetHiddenListParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UpvotesGetHiddenList200>> => {
    params = unref(params);
    
    return axios.get(
      `/upvotes/getHiddenList`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUpvotesGetHiddenListQueryKey = (params?: MaybeRef<UpvotesGetHiddenListParams>,) => {
    return ['upvotes','getHiddenList', ...(params ? [params]: [])] as const;
    }

    
export const getUpvotesGetHiddenListQueryOptions = <TData = Awaited<ReturnType<typeof upvotesGetHiddenList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UpvotesGetHiddenListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetHiddenList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUpvotesGetHiddenListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof upvotesGetHiddenList>>> = ({ signal }) => upvotesGetHiddenList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof upvotesGetHiddenList>>, TError, TData> 
}

export type UpvotesGetHiddenListQueryResult = NonNullable<Awaited<ReturnType<typeof upvotesGetHiddenList>>>
export type UpvotesGetHiddenListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUpvotesGetHiddenList<TData = Awaited<ReturnType<typeof upvotesGetHiddenList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UpvotesGetHiddenListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof upvotesGetHiddenList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUpvotesGetHiddenListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const popularityBatch = (
    popularityBatchBody: MaybeRef<PopularityBatchBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PopularityBatch200Item[]>> => {
    popularityBatchBody = unref(popularityBatchBody);
    
    return axios.post(
      `/popularity/batch`,
      popularityBatchBody,options
    );
  }



export const getPopularityBatchMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof popularityBatch>>, TError,{data: PopularityBatchBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof popularityBatch>>, TError,{data: PopularityBatchBody}, TContext> => {

const mutationKey = ['popularityBatch'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof popularityBatch>>, {data: PopularityBatchBody}> = (props) => {
          const {data} = props ?? {};

          return  popularityBatch(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PopularityBatchMutationResult = NonNullable<Awaited<ReturnType<typeof popularityBatch>>>
    export type PopularityBatchMutationBody = PopularityBatchBody
    export type PopularityBatchMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePopularityBatch = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof popularityBatch>>, TError,{data: PopularityBatchBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof popularityBatch>>,
        TError,
        {data: PopularityBatchBody},
        TContext
      > => {

      const mutationOptions = getPopularityBatchMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const eventsPublicEvents = (
    params?: MaybeRef<EventsPublicEventsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventsPublicEvents200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/events/publicEvents`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getEventsPublicEventsQueryKey = (params?: MaybeRef<EventsPublicEventsParams>,) => {
    return ['events','publicEvents', ...(params ? [params]: [])] as const;
    }

    
export const getEventsPublicEventsQueryOptions = <TData = Awaited<ReturnType<typeof eventsPublicEvents>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<EventsPublicEventsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsPublicEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getEventsPublicEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsPublicEvents>>> = ({ signal }) => eventsPublicEvents(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventsPublicEvents>>, TError, TData> 
}

export type EventsPublicEventsQueryResult = NonNullable<Awaited<ReturnType<typeof eventsPublicEvents>>>
export type EventsPublicEventsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useEventsPublicEvents<TData = Awaited<ReturnType<typeof eventsPublicEvents>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<EventsPublicEventsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsPublicEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventsPublicEventsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const eventsPrivateEvents = (
    params?: MaybeRef<EventsPrivateEventsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<EventsPrivateEvents200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/events/privateEvents`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getEventsPrivateEventsQueryKey = (params?: MaybeRef<EventsPrivateEventsParams>,) => {
    return ['events','privateEvents', ...(params ? [params]: [])] as const;
    }

    
export const getEventsPrivateEventsQueryOptions = <TData = Awaited<ReturnType<typeof eventsPrivateEvents>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<EventsPrivateEventsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsPrivateEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getEventsPrivateEventsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof eventsPrivateEvents>>> = ({ signal }) => eventsPrivateEvents(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof eventsPrivateEvents>>, TError, TData> 
}

export type EventsPrivateEventsQueryResult = NonNullable<Awaited<ReturnType<typeof eventsPrivateEvents>>>
export type EventsPrivateEventsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useEventsPrivateEvents<TData = Awaited<ReturnType<typeof eventsPrivateEvents>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<EventsPrivateEventsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof eventsPrivateEvents>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getEventsPrivateEventsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const eventsMarkEventSeen = (
    eventsMarkEventSeenBody: MaybeRef<EventsMarkEventSeenBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    eventsMarkEventSeenBody = unref(eventsMarkEventSeenBody);
    
    return axios.post(
      `/events/markEventSeen`,
      eventsMarkEventSeenBody,options
    );
  }



export const getEventsMarkEventSeenMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventsMarkEventSeen>>, TError,{data: EventsMarkEventSeenBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof eventsMarkEventSeen>>, TError,{data: EventsMarkEventSeenBody}, TContext> => {

const mutationKey = ['eventsMarkEventSeen'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof eventsMarkEventSeen>>, {data: EventsMarkEventSeenBody}> = (props) => {
          const {data} = props ?? {};

          return  eventsMarkEventSeen(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type EventsMarkEventSeenMutationResult = NonNullable<Awaited<ReturnType<typeof eventsMarkEventSeen>>>
    export type EventsMarkEventSeenMutationBody = EventsMarkEventSeenBody
    export type EventsMarkEventSeenMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useEventsMarkEventSeen = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof eventsMarkEventSeen>>, TError,{data: EventsMarkEventSeenBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof eventsMarkEventSeen>>,
        TError,
        {data: EventsMarkEventSeenBody},
        TContext
      > => {

      const mutationOptions = getEventsMarkEventSeenMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const missionsList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsList200Item[]>> => {
    
    
    return axios.get(
      `/missions/list`,options
    );
  }


export const getMissionsListQueryKey = () => {
    return ['missions','list'] as const;
    }

    
export const getMissionsListQueryOptions = <TData = Awaited<ReturnType<typeof missionsList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getMissionsListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof missionsList>>> = ({ signal }) => missionsList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof missionsList>>, TError, TData> 
}

export type MissionsListQueryResult = NonNullable<Awaited<ReturnType<typeof missionsList>>>
export type MissionsListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useMissionsList<TData = Awaited<ReturnType<typeof missionsList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMissionsListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const missionsProgress = (
    params: MaybeRef<MissionsProgressParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsProgress200>> => {
    params = unref(params);
    
    return axios.get(
      `/missions/progress`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getMissionsProgressQueryKey = (params: MaybeRef<MissionsProgressParams>,) => {
    return ['missions','progress', ...(params ? [params]: [])] as const;
    }

    
export const getMissionsProgressQueryOptions = <TData = Awaited<ReturnType<typeof missionsProgress>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<MissionsProgressParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsProgress>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getMissionsProgressQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof missionsProgress>>> = ({ signal }) => missionsProgress(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof missionsProgress>>, TError, TData> 
}

export type MissionsProgressQueryResult = NonNullable<Awaited<ReturnType<typeof missionsProgress>>>
export type MissionsProgressQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useMissionsProgress<TData = Awaited<ReturnType<typeof missionsProgress>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<MissionsProgressParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsProgress>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMissionsProgressQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const missionsIsClaimed = (
    params: MaybeRef<MissionsIsClaimedParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsIsClaimed200>> => {
    params = unref(params);
    
    return axios.get(
      `/missions/isClaimed`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getMissionsIsClaimedQueryKey = (params: MaybeRef<MissionsIsClaimedParams>,) => {
    return ['missions','isClaimed', ...(params ? [params]: [])] as const;
    }

    
export const getMissionsIsClaimedQueryOptions = <TData = Awaited<ReturnType<typeof missionsIsClaimed>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<MissionsIsClaimedParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsIsClaimed>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getMissionsIsClaimedQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof missionsIsClaimed>>> = ({ signal }) => missionsIsClaimed(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof missionsIsClaimed>>, TError, TData> 
}

export type MissionsIsClaimedQueryResult = NonNullable<Awaited<ReturnType<typeof missionsIsClaimed>>>
export type MissionsIsClaimedQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useMissionsIsClaimed<TData = Awaited<ReturnType<typeof missionsIsClaimed>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<MissionsIsClaimedParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsIsClaimed>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMissionsIsClaimedQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const missionsClaim = (
    missionsClaimBody: MaybeRef<MissionsClaimBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsClaim200>> => {
    missionsClaimBody = unref(missionsClaimBody);
    
    return axios.post(
      `/missions/claim`,
      missionsClaimBody,options
    );
  }



export const getMissionsClaimMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof missionsClaim>>, TError,{data: MissionsClaimBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof missionsClaim>>, TError,{data: MissionsClaimBody}, TContext> => {

const mutationKey = ['missionsClaim'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof missionsClaim>>, {data: MissionsClaimBody}> = (props) => {
          const {data} = props ?? {};

          return  missionsClaim(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MissionsClaimMutationResult = NonNullable<Awaited<ReturnType<typeof missionsClaim>>>
    export type MissionsClaimMutationBody = MissionsClaimBody
    export type MissionsClaimMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMissionsClaim = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof missionsClaim>>, TError,{data: MissionsClaimBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof missionsClaim>>,
        TError,
        {data: MissionsClaimBody},
        TContext
      > => {

      const mutationOptions = getMissionsClaimMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const missionsStatus = (
    params: MaybeRef<MissionsStatusParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsStatus200>> => {
    params = unref(params);
    
    return axios.get(
      `/missions/status`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getMissionsStatusQueryKey = (params: MaybeRef<MissionsStatusParams>,) => {
    return ['missions','status', ...(params ? [params]: [])] as const;
    }

    
export const getMissionsStatusQueryOptions = <TData = Awaited<ReturnType<typeof missionsStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<MissionsStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getMissionsStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof missionsStatus>>> = ({ signal }) => missionsStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof missionsStatus>>, TError, TData> 
}

export type MissionsStatusQueryResult = NonNullable<Awaited<ReturnType<typeof missionsStatus>>>
export type MissionsStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useMissionsStatus<TData = Awaited<ReturnType<typeof missionsStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<MissionsStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMissionsStatusQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const missionsStatuses = (
    params?: MaybeRef<MissionsStatusesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MissionsStatuses200>> => {
    params = unref(params);
    
    return axios.get(
      `/missions/statuses`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getMissionsStatusesQueryKey = (params?: MaybeRef<MissionsStatusesParams>,) => {
    return ['missions','statuses', ...(params ? [params]: [])] as const;
    }

    
export const getMissionsStatusesQueryOptions = <TData = Awaited<ReturnType<typeof missionsStatuses>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<MissionsStatusesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsStatuses>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getMissionsStatusesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof missionsStatuses>>> = ({ signal }) => missionsStatuses(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof missionsStatuses>>, TError, TData> 
}

export type MissionsStatusesQueryResult = NonNullable<Awaited<ReturnType<typeof missionsStatuses>>>
export type MissionsStatusesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useMissionsStatuses<TData = Awaited<ReturnType<typeof missionsStatuses>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<MissionsStatusesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof missionsStatuses>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getMissionsStatusesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const badgesList = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BadgesList200Item[]>> => {
    
    
    return axios.get(
      `/badges/list`,options
    );
  }


export const getBadgesListQueryKey = () => {
    return ['badges','list'] as const;
    }

    
export const getBadgesListQueryOptions = <TData = Awaited<ReturnType<typeof badgesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof badgesList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getBadgesListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof badgesList>>> = ({ signal }) => badgesList({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof badgesList>>, TError, TData> 
}

export type BadgesListQueryResult = NonNullable<Awaited<ReturnType<typeof badgesList>>>
export type BadgesListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useBadgesList<TData = Awaited<ReturnType<typeof badgesList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof badgesList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBadgesListQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const badgesForUser = (
    params?: MaybeRef<BadgesForUserParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<BadgesForUser200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/badges/forUser`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getBadgesForUserQueryKey = (params?: MaybeRef<BadgesForUserParams>,) => {
    return ['badges','forUser', ...(params ? [params]: [])] as const;
    }

    
export const getBadgesForUserQueryOptions = <TData = Awaited<ReturnType<typeof badgesForUser>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<BadgesForUserParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof badgesForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getBadgesForUserQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof badgesForUser>>> = ({ signal }) => badgesForUser(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof badgesForUser>>, TError, TData> 
}

export type BadgesForUserQueryResult = NonNullable<Awaited<ReturnType<typeof badgesForUser>>>
export type BadgesForUserQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useBadgesForUser<TData = Awaited<ReturnType<typeof badgesForUser>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<BadgesForUserParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof badgesForUser>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getBadgesForUserQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const telegramPackages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramPackages200Item[]>> => {
    
    
    return axios.get(
      `/telegram/packages`,options
    );
  }


export const getTelegramPackagesQueryKey = () => {
    return ['telegram','packages'] as const;
    }

    
export const getTelegramPackagesQueryOptions = <TData = Awaited<ReturnType<typeof telegramPackages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTelegramPackagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof telegramPackages>>> = ({ signal }) => telegramPackages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof telegramPackages>>, TError, TData> 
}

export type TelegramPackagesQueryResult = NonNullable<Awaited<ReturnType<typeof telegramPackages>>>
export type TelegramPackagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTelegramPackages<TData = Awaited<ReturnType<typeof telegramPackages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramPackages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTelegramPackagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const telegramCreateDeepLink = (
    telegramCreateDeepLinkBody?: MaybeRef<TelegramCreateDeepLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramCreateDeepLink200>> => {
    telegramCreateDeepLinkBody = unref(telegramCreateDeepLinkBody);
    
    return axios.post(
      `/telegram/createDeepLink`,
      telegramCreateDeepLinkBody,options
    );
  }



export const getTelegramCreateDeepLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeepLink>>, TError,{data: TelegramCreateDeepLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeepLink>>, TError,{data: TelegramCreateDeepLinkBody}, TContext> => {

const mutationKey = ['telegramCreateDeepLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramCreateDeepLink>>, {data: TelegramCreateDeepLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramCreateDeepLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramCreateDeepLinkMutationResult = NonNullable<Awaited<ReturnType<typeof telegramCreateDeepLink>>>
    export type TelegramCreateDeepLinkMutationBody = TelegramCreateDeepLinkBody
    export type TelegramCreateDeepLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramCreateDeepLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeepLink>>, TError,{data: TelegramCreateDeepLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramCreateDeepLink>>,
        TError,
        {data: TelegramCreateDeepLinkBody},
        TContext
      > => {

      const mutationOptions = getTelegramCreateDeepLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramCreateBuyDeepLink = (
    telegramCreateBuyDeepLinkBody: MaybeRef<TelegramCreateBuyDeepLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramCreateBuyDeepLink200>> => {
    telegramCreateBuyDeepLinkBody = unref(telegramCreateBuyDeepLinkBody);
    
    return axios.post(
      `/telegram/createBuyDeepLink`,
      telegramCreateBuyDeepLinkBody,options
    );
  }



export const getTelegramCreateBuyDeepLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>, TError,{data: TelegramCreateBuyDeepLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>, TError,{data: TelegramCreateBuyDeepLinkBody}, TContext> => {

const mutationKey = ['telegramCreateBuyDeepLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>, {data: TelegramCreateBuyDeepLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramCreateBuyDeepLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramCreateBuyDeepLinkMutationResult = NonNullable<Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>>
    export type TelegramCreateBuyDeepLinkMutationBody = TelegramCreateBuyDeepLinkBody
    export type TelegramCreateBuyDeepLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramCreateBuyDeepLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>, TError,{data: TelegramCreateBuyDeepLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramCreateBuyDeepLink>>,
        TError,
        {data: TelegramCreateBuyDeepLinkBody},
        TContext
      > => {

      const mutationOptions = getTelegramCreateBuyDeepLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramCreateStarsInvoice = (
    telegramCreateStarsInvoiceBody: MaybeRef<TelegramCreateStarsInvoiceBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramCreateStarsInvoice200>> => {
    telegramCreateStarsInvoiceBody = unref(telegramCreateStarsInvoiceBody);
    
    return axios.post(
      `/telegram/createStarsInvoice`,
      telegramCreateStarsInvoiceBody,options
    );
  }



export const getTelegramCreateStarsInvoiceMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateStarsInvoice>>, TError,{data: TelegramCreateStarsInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramCreateStarsInvoice>>, TError,{data: TelegramCreateStarsInvoiceBody}, TContext> => {

const mutationKey = ['telegramCreateStarsInvoice'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramCreateStarsInvoice>>, {data: TelegramCreateStarsInvoiceBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramCreateStarsInvoice(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramCreateStarsInvoiceMutationResult = NonNullable<Awaited<ReturnType<typeof telegramCreateStarsInvoice>>>
    export type TelegramCreateStarsInvoiceMutationBody = TelegramCreateStarsInvoiceBody
    export type TelegramCreateStarsInvoiceMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramCreateStarsInvoice = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateStarsInvoice>>, TError,{data: TelegramCreateStarsInvoiceBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramCreateStarsInvoice>>,
        TError,
        {data: TelegramCreateStarsInvoiceBody},
        TContext
      > => {

      const mutationOptions = getTelegramCreateStarsInvoiceMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramWebAppLogin = (
    telegramWebAppLoginBody: MaybeRef<TelegramWebAppLoginBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramWebAppLogin200>> => {
    telegramWebAppLoginBody = unref(telegramWebAppLoginBody);
    
    return axios.post(
      `/telegram/webAppLogin`,
      telegramWebAppLoginBody,options
    );
  }



export const getTelegramWebAppLoginMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramWebAppLogin>>, TError,{data: TelegramWebAppLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramWebAppLogin>>, TError,{data: TelegramWebAppLoginBody}, TContext> => {

const mutationKey = ['telegramWebAppLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramWebAppLogin>>, {data: TelegramWebAppLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramWebAppLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramWebAppLoginMutationResult = NonNullable<Awaited<ReturnType<typeof telegramWebAppLogin>>>
    export type TelegramWebAppLoginMutationBody = TelegramWebAppLoginBody
    export type TelegramWebAppLoginMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramWebAppLogin = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramWebAppLogin>>, TError,{data: TelegramWebAppLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramWebAppLogin>>,
        TError,
        {data: TelegramWebAppLoginBody},
        TContext
      > => {

      const mutationOptions = getTelegramWebAppLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramCheckWebAppLink = (
    params: MaybeRef<TelegramCheckWebAppLinkParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramCheckWebAppLink200>> => {
    params = unref(params);
    
    return axios.get(
      `/telegram/checkWebAppLink`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTelegramCheckWebAppLinkQueryKey = (params: MaybeRef<TelegramCheckWebAppLinkParams>,) => {
    return ['telegram','checkWebAppLink', ...(params ? [params]: [])] as const;
    }

    
export const getTelegramCheckWebAppLinkQueryOptions = <TData = Awaited<ReturnType<typeof telegramCheckWebAppLink>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TelegramCheckWebAppLinkParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramCheckWebAppLink>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTelegramCheckWebAppLinkQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof telegramCheckWebAppLink>>> = ({ signal }) => telegramCheckWebAppLink(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof telegramCheckWebAppLink>>, TError, TData> 
}

export type TelegramCheckWebAppLinkQueryResult = NonNullable<Awaited<ReturnType<typeof telegramCheckWebAppLink>>>
export type TelegramCheckWebAppLinkQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTelegramCheckWebAppLink<TData = Awaited<ReturnType<typeof telegramCheckWebAppLink>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TelegramCheckWebAppLinkParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramCheckWebAppLink>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTelegramCheckWebAppLinkQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const telegramLinkStatus = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramLinkStatus200>> => {
    
    
    return axios.get(
      `/telegram/linkStatus`,options
    );
  }


export const getTelegramLinkStatusQueryKey = () => {
    return ['telegram','linkStatus'] as const;
    }

    
export const getTelegramLinkStatusQueryOptions = <TData = Awaited<ReturnType<typeof telegramLinkStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramLinkStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTelegramLinkStatusQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof telegramLinkStatus>>> = ({ signal }) => telegramLinkStatus({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof telegramLinkStatus>>, TError, TData> 
}

export type TelegramLinkStatusQueryResult = NonNullable<Awaited<ReturnType<typeof telegramLinkStatus>>>
export type TelegramLinkStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTelegramLinkStatus<TData = Awaited<ReturnType<typeof telegramLinkStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof telegramLinkStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTelegramLinkStatusQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const telegramCreateDeviceLogin = (
    telegramCreateDeviceLoginBody?: MaybeRef<TelegramCreateDeviceLoginBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramCreateDeviceLogin200>> => {
    telegramCreateDeviceLoginBody = unref(telegramCreateDeviceLoginBody);
    
    return axios.post(
      `/telegram/createDeviceLogin`,
      telegramCreateDeviceLoginBody,options
    );
  }



export const getTelegramCreateDeviceLoginMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeviceLogin>>, TError,{data: TelegramCreateDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeviceLogin>>, TError,{data: TelegramCreateDeviceLoginBody}, TContext> => {

const mutationKey = ['telegramCreateDeviceLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramCreateDeviceLogin>>, {data: TelegramCreateDeviceLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramCreateDeviceLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramCreateDeviceLoginMutationResult = NonNullable<Awaited<ReturnType<typeof telegramCreateDeviceLogin>>>
    export type TelegramCreateDeviceLoginMutationBody = TelegramCreateDeviceLoginBody
    export type TelegramCreateDeviceLoginMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramCreateDeviceLogin = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramCreateDeviceLogin>>, TError,{data: TelegramCreateDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramCreateDeviceLogin>>,
        TError,
        {data: TelegramCreateDeviceLoginBody},
        TContext
      > => {

      const mutationOptions = getTelegramCreateDeviceLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramExchangeDeviceLogin = (
    telegramExchangeDeviceLoginBody: MaybeRef<TelegramExchangeDeviceLoginBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramExchangeDeviceLogin200>> => {
    telegramExchangeDeviceLoginBody = unref(telegramExchangeDeviceLoginBody);
    
    return axios.post(
      `/telegram/exchangeDeviceLogin`,
      telegramExchangeDeviceLoginBody,options
    );
  }



export const getTelegramExchangeDeviceLoginMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>, TError,{data: TelegramExchangeDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>, TError,{data: TelegramExchangeDeviceLoginBody}, TContext> => {

const mutationKey = ['telegramExchangeDeviceLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>, {data: TelegramExchangeDeviceLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramExchangeDeviceLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramExchangeDeviceLoginMutationResult = NonNullable<Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>>
    export type TelegramExchangeDeviceLoginMutationBody = TelegramExchangeDeviceLoginBody
    export type TelegramExchangeDeviceLoginMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramExchangeDeviceLogin = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>, TError,{data: TelegramExchangeDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramExchangeDeviceLogin>>,
        TError,
        {data: TelegramExchangeDeviceLoginBody},
        TContext
      > => {

      const mutationOptions = getTelegramExchangeDeviceLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramConfirmDeviceLogin = (
    telegramConfirmDeviceLoginBody: MaybeRef<TelegramConfirmDeviceLoginBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramConfirmDeviceLogin200>> => {
    telegramConfirmDeviceLoginBody = unref(telegramConfirmDeviceLoginBody);
    
    return axios.post(
      `/telegram/confirmDeviceLogin`,
      telegramConfirmDeviceLoginBody,options
    );
  }



export const getTelegramConfirmDeviceLoginMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>, TError,{data: TelegramConfirmDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>, TError,{data: TelegramConfirmDeviceLoginBody}, TContext> => {

const mutationKey = ['telegramConfirmDeviceLogin'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>, {data: TelegramConfirmDeviceLoginBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramConfirmDeviceLogin(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramConfirmDeviceLoginMutationResult = NonNullable<Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>>
    export type TelegramConfirmDeviceLoginMutationBody = TelegramConfirmDeviceLoginBody
    export type TelegramConfirmDeviceLoginMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramConfirmDeviceLogin = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>, TError,{data: TelegramConfirmDeviceLoginBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramConfirmDeviceLogin>>,
        TError,
        {data: TelegramConfirmDeviceLoginBody},
        TContext
      > => {

      const mutationOptions = getTelegramConfirmDeviceLoginMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const telegramUnlink = (
    telegramUnlinkBody?: MaybeRef<TelegramUnlinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TelegramUnlink200>> => {
    telegramUnlinkBody = unref(telegramUnlinkBody);
    
    return axios.post(
      `/telegram/unlink`,
      telegramUnlinkBody,options
    );
  }



export const getTelegramUnlinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramUnlink>>, TError,{data: TelegramUnlinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof telegramUnlink>>, TError,{data: TelegramUnlinkBody}, TContext> => {

const mutationKey = ['telegramUnlink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof telegramUnlink>>, {data: TelegramUnlinkBody}> = (props) => {
          const {data} = props ?? {};

          return  telegramUnlink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TelegramUnlinkMutationResult = NonNullable<Awaited<ReturnType<typeof telegramUnlink>>>
    export type TelegramUnlinkMutationBody = TelegramUnlinkBody
    export type TelegramUnlinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTelegramUnlink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof telegramUnlink>>, TError,{data: TelegramUnlinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof telegramUnlink>>,
        TError,
        {data: TelegramUnlinkBody},
        TContext
      > => {

      const mutationOptions = getTelegramUnlinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const discountsValidate = (
    params: MaybeRef<DiscountsValidateParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DiscountsValidate200>> => {
    params = unref(params);
    
    return axios.get(
      `/discounts/validate`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getDiscountsValidateQueryKey = (params: MaybeRef<DiscountsValidateParams>,) => {
    return ['discounts','validate', ...(params ? [params]: [])] as const;
    }

    
export const getDiscountsValidateQueryOptions = <TData = Awaited<ReturnType<typeof discountsValidate>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<DiscountsValidateParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof discountsValidate>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getDiscountsValidateQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof discountsValidate>>> = ({ signal }) => discountsValidate(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof discountsValidate>>, TError, TData> 
}

export type DiscountsValidateQueryResult = NonNullable<Awaited<ReturnType<typeof discountsValidate>>>
export type DiscountsValidateQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useDiscountsValidate<TData = Awaited<ReturnType<typeof discountsValidate>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<DiscountsValidateParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof discountsValidate>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDiscountsValidateQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const discountsMyCodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DiscountsMyCodes200Item[]>> => {
    
    
    return axios.get(
      `/discounts/myCodes`,options
    );
  }


export const getDiscountsMyCodesQueryKey = () => {
    return ['discounts','myCodes'] as const;
    }

    
export const getDiscountsMyCodesQueryOptions = <TData = Awaited<ReturnType<typeof discountsMyCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof discountsMyCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getDiscountsMyCodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof discountsMyCodes>>> = ({ signal }) => discountsMyCodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof discountsMyCodes>>, TError, TData> 
}

export type DiscountsMyCodesQueryResult = NonNullable<Awaited<ReturnType<typeof discountsMyCodes>>>
export type DiscountsMyCodesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useDiscountsMyCodes<TData = Awaited<ReturnType<typeof discountsMyCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof discountsMyCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getDiscountsMyCodesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const commentsCount = (
    params?: MaybeRef<CommentsCountParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentsCount200>> => {
    params = unref(params);
    
    return axios.get(
      `/comments/count`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCommentsCountQueryKey = (params?: MaybeRef<CommentsCountParams>,) => {
    return ['comments','count', ...(params ? [params]: [])] as const;
    }

    
export const getCommentsCountQueryOptions = <TData = Awaited<ReturnType<typeof commentsCount>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CommentsCountParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsCount>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCommentsCountQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof commentsCount>>> = ({ signal }) => commentsCount(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof commentsCount>>, TError, TData> 
}

export type CommentsCountQueryResult = NonNullable<Awaited<ReturnType<typeof commentsCount>>>
export type CommentsCountQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCommentsCount<TData = Awaited<ReturnType<typeof commentsCount>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CommentsCountParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsCount>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCommentsCountQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const commentsList = (
    params?: MaybeRef<CommentsListParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentsList200>> => {
    params = unref(params);
    
    return axios.get(
      `/comments/list`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCommentsListQueryKey = (params?: MaybeRef<CommentsListParams>,) => {
    return ['comments','list', ...(params ? [params]: [])] as const;
    }

    
export const getCommentsListQueryOptions = <TData = Awaited<ReturnType<typeof commentsList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CommentsListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsList>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCommentsListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof commentsList>>> = ({ signal }) => commentsList(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof commentsList>>, TError, TData> 
}

export type CommentsListQueryResult = NonNullable<Awaited<ReturnType<typeof commentsList>>>
export type CommentsListQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCommentsList<TData = Awaited<ReturnType<typeof commentsList>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CommentsListParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof commentsList>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCommentsListQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const commentsCreate = (
    commentsCreateBody: MaybeRef<CommentsCreateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentsCreate200>> => {
    commentsCreateBody = unref(commentsCreateBody);
    
    return axios.post(
      `/comments/create`,
      commentsCreateBody,options
    );
  }



export const getCommentsCreateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsCreate>>, TError,{data: CommentsCreateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof commentsCreate>>, TError,{data: CommentsCreateBody}, TContext> => {

const mutationKey = ['commentsCreate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsCreate>>, {data: CommentsCreateBody}> = (props) => {
          const {data} = props ?? {};

          return  commentsCreate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsCreateMutationResult = NonNullable<Awaited<ReturnType<typeof commentsCreate>>>
    export type CommentsCreateMutationBody = CommentsCreateBody
    export type CommentsCreateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCommentsCreate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsCreate>>, TError,{data: CommentsCreateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof commentsCreate>>,
        TError,
        {data: CommentsCreateBody},
        TContext
      > => {

      const mutationOptions = getCommentsCreateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const commentsEdit = (
    commentsEditBody: MaybeRef<CommentsEditBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentsEdit200>> => {
    commentsEditBody = unref(commentsEditBody);
    
    return axios.post(
      `/comments/edit`,
      commentsEditBody,options
    );
  }



export const getCommentsEditMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsEdit>>, TError,{data: CommentsEditBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof commentsEdit>>, TError,{data: CommentsEditBody}, TContext> => {

const mutationKey = ['commentsEdit'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsEdit>>, {data: CommentsEditBody}> = (props) => {
          const {data} = props ?? {};

          return  commentsEdit(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsEditMutationResult = NonNullable<Awaited<ReturnType<typeof commentsEdit>>>
    export type CommentsEditMutationBody = CommentsEditBody
    export type CommentsEditMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCommentsEdit = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsEdit>>, TError,{data: CommentsEditBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof commentsEdit>>,
        TError,
        {data: CommentsEditBody},
        TContext
      > => {

      const mutationOptions = getCommentsEditMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const commentsDelete = (
    commentsDeleteBody: MaybeRef<CommentsDeleteBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CommentsDelete200>> => {
    commentsDeleteBody = unref(commentsDeleteBody);
    
    return axios.post(
      `/comments/delete`,
      commentsDeleteBody,options
    );
  }



export const getCommentsDeleteMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsDelete>>, TError,{data: CommentsDeleteBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof commentsDelete>>, TError,{data: CommentsDeleteBody}, TContext> => {

const mutationKey = ['commentsDelete'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof commentsDelete>>, {data: CommentsDeleteBody}> = (props) => {
          const {data} = props ?? {};

          return  commentsDelete(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CommentsDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof commentsDelete>>>
    export type CommentsDeleteMutationBody = CommentsDeleteBody
    export type CommentsDeleteMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCommentsDelete = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof commentsDelete>>, TError,{data: CommentsDeleteBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof commentsDelete>>,
        TError,
        {data: CommentsDeleteBody},
        TContext
      > => {

      const mutationOptions = getCommentsDeleteMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const tiktokCompleteRegistration = (
    tiktokCompleteRegistrationBody: MaybeRef<TiktokCompleteRegistrationBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TiktokCompleteRegistration200>> => {
    tiktokCompleteRegistrationBody = unref(tiktokCompleteRegistrationBody);
    
    return axios.post(
      `/tiktok/completeRegistration`,
      tiktokCompleteRegistrationBody,options
    );
  }



export const getTiktokCompleteRegistrationMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tiktokCompleteRegistration>>, TError,{data: TiktokCompleteRegistrationBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof tiktokCompleteRegistration>>, TError,{data: TiktokCompleteRegistrationBody}, TContext> => {

const mutationKey = ['tiktokCompleteRegistration'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof tiktokCompleteRegistration>>, {data: TiktokCompleteRegistrationBody}> = (props) => {
          const {data} = props ?? {};

          return  tiktokCompleteRegistration(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TiktokCompleteRegistrationMutationResult = NonNullable<Awaited<ReturnType<typeof tiktokCompleteRegistration>>>
    export type TiktokCompleteRegistrationMutationBody = TiktokCompleteRegistrationBody
    export type TiktokCompleteRegistrationMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTiktokCompleteRegistration = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof tiktokCompleteRegistration>>, TError,{data: TiktokCompleteRegistrationBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof tiktokCompleteRegistration>>,
        TError,
        {data: TiktokCompleteRegistrationBody},
        TContext
      > => {

      const mutationOptions = getTiktokCompleteRegistrationMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingAddToCart = (
    marketingAddToCartBody: MaybeRef<MarketingAddToCartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingAddToCart200>> => {
    marketingAddToCartBody = unref(marketingAddToCartBody);
    
    return axios.post(
      `/marketing/addToCart`,
      marketingAddToCartBody,options
    );
  }



export const getMarketingAddToCartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingAddToCart>>, TError,{data: MarketingAddToCartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingAddToCart>>, TError,{data: MarketingAddToCartBody}, TContext> => {

const mutationKey = ['marketingAddToCart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingAddToCart>>, {data: MarketingAddToCartBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingAddToCart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingAddToCartMutationResult = NonNullable<Awaited<ReturnType<typeof marketingAddToCart>>>
    export type MarketingAddToCartMutationBody = MarketingAddToCartBody
    export type MarketingAddToCartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingAddToCart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingAddToCart>>, TError,{data: MarketingAddToCartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingAddToCart>>,
        TError,
        {data: MarketingAddToCartBody},
        TContext
      > => {

      const mutationOptions = getMarketingAddToCartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingInitiateCheckout = (
    marketingInitiateCheckoutBody: MaybeRef<MarketingInitiateCheckoutBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingInitiateCheckout200>> => {
    marketingInitiateCheckoutBody = unref(marketingInitiateCheckoutBody);
    
    return axios.post(
      `/marketing/initiateCheckout`,
      marketingInitiateCheckoutBody,options
    );
  }



export const getMarketingInitiateCheckoutMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingInitiateCheckout>>, TError,{data: MarketingInitiateCheckoutBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingInitiateCheckout>>, TError,{data: MarketingInitiateCheckoutBody}, TContext> => {

const mutationKey = ['marketingInitiateCheckout'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingInitiateCheckout>>, {data: MarketingInitiateCheckoutBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingInitiateCheckout(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingInitiateCheckoutMutationResult = NonNullable<Awaited<ReturnType<typeof marketingInitiateCheckout>>>
    export type MarketingInitiateCheckoutMutationBody = MarketingInitiateCheckoutBody
    export type MarketingInitiateCheckoutMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingInitiateCheckout = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingInitiateCheckout>>, TError,{data: MarketingInitiateCheckoutBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingInitiateCheckout>>,
        TError,
        {data: MarketingInitiateCheckoutBody},
        TContext
      > => {

      const mutationOptions = getMarketingInitiateCheckoutMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingCreateImageStart = (
    marketingCreateImageStartBody: MaybeRef<MarketingCreateImageStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingCreateImageStart200>> => {
    marketingCreateImageStartBody = unref(marketingCreateImageStartBody);
    
    return axios.post(
      `/marketing/createImageStart`,
      marketingCreateImageStartBody,options
    );
  }



export const getMarketingCreateImageStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageStart>>, TError,{data: MarketingCreateImageStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageStart>>, TError,{data: MarketingCreateImageStartBody}, TContext> => {

const mutationKey = ['marketingCreateImageStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingCreateImageStart>>, {data: MarketingCreateImageStartBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingCreateImageStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingCreateImageStartMutationResult = NonNullable<Awaited<ReturnType<typeof marketingCreateImageStart>>>
    export type MarketingCreateImageStartMutationBody = MarketingCreateImageStartBody
    export type MarketingCreateImageStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingCreateImageStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageStart>>, TError,{data: MarketingCreateImageStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingCreateImageStart>>,
        TError,
        {data: MarketingCreateImageStartBody},
        TContext
      > => {

      const mutationOptions = getMarketingCreateImageStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingCreateImageSuccess = (
    marketingCreateImageSuccessBody: MaybeRef<MarketingCreateImageSuccessBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingCreateImageSuccess200>> => {
    marketingCreateImageSuccessBody = unref(marketingCreateImageSuccessBody);
    
    return axios.post(
      `/marketing/createImageSuccess`,
      marketingCreateImageSuccessBody,options
    );
  }



export const getMarketingCreateImageSuccessMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageSuccess>>, TError,{data: MarketingCreateImageSuccessBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageSuccess>>, TError,{data: MarketingCreateImageSuccessBody}, TContext> => {

const mutationKey = ['marketingCreateImageSuccess'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingCreateImageSuccess>>, {data: MarketingCreateImageSuccessBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingCreateImageSuccess(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingCreateImageSuccessMutationResult = NonNullable<Awaited<ReturnType<typeof marketingCreateImageSuccess>>>
    export type MarketingCreateImageSuccessMutationBody = MarketingCreateImageSuccessBody
    export type MarketingCreateImageSuccessMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingCreateImageSuccess = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateImageSuccess>>, TError,{data: MarketingCreateImageSuccessBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingCreateImageSuccess>>,
        TError,
        {data: MarketingCreateImageSuccessBody},
        TContext
      > => {

      const mutationOptions = getMarketingCreateImageSuccessMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingCreateVideoStart = (
    marketingCreateVideoStartBody: MaybeRef<MarketingCreateVideoStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingCreateVideoStart200>> => {
    marketingCreateVideoStartBody = unref(marketingCreateVideoStartBody);
    
    return axios.post(
      `/marketing/createVideoStart`,
      marketingCreateVideoStartBody,options
    );
  }



export const getMarketingCreateVideoStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoStart>>, TError,{data: MarketingCreateVideoStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoStart>>, TError,{data: MarketingCreateVideoStartBody}, TContext> => {

const mutationKey = ['marketingCreateVideoStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingCreateVideoStart>>, {data: MarketingCreateVideoStartBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingCreateVideoStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingCreateVideoStartMutationResult = NonNullable<Awaited<ReturnType<typeof marketingCreateVideoStart>>>
    export type MarketingCreateVideoStartMutationBody = MarketingCreateVideoStartBody
    export type MarketingCreateVideoStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingCreateVideoStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoStart>>, TError,{data: MarketingCreateVideoStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingCreateVideoStart>>,
        TError,
        {data: MarketingCreateVideoStartBody},
        TContext
      > => {

      const mutationOptions = getMarketingCreateVideoStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const marketingCreateVideoSuccess = (
    marketingCreateVideoSuccessBody: MaybeRef<MarketingCreateVideoSuccessBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<MarketingCreateVideoSuccess200>> => {
    marketingCreateVideoSuccessBody = unref(marketingCreateVideoSuccessBody);
    
    return axios.post(
      `/marketing/createVideoSuccess`,
      marketingCreateVideoSuccessBody,options
    );
  }



export const getMarketingCreateVideoSuccessMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoSuccess>>, TError,{data: MarketingCreateVideoSuccessBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoSuccess>>, TError,{data: MarketingCreateVideoSuccessBody}, TContext> => {

const mutationKey = ['marketingCreateVideoSuccess'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof marketingCreateVideoSuccess>>, {data: MarketingCreateVideoSuccessBody}> = (props) => {
          const {data} = props ?? {};

          return  marketingCreateVideoSuccess(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type MarketingCreateVideoSuccessMutationResult = NonNullable<Awaited<ReturnType<typeof marketingCreateVideoSuccess>>>
    export type MarketingCreateVideoSuccessMutationBody = MarketingCreateVideoSuccessBody
    export type MarketingCreateVideoSuccessMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useMarketingCreateVideoSuccess = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof marketingCreateVideoSuccess>>, TError,{data: MarketingCreateVideoSuccessBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof marketingCreateVideoSuccess>>,
        TError,
        {data: MarketingCreateVideoSuccessBody},
        TContext
      > => {

      const mutationOptions = getMarketingCreateVideoSuccessMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
