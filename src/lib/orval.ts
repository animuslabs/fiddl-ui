/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Fiddl.art API
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/vue-query';
import type {
  DataTag,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType
} from '@tanstack/vue-query';

import axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

import {
  unref
} from 'vue';
import type {
  MaybeRef
} from 'vue';

export type ErrorBADREQUESTIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorBADREQUEST {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorBADREQUESTIssuesItem[];
}

export type ErrorUNAUTHORIZEDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorUNAUTHORIZED {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorUNAUTHORIZEDIssuesItem[];
}

export type ErrorFORBIDDENIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorFORBIDDEN {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorFORBIDDENIssuesItem[];
}

export type ErrorINTERNALSERVERERRORIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorINTERNALSERVERERROR {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorINTERNALSERVERERRORIssuesItem[];
}

export type ErrorNOTFOUNDIssuesItem = {
  message: string;
};

/**
 * The error information
 */
export interface ErrorNOTFOUND {
  /** The error message */
  message: string;
  /** The error code */
  code: string;
  /** An array of issues that were responsible for the error */
  issues?: ErrorNOTFOUNDIssuesItem[];
}

export type PkAuthRegisterStartBody = {
  email?: string;
  phone?: string;
  referredByUserName?: string;
};

export type PkAuthRegisterFinishBody = {
  userId: string;
  data?: unknown;
};

export type PkAuthLoginStartBody = {
  userId: string;
};

export type PkAuthLoginFinishBody = {
  userId: string;
  data?: unknown;
};

export type CreateImageBodyModel = typeof CreateImageBodyModel[keyof typeof CreateImageBodyModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const;

export type CreateImageBodyAspectRatio = typeof CreateImageBodyAspectRatio[keyof typeof CreateImageBodyAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImageBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateImageBody = {
  prompt: string;
  negativePrompt?: string;
  /**
   * @minimum 1
   * @maximum 100
   */
  quantity: number;
  seed?: number;
  model: CreateImageBodyModel;
  public?: boolean;
  aspectRatio?: CreateImageBodyAspectRatio;
  customModelId?: string;
};

export type CreateImage200 = {
  ids: string[];
  id: string;
  errors: string[];
};

export type CreateVideoBodyModel = typeof CreateVideoBodyModel[keyof typeof CreateVideoBodyModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateVideoBodyModel = {
  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
} as const;

export type CreateVideoBodyAspectRatio = typeof CreateVideoBodyAspectRatio[keyof typeof CreateVideoBodyAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateVideoBodyAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreateVideoBody = {
  prompt: string;
  /**
   * @minimum 1
   * @maximum 5
   */
  quantity: number;
  seed?: number;
  model: CreateVideoBodyModel;
  public: boolean;
  aspectRatio: CreateVideoBodyAspectRatio;
  duration: number;
  startImageId?: string;
};

export type CreateVideo200VideosItemStatus = typeof CreateVideo200VideosItemStatus[keyof typeof CreateVideo200VideosItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateVideo200VideosItemStatus = {
  processing: 'processing',
  previewRendering: 'previewRendering',
  ready: 'ready',
  errored: 'errored',
} as const;

export type CreateVideo200VideosItem = {
  status: CreateVideo200VideosItemStatus;
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  seed: string | null;
  errored: boolean;
  deleted: boolean;
  videoRequestId: string;
  /** @nullable */
  replicatePredictionId: string | null;
  /** @nullable */
  coconutJobId: string | null;
  /** @nullable */
  errorMessage: string | null;
};

export type CreateVideo200 = {
  id: string;
  userId: string;
  prompt: string;
  model: string;
  aspectRatio: string;
  duration: number;
  /** @nullable */
  seed: string | null;
  /** @nullable */
  negativePrompt: string | null;
  quantity: number;
  createdAt: string;
  updatedAt: string;
  public: boolean;
  deleted: boolean;
  /** @nullable */
  error: string | null;
  /** @nullable */
  startImageId: string | null;
  videos: CreateVideo200VideosItem[];
};

export type CreateRandomPromptBodyType = typeof CreateRandomPromptBodyType[keyof typeof CreateRandomPromptBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateRandomPromptBodyType = {
  image: 'image',
  video: 'video',
} as const;

export type CreateRandomPromptBody = {
  theme?: string;
  type?: CreateRandomPromptBodyType;
};

export type CreateImprovePromptBodyType = typeof CreateImprovePromptBodyType[keyof typeof CreateImprovePromptBodyType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreateImprovePromptBodyType = {
  image: 'image',
  video: 'video',
} as const;

export type CreateImprovePromptBody = {
  prompt: string;
  type?: CreateImprovePromptBodyType;
};

export type CreationsGetCreationDataParams = {
imageId?: string;
videoId?: string;
};

export type CreationsGetCreationData200 = {
  id: string;
  createdAt: string;
  requestId: string;
  seed?: number;
  creatorId: string;
  numCollections: number;
};

export type CreationsUserImagePurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserImagePurchasesOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: typeof CreationsUserImagePurchasesModel[keyof typeof CreationsUserImagePurchasesModel] ;
aspectRatio?: CreationsUserImagePurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserImagePurchasesOrder = typeof CreationsUserImagePurchasesOrder[keyof typeof CreationsUserImagePurchasesOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const
export type CreationsUserImagePurchasesAspectRatio = typeof CreationsUserImagePurchasesAspectRatio[keyof typeof CreationsUserImagePurchasesAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserImagePurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsUserImagePurchases200Item = {
  id: string;
  userId: string;
  imageId: string;
  createdAt: string;
};

export type CreationsUserVideoPurchasesParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsUserVideoPurchasesOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: typeof CreationsUserVideoPurchasesModel[keyof typeof CreationsUserVideoPurchasesModel] ;
aspectRatio?: CreationsUserVideoPurchasesAspectRatio;
promptIncludes?: string;
};

export type CreationsUserVideoPurchasesOrder = typeof CreationsUserVideoPurchasesOrder[keyof typeof CreationsUserVideoPurchasesOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserVideoPurchasesOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserVideoPurchasesModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const
export type CreationsUserVideoPurchasesAspectRatio = typeof CreationsUserVideoPurchasesAspectRatio[keyof typeof CreationsUserVideoPurchasesAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsUserVideoPurchasesAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsUserVideoPurchases200Item = {
  id: string;
  userId: string;
  videoId: string;
  createdAt: string;
};

export type CreationsCreateImageRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateImageRequestsOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: typeof CreationsCreateImageRequestsModel[keyof typeof CreationsCreateImageRequestsModel] ;
aspectRatio?: CreationsCreateImageRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateImageRequestsOrder = typeof CreationsCreateImageRequestsOrder[keyof typeof CreationsCreateImageRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateImageRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateImageRequestsModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const
export type CreationsCreateImageRequestsAspectRatio = typeof CreationsCreateImageRequestsAspectRatio[keyof typeof CreationsCreateImageRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateImageRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsCreateImageRequests200Item = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsCreateVideoRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsCreateVideoRequestsOrder;
endDateTime?: string;
includeMetadata?: boolean;
customModelId?: string;
model?: typeof CreationsCreateVideoRequestsModel[keyof typeof CreationsCreateVideoRequestsModel] ;
aspectRatio?: CreationsCreateVideoRequestsAspectRatio;
promptIncludes?: string;
};

export type CreationsCreateVideoRequestsOrder = typeof CreationsCreateVideoRequestsOrder[keyof typeof CreationsCreateVideoRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateVideoRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateVideoRequestsModel = {  'veo-2': 'veo-2',
  'veo-3': 'veo-3',
  'seedance-pro': 'seedance-pro',
  'seedance-lite': 'seedance-lite',
  kling: 'kling',
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const
export type CreationsCreateVideoRequestsAspectRatio = typeof CreationsCreateVideoRequestsAspectRatio[keyof typeof CreationsCreateVideoRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsCreateVideoRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsCreateVideoRequests200Item = {
  id: string;
  videoIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  duration?: number;
  quantity: number;
  startImageId?: string;
};

export type CreationsGetImageRequestParams = {
imageRequestId: string;
};

export type CreationsGetImageRequest200 = {
  id: string;
  imageIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  negativePrompt?: string;
  quantity: number;
  customModelId?: string;
  customModelName?: string;
};

export type CreationsGetVideoRequestParams = {
videoRequestId: string;
};

export type CreationsGetVideoRequest200 = {
  id: string;
  videoIds: string[];
  createdAt: string;
  aspectRatio: string;
  public: boolean;
  creatorId: string;
  model?: string;
  seed?: number;
  prompt?: string;
  duration?: number;
  quantity: number;
  startImageId?: string;
};

export type CreationsBrowseCreateRequestsParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: CreationsBrowseCreateRequestsOrder;
endDateTime?: string;
promptIncludes?: string;
model?: CreationsBrowseCreateRequestsModel;
aspectRatio?: CreationsBrowseCreateRequestsAspectRatio;
customModelId?: string;
randomSeed?: number;
sortMethod: CreationsBrowseCreateRequestsSortMethod;
mediaType?: CreationsBrowseCreateRequestsMediaType;
};

export type CreationsBrowseCreateRequestsOrder = typeof CreationsBrowseCreateRequestsOrder[keyof typeof CreationsBrowseCreateRequestsOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type CreationsBrowseCreateRequestsModel = typeof CreationsBrowseCreateRequestsModel[keyof typeof CreationsBrowseCreateRequestsModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsModel = {
  ultra: 'ultra',
  'sd3-lg': 'sd3-lg',
  core: 'core',
  'dall-e-3': 'dall-e-3',
  'flux-pro-ultra': 'flux-pro-ultra',
  'flux-dev': 'flux-dev',
  'flux-pro': 'flux-pro',
  custom: 'custom',
  imagen4: 'imagen4',
  'imagen4-ultra': 'imagen4-ultra',
  photon: 'photon',
  recraft3: 'recraft3',
  'recraft3-svg': 'recraft3-svg',
  'gpt-image-1': 'gpt-image-1',
  seedream3: 'seedream3',
} as const;

export type CreationsBrowseCreateRequestsAspectRatio = typeof CreationsBrowseCreateRequestsAspectRatio[keyof typeof CreationsBrowseCreateRequestsAspectRatio];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsAspectRatio = {
  '16:9': '16:9',
  '1:1': '1:1',
  '21:9': '21:9',
  '2:3': '2:3',
  '3:2': '3:2',
  '4:5': '4:5',
  '5:4': '5:4',
  '9:16': '9:16',
  '9:21': '9:21',
  '3:4': '3:4',
  '4:3': '4:3',
} as const;

export type CreationsBrowseCreateRequestsSortMethod = typeof CreationsBrowseCreateRequestsSortMethod[keyof typeof CreationsBrowseCreateRequestsSortMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsSortMethod = {
  latest: 'latest',
  shuffle: 'shuffle',
  popular: 'popular',
} as const;

export type CreationsBrowseCreateRequestsMediaType = typeof CreationsBrowseCreateRequestsMediaType[keyof typeof CreationsBrowseCreateRequestsMediaType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CreationsBrowseCreateRequestsMediaType = {
  image: 'image',
  video: 'video',
  all: 'all',
} as const;

export type CreationsHdImageParams = {
imageId: string;
};

export type CreationsHdVideoParams = {
videoId: string;
download?: boolean;
};

export type CreationsOriginalImageParams = {
imageId: string;
};

export type CreationsUpscaledImageParams = {
imageId: string;
};

export type CreationsPurchaseMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CreationsDeleteMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CreationsDeleteRequestBody = {
  videoRequestId?: string;
  imageRequestId?: string;
};

export type CreationsSetRequestPrivacyBody = {
  videoRequestId?: string;
  imageRequestId?: string;
  public: boolean;
};

export type PointsPackagesAvailable200Item = {
  points: number;
  discountPct: number;
  usd: number;
};

export type PointsPrices200ImageModel = {
  ultra: number;
  'sd3-lg': number;
  core: number;
  'dall-e-3': number;
  'flux-pro-ultra': number;
  'flux-dev': number;
  'flux-pro': number;
  custom: number;
  imagen4: number;
  'imagen4-ultra': number;
  photon: number;
  recraft3: number;
  'recraft3-svg': number;
  'gpt-image-1': number;
  seedream3: number;
};

export type PointsPrices200Image = {
  unlock: number;
  unlockCommission: number;
  model: PointsPrices200ImageModel;
};

export type PointsPrices200ForgeTrainBaseModel = {
  fluxDev: number;
  fluxPro: number;
  fluxProUltra: number;
  faceClone: number;
  faceForge: number;
};

export type PointsPrices200ForgeFineTuneType = {
  lora: number;
  full: number;
};

export type PointsPrices200Forge = {
  createTrainingSet: number;
  trainBaseModel: PointsPrices200ForgeTrainBaseModel;
  fineTuneType: PointsPrices200ForgeFineTuneType;
  customModelCharge: number;
  customModelOwnerComission: number;
};

export type PointsPrices200VideoModel = {
  'veo-2': number;
  'veo-3': number;
  'seedance-pro': number;
  'seedance-lite': number;
  kling: number;
};

export type PointsPrices200Video = {
  unlock: number;
  unlockCommission: number;
  model: PointsPrices200VideoModel;
};

export type PointsPrices200SocialRewards = {
  linkEmail: number;
  linkTwitter: number;
  linkGoogle: number;
  linkPhone: number;
  linkTelegram: number;
};

export type PointsPrices200PromptTools = {
  improvePrompt: number;
  randomPrompt: number;
};

export type PointsPrices200 = {
  image: PointsPrices200Image;
  forge: PointsPrices200Forge;
  video: PointsPrices200Video;
  socialRewards: PointsPrices200SocialRewards;
  promptTools: PointsPrices200PromptTools;
};

export type PointsInitBuyPackageBodyMethod = typeof PointsInitBuyPackageBodyMethod[keyof typeof PointsInitBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackageBody = {
  packageId: number;
  method: PointsInitBuyPackageBodyMethod;
};

export type PointsInitBuyPackage200AnyOfLinksItem = {
  href: string;
  rel: string;
  method: string;
};

export type PointsInitBuyPackage200AnyOf = {
  id: string;
  status: string;
  links: PointsInitBuyPackage200AnyOfLinksItem[];
};

export type PointsInitBuyPackage200AnyOfThreeChainName = typeof PointsInitBuyPackage200AnyOfThreeChainName[keyof typeof PointsInitBuyPackage200AnyOfThreeChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsInitBuyPackage200AnyOfThreeTokenType = typeof PointsInitBuyPackage200AnyOfThreeTokenType[keyof typeof PointsInitBuyPackage200AnyOfThreeTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsInitBuyPackage200AnyOfThreeTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsInitBuyPackage200AnyOfThree = {
  chainName: PointsInitBuyPackage200AnyOfThreeChainName;
  tokenType: PointsInitBuyPackage200AnyOfThreeTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsInitBuyPackage200 = PointsInitBuyPackage200AnyOf | PointsInitBuyPackage200AnyOfThree;

export type PointsFinishBuyPackageBodyMethod = typeof PointsFinishBuyPackageBodyMethod[keyof typeof PointsFinishBuyPackageBodyMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsFinishBuyPackageBodyMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsFinishBuyPackageBody = {
  orderId: string;
  method: PointsFinishBuyPackageBodyMethod;
  trackingId?: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount = {
  currency_code: string;
  value: string;
};

export type PointsFinishBuyPackage200AnyOfPurchaseUnitsItem = {
  reference_id: string;
  amount: PointsFinishBuyPackage200AnyOfPurchaseUnitsItemAmount;
};

export type PointsFinishBuyPackage200AnyOf = {
  id: string;
  status: string;
  purchase_units: PointsFinishBuyPackage200AnyOfPurchaseUnitsItem[];
};

export type PointsFinishBuyPackage200AnyOfFour = {
  status: string;
};

export type PointsFinishBuyPackage200 = PointsFinishBuyPackage200AnyOf | PointsFinishBuyPackage200AnyOfFour;

export type PointsGetOrders200PayPalOrdersItem = {
  id: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrders200CryptoOrdersItemChainName = typeof PointsGetOrders200CryptoOrdersItemChainName[keyof typeof PointsGetOrders200CryptoOrdersItemChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrders200CryptoOrdersItemChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrders200CryptoOrdersItem = {
  id: string;
  chainName: PointsGetOrders200CryptoOrdersItemChainName;
  tokenAmount: number;
  usdValue: number;
  confirmed: boolean;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsGetOrders200 = {
  payPalOrders: PointsGetOrders200PayPalOrdersItem[];
  cryptoOrders: PointsGetOrders200CryptoOrdersItem[];
};

export type PointsGetOrderParams = {
id: string;
method: PointsGetOrderMethod;
};

export type PointsGetOrderMethod = typeof PointsGetOrderMethod[keyof typeof PointsGetOrderMethod];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrderMethod = {
  payPal: 'payPal',
  stripe: 'stripe',
  applePay: 'applePay',
  googlePay: 'googlePay',
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOf = {
  id: string;
  userId: string;
  orderID: string;
  amount: number;
  currency: string;
  status: string;
  packageDetailsJSON: string;
  /** @nullable */
  orderDataJSON: string | null;
  createdAt: string;
  updatedAt: string;
};

export type PointsGetOrder200AnyOfTwoChainName = typeof PointsGetOrder200AnyOfTwoChainName[keyof typeof PointsGetOrder200AnyOfTwoChainName];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoChainName = {
  telosNative: 'telosNative',
  telosEVM: 'telosEVM',
} as const;

export type PointsGetOrder200AnyOfTwoTokenType = typeof PointsGetOrder200AnyOfTwoTokenType[keyof typeof PointsGetOrder200AnyOfTwoTokenType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const PointsGetOrder200AnyOfTwoTokenType = {
  TLOS: 'TLOS',
} as const;

export type PointsGetOrder200AnyOfTwo = {
  chainName: PointsGetOrder200AnyOfTwoChainName;
  tokenType: PointsGetOrder200AnyOfTwoTokenType;
  id: string;
  userId: string;
  tokenAmount: number;
  usdValue: number;
  fee: number;
  /** @nullable */
  transactionId: string | null;
  /** @nullable */
  transactionTime: string | null;
  /** @nullable */
  blockNumber: number | null;
  /** @nullable */
  memo: string | null;
  /** @nullable */
  senderWallet: string | null;
  destWallet: string;
  confirmed: boolean;
  /** @nullable */
  pointsGranted: number | null;
  createdAt: string;
  /** @nullable */
  updatedAt: string | null;
};

export type PointsGetOrder200 = PointsGetOrder200AnyOf | PointsGetOrder200AnyOfTwo;

export type UserGetParams = {
userId: string;
};

/**
 * @nullable
 */
export type UserGet200AvatarConfig = {
  imageId: string;
} | null;

export type UserGet200 = {
  id: string;
  /** @nullable */
  webauthnUserID: string | null;
  /** @nullable */
  currentPassKeyChallenge: string | null;
  availablePoints: number;
  createdAt: string;
  updatedAt: string;
  spentPoints: number;
  admin: boolean;
  /** @nullable */
  referredById: string | null;
  lastNotificationSent: string;
  /** @nullable */
  privyId: string | null;
  /** @nullable */
  AvatarConfig: UserGet200AvatarConfig;
};

export type UserProfileParams = {
userId: string;
};

export type UserProfile200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserPublicProfileParams = {
userId: string;
};

export type UserPublicProfile200Profile = {
  /** @nullable */
  username: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
};

export type UserPublicProfile200 = {
  profile: UserPublicProfile200Profile;
  imagesCreated: number;
  imagesFavorited: number;
};

export type UserGetUsernameParams = {
userId: string;
};

export type UserSetUsernameBody = {
  username: string;
};

export type UserSetUsername200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserSetBioBody = {
  bio: string;
};

export type UserSetBio200 = {
  userId: string;
  /** @nullable */
  username: string | null;
  /** @nullable */
  email: string | null;
  emailVerified: boolean;
  /** @nullable */
  phone: string | null;
  phoneVerified: boolean;
  /** @nullable */
  twitter: string | null;
  twitterVerified: boolean;
  /** @nullable */
  instagram: string | null;
  instagramVerified: boolean;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  lastUsernameChange: string | null;
  /** @nullable */
  bio: string | null;
  /** @nullable */
  linksJSON: string | null;
  /** @nullable */
  pangeaAccount: string | null;
};

export type UserSendVerificationEmailBody = {
  email: string;
};

export type UserPointsHistoryParams = {
userId?: string;
startDateTime?: string;
limit?: number;
offset?: number;
order?: UserPointsHistoryOrder;
endDateTime?: string;
includeMetadata?: boolean;
};

export type UserPointsHistoryOrder = typeof UserPointsHistoryOrder[keyof typeof UserPointsHistoryOrder];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistoryOrder = {
  asc: 'asc',
  desc: 'desc',
} as const;

export type UserPointsHistory200ItemType = typeof UserPointsHistory200ItemType[keyof typeof UserPointsHistory200ItemType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserPointsHistory200ItemType = {
  purchase: 'purchase',
  refund: 'refund',
  comission: 'comission',
  bonus: 'bonus',
  referral: 'referral',
  commission: 'commission',
  promoCode: 'promoCode',
  createModel: 'createModel',
  cryptoDeposit: 'cryptoDeposit',
  createTrainingSet: 'createTrainingSet',
} as const;

export type UserPointsHistory200Item = {
  type: UserPointsHistory200ItemType;
  id: string;
  createdAt: string;
  /** @nullable */
  memo: string | null;
  quantity: number;
  userFinalBalance: number;
};

export type UserFindByUsernameParams = {
username: string;
};

export type UserFindByEmailParams = {
email: string;
};

export type UserFindByPhoneParams = {
phone: string;
};

export type UserFindByPrivyIdParams = {
privyId: string;
};

export type UserGetNotificationConfig200EmailFrequency = typeof UserGetNotificationConfig200EmailFrequency[keyof typeof UserGetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200PhoneFrequency = typeof UserGetNotificationConfig200PhoneFrequency[keyof typeof UserGetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserGetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserGetNotificationConfig200 = {
  emailFrequency: UserGetNotificationConfig200EmailFrequency;
  phoneFrequency: UserGetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

export type UserSetNotificationConfigBodyEmailFrequency = typeof UserSetNotificationConfigBodyEmailFrequency[keyof typeof UserSetNotificationConfigBodyEmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyEmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBodyPhoneFrequency = typeof UserSetNotificationConfigBodyPhoneFrequency[keyof typeof UserSetNotificationConfigBodyPhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfigBodyPhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfigBody = {
  email?: boolean;
  phone?: boolean;
  emailFrequency?: UserSetNotificationConfigBodyEmailFrequency;
  phoneFrequency?: UserSetNotificationConfigBodyPhoneFrequency;
};

export type UserSetNotificationConfig200EmailFrequency = typeof UserSetNotificationConfig200EmailFrequency[keyof typeof UserSetNotificationConfig200EmailFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200EmailFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200PhoneFrequency = typeof UserSetNotificationConfig200PhoneFrequency[keyof typeof UserSetNotificationConfig200PhoneFrequency];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const UserSetNotificationConfig200PhoneFrequency = {
  instant: 'instant',
  daily: 'daily',
  weekly: 'weekly',
  monthly: 'monthly',
} as const;

export type UserSetNotificationConfig200 = {
  emailFrequency: UserSetNotificationConfig200EmailFrequency;
  phoneFrequency: UserSetNotificationConfig200PhoneFrequency;
  userId: string;
  email: boolean;
  phone: boolean;
};

export type UserUnsubscribeEmailNotificationsBody = { [key: string]: unknown };

export type UserSetAvatarBodyPosition = {
  x: number;
  y: number;
};

export type UserSetAvatarBody = {
  imageId: string;
  scale: number;
  position: UserSetAvatarBodyPosition;
};

/**
 * @nullable
 */
export type UserAllUsers200ItemProfile = {
  /** @nullable */
  bio: string | null;
  /** @nullable */
  username: string | null;
} | null;

export type UserAllUsers200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  Profile: UserAllUsers200ItemProfile;
};

export type LoginLinkInitLoginLinkBody = {
  email?: string;
  phoneNumber?: string;
  referredBy?: string;
};

export type LoginLinkLoginWithLinkBody = {
  linkId: string;
};

export type LoginLinkLoginWithLink200 = {
  token: string;
  userId: string;
};

export type StatsUsers200 = {
  spentPoints: number;
  spentOver100Points: number;
  spentOver1000Points: number;
  spentOver10000Points: number;
  spentOver20000Points: number;
  purchasedImage: number;
  createdImage: number;
  emailVerified: number;
  phoneVerified: number;
  instagramVerified: number;
  twitterVerified: number;
  setUsername: number;
};

export type _StatsImages200AverageImageQuantityPerCreateRequestAvg = {
  /** @nullable */
  quantity: number | null;
};

export type StatsImages200AverageImageQuantityPerCreateRequest = {
  _avg: _StatsImages200AverageImageQuantityPerCreateRequestAvg;
};

export type StatsImages200 = {
  totalCreated: number;
  totalUpscaled: number;
  totalImageCreateRequests: number;
  averageImageQuantityPerCreateRequest: StatsImages200AverageImageQuantityPerCreateRequest;
  purchasedImages: number;
  totalPurchases: number;
  privateImages: number;
  imagesInAtLeastOneCollection: number;
  imageCreationFailed: number;
};

export type StatsCollections200 = {
  collectionsCreated: number;
  emptyCollections: number;
};

export type _StatsPayments200PaypalOrdersTotalPaidSum = {
  /** @nullable */
  amount: number | null;
};

export type StatsPayments200PaypalOrdersTotalPaid = {
  _sum: _StatsPayments200PaypalOrdersTotalPaidSum;
};

export type StatsPayments200 = {
  incompletePayPayPalOrders: number;
  completePayPayPalOrders: number;
  paypalOrdersTotalPaid: StatsPayments200PaypalOrdersTotalPaid;
};

export type CollectionsMediaInUsersCollectionParams = {
imageId?: string;
videoId?: string;
name: string;
};

export type CollectionsLikeMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CollectionsUnlikeMediaBody = {
  imageId?: string;
  videoId?: string;
};

export type CollectionsGetCollectionMetaParams = {
id: string;
};

export type _CollectionsGetCollectionMeta200Count = {
  Images: number;
  Favorited: number;
};

export type CollectionsGetCollectionMeta200 = {
  id: string;
  name: string;
  description: string;
  ownerId: string;
  private: boolean;
  _count: _CollectionsGetCollectionMeta200Count;
};

export type CollectionsFindCollectionByNameParams = {
ownerId: string;
collectionName: string;
};

export type CollectionsFindCollectionByName200 = {
  id: string;
};

export type CollectionsGetCollectionImagesParams = {
id: string;
};

export type CollectionsGetCollectionImages200ItemImageRequest = {
  userId: string;
};

export type CollectionsGetCollectionImages200Item = {
  id: string;
  createdAt: string;
  updatedAt: string;
  imageRequestId: string;
  seed: string;
  errored: boolean;
  filtered: boolean;
  deleted: boolean;
  imageRequest: CollectionsGetCollectionImages200ItemImageRequest;
};

export type CollectionsGetCollectionVideosParams = {
id: string;
};

export type CollectionsGetCollectionVideos200ItemStatus = typeof CollectionsGetCollectionVideos200ItemStatus[keyof typeof CollectionsGetCollectionVideos200ItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const CollectionsGetCollectionVideos200ItemStatus = {
  processing: 'processing',
  previewRendering: 'previewRendering',
  ready: 'ready',
  errored: 'errored',
} as const;

export type CollectionsGetCollectionVideos200ItemVideoRequest = {
  userId: string;
};

export type CollectionsGetCollectionVideos200Item = {
  status: CollectionsGetCollectionVideos200ItemStatus;
  id: string;
  createdAt: string;
  updatedAt: string;
  /** @nullable */
  seed: string | null;
  errored: boolean;
  deleted: boolean;
  videoRequestId: string;
  /** @nullable */
  replicatePredictionId: string | null;
  /** @nullable */
  coconutJobId: string | null;
  /** @nullable */
  errorMessage: string | null;
  VideoRequest: CollectionsGetCollectionVideos200ItemVideoRequest;
};

export type PromoCreatePromoCodeBody = {
  points: number;
};

export type PromoCreatePromoCode200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoDeletePromoCodeBody = {
  id: string;
};

export type PromoGetPromoCodes200Item = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoGetPromoCodeDetailsParams = {
id: string;
};

export type PromoGetPromoCodeDetails200 = {
  id: string;
  points: number;
  /** @nullable */
  claimedByUserId: string | null;
  /** @nullable */
  claimedAt: string | null;
  createdAt: string;
};

export type PromoClaimPromoCodeBody = {
  id: string;
};

export type ModelsEditModelBody = {
  id: string;
  /** @maxLength 30 */
  name: string;
  /** @maxLength 500 */
  description: string;
};

export type ModelsGetUserModelsParams = {
trainingSetId?: string;
};

export type ModelsGetUserModels200ItemStatus = typeof ModelsGetUserModels200ItemStatus[keyof typeof ModelsGetUserModels200ItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetUserModels200ItemModelType = typeof ModelsGetUserModels200ItemModelType[keyof typeof ModelsGetUserModels200ItemModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetUserModels200ItemFineTuneType = typeof ModelsGetUserModels200ItemFineTuneType[keyof typeof ModelsGetUserModels200ItemFineTuneType] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetUserModels200ItemMode = typeof ModelsGetUserModels200ItemMode[keyof typeof ModelsGetUserModels200ItemMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetUserModels200ItemModelTagsItem = typeof ModelsGetUserModels200ItemModelTagsItem[keyof typeof ModelsGetUserModels200ItemModelTagsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetUserModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetUserModels200ItemImageRequestsItemImagesItem = {
  id: string;
};

export type ModelsGetUserModels200ItemImageRequestsItem = {
  id: string;
  images: ModelsGetUserModels200ItemImageRequestsItemImagesItem[];
};

export type ModelsGetUserModels200Item = {
  status: ModelsGetUserModels200ItemStatus;
  modelType: ModelsGetUserModels200ItemModelType;
  /** @nullable */
  fineTuneType: ModelsGetUserModels200ItemFineTuneType;
  mode: ModelsGetUserModels200ItemMode;
  modelTags: ModelsGetUserModels200ItemModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
  imageRequests: ModelsGetUserModels200ItemImageRequestsItem[];
};

export type ModelsCreateModelBodyBaseModel = typeof ModelsCreateModelBodyBaseModel[keyof typeof ModelsCreateModelBodyBaseModel];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyBaseModel = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

export type ModelsCreateModelBodyModelMode = typeof ModelsCreateModelBodyModelMode[keyof typeof ModelsCreateModelBodyModelMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyModelMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsCreateModelBodyFineTuneType = typeof ModelsCreateModelBodyFineTuneType[keyof typeof ModelsCreateModelBodyFineTuneType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsCreateModelBodyFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsCreateModelBody = {
  name: string;
  description: string;
  baseModel: ModelsCreateModelBodyBaseModel;
  modelMode: ModelsCreateModelBodyModelMode;
  fineTuneType: ModelsCreateModelBodyFineTuneType;
  trainingSetId: string;
};

export type ModelsGetTrainingStatusParams = {
id: string;
};

export type ModelsGetTrainingStatus200Status = typeof ModelsGetTrainingStatus200Status[keyof typeof ModelsGetTrainingStatus200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetTrainingStatus200Status = {
  processing: 'processing',
  trained: 'trained',
  succeeded: 'succeeded',
  failed: 'failed',
} as const;

export type ModelsGetTrainingStatus200 = {
  status: ModelsGetTrainingStatus200Status;
  /** @nullable */
  error: string | null;
  /**
   * @minimum 0
   * @maximum 100
   */
  progress: number;
  elapsedTime: string;
  remainingTime: string;
};

export type ModelsDeleteModelBody = {
  id: string;
};

export type ModelsGetCustomModelParams = {
id: string;
};

export type ModelsGetCustomModel200Status = typeof ModelsGetCustomModel200Status[keyof typeof ModelsGetCustomModel200Status];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetCustomModel200Status = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetCustomModel200ModelType = typeof ModelsGetCustomModel200ModelType[keyof typeof ModelsGetCustomModel200ModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetCustomModel200ModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetCustomModel200FineTuneType = typeof ModelsGetCustomModel200FineTuneType[keyof typeof ModelsGetCustomModel200FineTuneType] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetCustomModel200FineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetCustomModel200Mode = typeof ModelsGetCustomModel200Mode[keyof typeof ModelsGetCustomModel200Mode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetCustomModel200Mode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetCustomModel200ModelTagsItem = typeof ModelsGetCustomModel200ModelTagsItem[keyof typeof ModelsGetCustomModel200ModelTagsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetCustomModel200ModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetCustomModel200 = {
  status: ModelsGetCustomModel200Status;
  modelType: ModelsGetCustomModel200ModelType;
  /** @nullable */
  fineTuneType: ModelsGetCustomModel200FineTuneType;
  mode: ModelsGetCustomModel200Mode;
  modelTags: ModelsGetCustomModel200ModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
};

export type ModelsGetPublicModelsParams = {
page?: number;
tag?: ModelsGetPublicModelsTag;
};

export type ModelsGetPublicModelsTag = typeof ModelsGetPublicModelsTag[keyof typeof ModelsGetPublicModelsTag];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModelsTag = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetPublicModels200ItemStatus = typeof ModelsGetPublicModels200ItemStatus[keyof typeof ModelsGetPublicModels200ItemStatus];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModels200ItemStatus = {
  training: 'training',
  trained: 'trained',
  error: 'error',
  waitingForImageUpload: 'waitingForImageUpload',
} as const;

export type ModelsGetPublicModels200ItemModelType = typeof ModelsGetPublicModels200ItemModelType[keyof typeof ModelsGetPublicModels200ItemModelType];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModels200ItemModelType = {
  faceClone: 'faceClone',
  faceForge: 'faceForge',
  fluxDev: 'fluxDev',
  fluxPro: 'fluxPro',
  fluxProUltra: 'fluxProUltra',
} as const;

/**
 * @nullable
 */
export type ModelsGetPublicModels200ItemFineTuneType = typeof ModelsGetPublicModels200ItemFineTuneType[keyof typeof ModelsGetPublicModels200ItemFineTuneType] | null;


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModels200ItemFineTuneType = {
  lora: 'lora',
  full: 'full',
} as const;

export type ModelsGetPublicModels200ItemMode = typeof ModelsGetPublicModels200ItemMode[keyof typeof ModelsGetPublicModels200ItemMode];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModels200ItemMode = {
  subject: 'subject',
  style: 'style',
  object: 'object',
  general: 'general',
} as const;

export type ModelsGetPublicModels200ItemModelTagsItem = typeof ModelsGetPublicModels200ItemModelTagsItem[keyof typeof ModelsGetPublicModels200ItemModelTagsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetPublicModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetPublicModels200Item = {
  status: ModelsGetPublicModels200ItemStatus;
  modelType: ModelsGetPublicModels200ItemModelType;
  /** @nullable */
  fineTuneType: ModelsGetPublicModels200ItemFineTuneType;
  mode: ModelsGetPublicModels200ItemMode;
  modelTags: ModelsGetPublicModels200ItemModelTagsItem[];
  id: string;
  createdAt: string;
  updatedAt: string;
  creatorId: string;
  name: string;
  slug: string;
  /** @nullable */
  trainingError: string | null;
  /** @nullable */
  trainingId: string | null;
  /** @nullable */
  inferenceId: string | null;
  Public: boolean;
  /** @nullable */
  trainingSetId: string | null;
  /** @nullable */
  description: string | null;
};

export type ModelsGetBaseModelsParams = {
page?: number;
};

export type ModelsGetBaseModels200ItemModelTagsItem = typeof ModelsGetBaseModels200ItemModelTagsItem[keyof typeof ModelsGetBaseModels200ItemModelTagsItem];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const ModelsGetBaseModels200ItemModelTagsItem = {
  Realistic: 'Realistic',
  Creative: 'Creative',
  Illustrative: 'Illustrative',
  DesignText: 'DesignText',
  Precision: 'Precision',
  Vibrant: 'Vibrant',
  Versatile: 'Versatile',
  FastBudget: 'FastBudget',
  Vector: 'Vector',
  Multimodal: 'Multimodal',
  Bilingual: 'Bilingual',
  Custom: 'Custom',
  Cinematic: 'Cinematic',
  MultiCamera: 'MultiCamera',
  Audio: 'Audio',
  Dramatic: 'Dramatic',
  Experimental: 'Experimental',
  Image: 'Image',
  Video: 'Video',
} as const;

export type ModelsGetBaseModels200Item = {
  modelTags: ModelsGetBaseModels200ItemModelTagsItem[];
  slug: string;
  updatedAt: string;
  name: string;
  /** @nullable */
  description: string | null;
};

export type ModelsSetModelPrivacyBody = {
  id: string;
  public: boolean;
};

export type AdminLoginAsUserBody = {
  id: string;
};

export type PrivyAuthenticateBody = {
  accessToken: string;
  referrerUsername?: string;
};

export type PrivyAuthenticate200 = {
  token: string;
  userId: string;
};

export type TrainingSetsCreateSetBody = {
  /** @maxLength 30 */
  name: string;
  /** @maxLength 400 */
  description: string;
  /**
   * @minimum 3
   * @maximum 200
   */
  numImages: number;
  /** @maximum 800 */
  zipSizeMb: number;
};

export type TrainingSetsCreateSet200SignedZipUploadDataFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedZipUploadData = {
  url: string;
  fields: TrainingSetsCreateSet200SignedZipUploadDataFields;
};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields = {[key: string]: string};

export type TrainingSetsCreateSet200SignedThumbnailUploadDatasItem = {
  url: string;
  fields: TrainingSetsCreateSet200SignedThumbnailUploadDatasItemFields;
};

export type TrainingSetsCreateSet200 = {
  trainingSetId: string;
  signedZipUploadData: TrainingSetsCreateSet200SignedZipUploadData;
  signedThumbnailUploadDatas: TrainingSetsCreateSet200SignedThumbnailUploadDatasItem[];
};

export type TrainingSetsFinalizeSetBody = {
  trainingSetId: string;
};

export type TrainingSetsGetUserSetsParams = {
userId: string;
};

export type TrainingSetsGetUserSets200Item = {
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  /** @nullable */
  description: string | null;
  deleted: boolean;
  updatedAt: string;
};

export type TrainingSetsGetSetParams = {
trainingSetId: string;
};

export type TrainingSetsGetSet200 = {
  id: string;
  ownerId: string;
  createdAt: string;
  name: string;
  sizeMB: number;
  numImages: number;
  status: number;
  thumbnailIds: string[];
  /** @nullable */
  description: string | null;
  deleted: boolean;
  updatedAt: string;
};

export type TrainingSetsDeleteSetBody = {
  trainingSetId: string;
};

export type TrainingSetsEditSetBody = {
  trainingSetId: string;
  /** @maxLength 32 */
  newName: string;
  /** @maxLength 400 */
  newDescription: string;
};

export const pkAuthRegisterStart = (
    pkAuthRegisterStartBody: MaybeRef<PkAuthRegisterStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterStartBody = unref(pkAuthRegisterStartBody);
    
    return axios.post(
      `/pkAuth/registerStart`,
      pkAuthRegisterStartBody,options
    );
  }



export const getPkAuthRegisterStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext> => {

const mutationKey = ['pkAuthRegisterStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterStart>>, {data: PkAuthRegisterStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterStart>>>
    export type PkAuthRegisterStartMutationBody = PkAuthRegisterStartBody
    export type PkAuthRegisterStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterStart>>, TError,{data: PkAuthRegisterStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterStart>>,
        TError,
        {data: PkAuthRegisterStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthRegisterFinish = (
    pkAuthRegisterFinishBody: MaybeRef<PkAuthRegisterFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthRegisterFinishBody = unref(pkAuthRegisterFinishBody);
    
    return axios.post(
      `/pkAuth/registerFinish`,
      pkAuthRegisterFinishBody,options
    );
  }



export const getPkAuthRegisterFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext> => {

const mutationKey = ['pkAuthRegisterFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, {data: PkAuthRegisterFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthRegisterFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthRegisterFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthRegisterFinish>>>
    export type PkAuthRegisterFinishMutationBody = PkAuthRegisterFinishBody
    export type PkAuthRegisterFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthRegisterFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthRegisterFinish>>, TError,{data: PkAuthRegisterFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthRegisterFinish>>,
        TError,
        {data: PkAuthRegisterFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthRegisterFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginStart = (
    pkAuthLoginStartBody: MaybeRef<PkAuthLoginStartBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginStartBody = unref(pkAuthLoginStartBody);
    
    return axios.post(
      `/pkAuth/loginStart`,
      pkAuthLoginStartBody,options
    );
  }



export const getPkAuthLoginStartMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext> => {

const mutationKey = ['pkAuthLoginStart'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginStart>>, {data: PkAuthLoginStartBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginStart(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginStartMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginStart>>>
    export type PkAuthLoginStartMutationBody = PkAuthLoginStartBody
    export type PkAuthLoginStartMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginStart = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginStart>>, TError,{data: PkAuthLoginStartBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginStart>>,
        TError,
        {data: PkAuthLoginStartBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginStartMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pkAuthLoginFinish = (
    pkAuthLoginFinishBody: MaybeRef<PkAuthLoginFinishBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    pkAuthLoginFinishBody = unref(pkAuthLoginFinishBody);
    
    return axios.post(
      `/pkAuth/loginFinish`,
      pkAuthLoginFinishBody,options
    );
  }



export const getPkAuthLoginFinishMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext> => {

const mutationKey = ['pkAuthLoginFinish'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pkAuthLoginFinish>>, {data: PkAuthLoginFinishBody}> = (props) => {
          const {data} = props ?? {};

          return  pkAuthLoginFinish(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PkAuthLoginFinishMutationResult = NonNullable<Awaited<ReturnType<typeof pkAuthLoginFinish>>>
    export type PkAuthLoginFinishMutationBody = PkAuthLoginFinishBody
    export type PkAuthLoginFinishMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePkAuthLoginFinish = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pkAuthLoginFinish>>, TError,{data: PkAuthLoginFinishBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pkAuthLoginFinish>>,
        TError,
        {data: PkAuthLoginFinishBody},
        TContext
      > => {

      const mutationOptions = getPkAuthLoginFinishMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImage = (
    createImageBody: MaybeRef<CreateImageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateImage200>> => {
    createImageBody = unref(createImageBody);
    
    return axios.post(
      `/create/image`,
      createImageBody,options
    );
  }



export const getCreateImageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext> => {

const mutationKey = ['createImage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImage>>, {data: CreateImageBody}> = (props) => {
          const {data} = props ?? {};

          return  createImage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImageMutationResult = NonNullable<Awaited<ReturnType<typeof createImage>>>
    export type CreateImageMutationBody = CreateImageBody
    export type CreateImageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImage>>, TError,{data: CreateImageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImage>>,
        TError,
        {data: CreateImageBody},
        TContext
      > => {

      const mutationOptions = getCreateImageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createVideo = (
    createVideoBody: MaybeRef<CreateVideoBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreateVideo200>> => {
    createVideoBody = unref(createVideoBody);
    
    return axios.post(
      `/create/video`,
      createVideoBody,options
    );
  }



export const getCreateVideoMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext> => {

const mutationKey = ['createVideo'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createVideo>>, {data: CreateVideoBody}> = (props) => {
          const {data} = props ?? {};

          return  createVideo(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateVideoMutationResult = NonNullable<Awaited<ReturnType<typeof createVideo>>>
    export type CreateVideoMutationBody = CreateVideoBody
    export type CreateVideoMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateVideo = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createVideo>>, TError,{data: CreateVideoBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createVideo>>,
        TError,
        {data: CreateVideoBody},
        TContext
      > => {

      const mutationOptions = getCreateVideoMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createRandomPrompt = (
    createRandomPromptBody: MaybeRef<CreateRandomPromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createRandomPromptBody = unref(createRandomPromptBody);
    
    return axios.post(
      `/create/randomPrompt`,
      createRandomPromptBody,options
    );
  }



export const getCreateRandomPromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext> => {

const mutationKey = ['createRandomPrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRandomPrompt>>, {data: CreateRandomPromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createRandomPrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRandomPromptMutationResult = NonNullable<Awaited<ReturnType<typeof createRandomPrompt>>>
    export type CreateRandomPromptMutationBody = CreateRandomPromptBody
    export type CreateRandomPromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateRandomPrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRandomPrompt>>, TError,{data: CreateRandomPromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createRandomPrompt>>,
        TError,
        {data: CreateRandomPromptBody},
        TContext
      > => {

      const mutationOptions = getCreateRandomPromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const createImprovePrompt = (
    createImprovePromptBody: MaybeRef<CreateImprovePromptBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    createImprovePromptBody = unref(createImprovePromptBody);
    
    return axios.post(
      `/create/improvePrompt`,
      createImprovePromptBody,options
    );
  }



export const getCreateImprovePromptMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext> => {

const mutationKey = ['createImprovePrompt'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createImprovePrompt>>, {data: CreateImprovePromptBody}> = (props) => {
          const {data} = props ?? {};

          return  createImprovePrompt(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateImprovePromptMutationResult = NonNullable<Awaited<ReturnType<typeof createImprovePrompt>>>
    export type CreateImprovePromptMutationBody = CreateImprovePromptBody
    export type CreateImprovePromptMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreateImprovePrompt = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createImprovePrompt>>, TError,{data: CreateImprovePromptBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof createImprovePrompt>>,
        TError,
        {data: CreateImprovePromptBody},
        TContext
      > => {

      const mutationOptions = getCreateImprovePromptMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsGetCreationData = (
    params?: MaybeRef<CreationsGetCreationDataParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetCreationData200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getCreationData`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetCreationDataQueryKey = (params?: MaybeRef<CreationsGetCreationDataParams>,) => {
    return ['creations','getCreationData', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetCreationDataQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetCreationData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsGetCreationDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetCreationDataQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetCreationData>>> = ({ signal }) => creationsGetCreationData(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData> 
}

export type CreationsGetCreationDataQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetCreationData>>>
export type CreationsGetCreationDataQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetCreationData<TData = Awaited<ReturnType<typeof creationsGetCreationData>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsGetCreationDataParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetCreationData>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetCreationDataQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUserImagePurchases = (
    params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsUserImagePurchases200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/userImagePurchases`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUserImagePurchasesQueryKey = (params?: MaybeRef<CreationsUserImagePurchasesParams>,) => {
    return ['creations','userImagePurchases', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUserImagePurchasesQueryOptions = <TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUserImagePurchasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUserImagePurchases>>> = ({ signal }) => creationsUserImagePurchases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData> 
}

export type CreationsUserImagePurchasesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUserImagePurchases>>>
export type CreationsUserImagePurchasesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUserImagePurchases<TData = Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsUserImagePurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserImagePurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUserImagePurchasesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUserVideoPurchases = (
    params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsUserVideoPurchases200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/userVideoPurchases`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUserVideoPurchasesQueryKey = (params?: MaybeRef<CreationsUserVideoPurchasesParams>,) => {
    return ['creations','userVideoPurchases', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUserVideoPurchasesQueryOptions = <TData = Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUserVideoPurchasesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUserVideoPurchases>>> = ({ signal }) => creationsUserVideoPurchases(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData> 
}

export type CreationsUserVideoPurchasesQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUserVideoPurchases>>>
export type CreationsUserVideoPurchasesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUserVideoPurchases<TData = Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsUserVideoPurchasesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUserVideoPurchases>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUserVideoPurchasesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateImageRequests = (
    params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateImageRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createImageRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateImageRequestsQueryKey = (params?: MaybeRef<CreationsCreateImageRequestsParams>,) => {
    return ['creations','createImageRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateImageRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateImageRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateImageRequests>>> = ({ signal }) => creationsCreateImageRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData> 
}

export type CreationsCreateImageRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateImageRequests>>>
export type CreationsCreateImageRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateImageRequests<TData = Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsCreateImageRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateImageRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateImageRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsCreateVideoRequests = (
    params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsCreateVideoRequests200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/createVideoRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsCreateVideoRequestsQueryKey = (params?: MaybeRef<CreationsCreateVideoRequestsParams>,) => {
    return ['creations','createVideoRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsCreateVideoRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsCreateVideoRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsCreateVideoRequests>>> = ({ signal }) => creationsCreateVideoRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData> 
}

export type CreationsCreateVideoRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsCreateVideoRequests>>>
export type CreationsCreateVideoRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsCreateVideoRequests<TData = Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<CreationsCreateVideoRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsCreateVideoRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsCreateVideoRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetImageRequest = (
    params: MaybeRef<CreationsGetImageRequestParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetImageRequest200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getImageRequest`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetImageRequestQueryKey = (params: MaybeRef<CreationsGetImageRequestParams>,) => {
    return ['creations','getImageRequest', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetImageRequestQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetImageRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsGetImageRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetImageRequestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetImageRequest>>> = ({ signal }) => creationsGetImageRequest(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData> 
}

export type CreationsGetImageRequestQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetImageRequest>>>
export type CreationsGetImageRequestQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetImageRequest<TData = Awaited<ReturnType<typeof creationsGetImageRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsGetImageRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetImageRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetImageRequestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsGetVideoRequest = (
    params: MaybeRef<CreationsGetVideoRequestParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CreationsGetVideoRequest200>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/getVideoRequest`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsGetVideoRequestQueryKey = (params: MaybeRef<CreationsGetVideoRequestParams>,) => {
    return ['creations','getVideoRequest', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsGetVideoRequestQueryOptions = <TData = Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsGetVideoRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsGetVideoRequestQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsGetVideoRequest>>> = ({ signal }) => creationsGetVideoRequest(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData> 
}

export type CreationsGetVideoRequestQueryResult = NonNullable<Awaited<ReturnType<typeof creationsGetVideoRequest>>>
export type CreationsGetVideoRequestQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsGetVideoRequest<TData = Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsGetVideoRequestParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsGetVideoRequest>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsGetVideoRequestQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsBrowseCreateRequests = (
    params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown[]>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/browseCreateRequests`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsBrowseCreateRequestsQueryKey = (params: MaybeRef<CreationsBrowseCreateRequestsParams>,) => {
    return ['creations','browseCreateRequests', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsBrowseCreateRequestsQueryOptions = <TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsBrowseCreateRequestsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>> = ({ signal }) => creationsBrowseCreateRequests(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData> 
}

export type CreationsBrowseCreateRequestsQueryResult = NonNullable<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>>
export type CreationsBrowseCreateRequestsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsBrowseCreateRequests<TData = Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsBrowseCreateRequestsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsBrowseCreateRequests>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsBrowseCreateRequestsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsHdImage = (
    params: MaybeRef<CreationsHdImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/hdImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsHdImageQueryKey = (params: MaybeRef<CreationsHdImageParams>,) => {
    return ['creations','hdImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsHdImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsHdImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsHdImage>>> = ({ signal }) => creationsHdImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData> 
}

export type CreationsHdImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsHdImage>>>
export type CreationsHdImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsHdImage<TData = Awaited<ReturnType<typeof creationsHdImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsHdImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsHdImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsHdVideo = (
    params: MaybeRef<CreationsHdVideoParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/hdVideo`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsHdVideoQueryKey = (params: MaybeRef<CreationsHdVideoParams>,) => {
    return ['creations','hdVideo', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsHdVideoQueryOptions = <TData = Awaited<ReturnType<typeof creationsHdVideo>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsHdVideoParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsHdVideoQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsHdVideo>>> = ({ signal }) => creationsHdVideo(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData> 
}

export type CreationsHdVideoQueryResult = NonNullable<Awaited<ReturnType<typeof creationsHdVideo>>>
export type CreationsHdVideoQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsHdVideo<TData = Awaited<ReturnType<typeof creationsHdVideo>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsHdVideoParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsHdVideo>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsHdVideoQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsOriginalImage = (
    params: MaybeRef<CreationsOriginalImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/originalImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsOriginalImageQueryKey = (params: MaybeRef<CreationsOriginalImageParams>,) => {
    return ['creations','originalImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsOriginalImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsOriginalImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsOriginalImage>>> = ({ signal }) => creationsOriginalImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData> 
}

export type CreationsOriginalImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsOriginalImage>>>
export type CreationsOriginalImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsOriginalImage<TData = Awaited<ReturnType<typeof creationsOriginalImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsOriginalImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsOriginalImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsOriginalImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsUpscaledImage = (
    params: MaybeRef<CreationsUpscaledImageParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/creations/upscaledImage`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCreationsUpscaledImageQueryKey = (params: MaybeRef<CreationsUpscaledImageParams>,) => {
    return ['creations','upscaledImage', ...(params ? [params]: [])] as const;
    }

    
export const getCreationsUpscaledImageQueryOptions = <TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCreationsUpscaledImageQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof creationsUpscaledImage>>> = ({ signal }) => creationsUpscaledImage(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData> 
}

export type CreationsUpscaledImageQueryResult = NonNullable<Awaited<ReturnType<typeof creationsUpscaledImage>>>
export type CreationsUpscaledImageQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCreationsUpscaledImage<TData = Awaited<ReturnType<typeof creationsUpscaledImage>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CreationsUpscaledImageParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof creationsUpscaledImage>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCreationsUpscaledImageQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const creationsPurchaseMedia = (
    creationsPurchaseMediaBody: MaybeRef<CreationsPurchaseMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsPurchaseMediaBody = unref(creationsPurchaseMediaBody);
    
    return axios.post(
      `/creations/purchaseMedia`,
      creationsPurchaseMediaBody,options
    );
  }



export const getCreationsPurchaseMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext> => {

const mutationKey = ['creationsPurchaseMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsPurchaseMedia>>, {data: CreationsPurchaseMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsPurchaseMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsPurchaseMediaMutationResult = NonNullable<Awaited<ReturnType<typeof creationsPurchaseMedia>>>
    export type CreationsPurchaseMediaMutationBody = CreationsPurchaseMediaBody
    export type CreationsPurchaseMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsPurchaseMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsPurchaseMedia>>, TError,{data: CreationsPurchaseMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsPurchaseMedia>>,
        TError,
        {data: CreationsPurchaseMediaBody},
        TContext
      > => {

      const mutationOptions = getCreationsPurchaseMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteMedia = (
    creationsDeleteMediaBody: MaybeRef<CreationsDeleteMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    creationsDeleteMediaBody = unref(creationsDeleteMediaBody);
    
    return axios.post(
      `/creations/deleteMedia`,
      creationsDeleteMediaBody,options
    );
  }



export const getCreationsDeleteMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext> => {

const mutationKey = ['creationsDeleteMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteMedia>>, {data: CreationsDeleteMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteMediaMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteMedia>>>
    export type CreationsDeleteMediaMutationBody = CreationsDeleteMediaBody
    export type CreationsDeleteMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteMedia>>, TError,{data: CreationsDeleteMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteMedia>>,
        TError,
        {data: CreationsDeleteMediaBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsDeleteRequest = (
    creationsDeleteRequestBody: MaybeRef<CreationsDeleteRequestBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsDeleteRequestBody = unref(creationsDeleteRequestBody);
    
    return axios.post(
      `/creations/deleteRequest`,
      creationsDeleteRequestBody,options
    );
  }



export const getCreationsDeleteRequestMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext> => {

const mutationKey = ['creationsDeleteRequest'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsDeleteRequest>>, {data: CreationsDeleteRequestBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsDeleteRequest(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsDeleteRequestMutationResult = NonNullable<Awaited<ReturnType<typeof creationsDeleteRequest>>>
    export type CreationsDeleteRequestMutationBody = CreationsDeleteRequestBody
    export type CreationsDeleteRequestMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsDeleteRequest = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsDeleteRequest>>, TError,{data: CreationsDeleteRequestBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsDeleteRequest>>,
        TError,
        {data: CreationsDeleteRequestBody},
        TContext
      > => {

      const mutationOptions = getCreationsDeleteRequestMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const creationsSetRequestPrivacy = (
    creationsSetRequestPrivacyBody: MaybeRef<CreationsSetRequestPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    creationsSetRequestPrivacyBody = unref(creationsSetRequestPrivacyBody);
    
    return axios.post(
      `/creations/setRequestPrivacy`,
      creationsSetRequestPrivacyBody,options
    );
  }



export const getCreationsSetRequestPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext> => {

const mutationKey = ['creationsSetRequestPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, {data: CreationsSetRequestPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  creationsSetRequestPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreationsSetRequestPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>>
    export type CreationsSetRequestPrivacyMutationBody = CreationsSetRequestPrivacyBody
    export type CreationsSetRequestPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCreationsSetRequestPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof creationsSetRequestPrivacy>>, TError,{data: CreationsSetRequestPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof creationsSetRequestPrivacy>>,
        TError,
        {data: CreationsSetRequestPrivacyBody},
        TContext
      > => {

      const mutationOptions = getCreationsSetRequestPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsPackagesAvailable = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPackagesAvailable200Item[]>> => {
    
    
    return axios.get(
      `/points/packagesAvailable`,options
    );
  }


export const getPointsPackagesAvailableQueryKey = () => {
    return ['points','packagesAvailable'] as const;
    }

    
export const getPointsPackagesAvailableQueryOptions = <TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPackagesAvailableQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPackagesAvailable>>> = ({ signal }) => pointsPackagesAvailable({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData> 
}

export type PointsPackagesAvailableQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPackagesAvailable>>>
export type PointsPackagesAvailableQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPackagesAvailable<TData = Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPackagesAvailable>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPackagesAvailableQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsPrices = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsPrices200>> => {
    
    
    return axios.get(
      `/points/prices`,options
    );
  }


export const getPointsPricesQueryKey = () => {
    return ['points','prices'] as const;
    }

    
export const getPointsPricesQueryOptions = <TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsPricesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsPrices>>> = ({ signal }) => pointsPrices({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData> 
}

export type PointsPricesQueryResult = NonNullable<Awaited<ReturnType<typeof pointsPrices>>>
export type PointsPricesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsPrices<TData = Awaited<ReturnType<typeof pointsPrices>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsPrices>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsPricesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsInitBuyPackage = (
    pointsInitBuyPackageBody: MaybeRef<PointsInitBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsInitBuyPackage200>> => {
    pointsInitBuyPackageBody = unref(pointsInitBuyPackageBody);
    
    return axios.post(
      `/points/initBuyPackage`,
      pointsInitBuyPackageBody,options
    );
  }



export const getPointsInitBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext> => {

const mutationKey = ['pointsInitBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsInitBuyPackage>>, {data: PointsInitBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsInitBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsInitBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsInitBuyPackage>>>
    export type PointsInitBuyPackageMutationBody = PointsInitBuyPackageBody
    export type PointsInitBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsInitBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsInitBuyPackage>>, TError,{data: PointsInitBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsInitBuyPackage>>,
        TError,
        {data: PointsInitBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsInitBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsFinishBuyPackage = (
    pointsFinishBuyPackageBody: MaybeRef<PointsFinishBuyPackageBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsFinishBuyPackage200>> => {
    pointsFinishBuyPackageBody = unref(pointsFinishBuyPackageBody);
    
    return axios.post(
      `/points/finishBuyPackage`,
      pointsFinishBuyPackageBody,options
    );
  }



export const getPointsFinishBuyPackageMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext> => {

const mutationKey = ['pointsFinishBuyPackage'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, {data: PointsFinishBuyPackageBody}> = (props) => {
          const {data} = props ?? {};

          return  pointsFinishBuyPackage(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PointsFinishBuyPackageMutationResult = NonNullable<Awaited<ReturnType<typeof pointsFinishBuyPackage>>>
    export type PointsFinishBuyPackageMutationBody = PointsFinishBuyPackageBody
    export type PointsFinishBuyPackageMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePointsFinishBuyPackage = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pointsFinishBuyPackage>>, TError,{data: PointsFinishBuyPackageBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof pointsFinishBuyPackage>>,
        TError,
        {data: PointsFinishBuyPackageBody},
        TContext
      > => {

      const mutationOptions = getPointsFinishBuyPackageMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const pointsGetOrders = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrders200>> => {
    
    
    return axios.get(
      `/points/getOrders`,options
    );
  }


export const getPointsGetOrdersQueryKey = () => {
    return ['points','getOrders'] as const;
    }

    
export const getPointsGetOrdersQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrdersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrders>>> = ({ signal }) => pointsGetOrders({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData> 
}

export type PointsGetOrdersQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrders>>>
export type PointsGetOrdersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrders<TData = Awaited<ReturnType<typeof pointsGetOrders>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrders>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrdersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const pointsGetOrder = (
    params: MaybeRef<PointsGetOrderParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PointsGetOrder200>> => {
    params = unref(params);
    
    return axios.get(
      `/points/getOrder`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPointsGetOrderQueryKey = (params: MaybeRef<PointsGetOrderParams>,) => {
    return ['points','getOrder', ...(params ? [params]: [])] as const;
    }

    
export const getPointsGetOrderQueryOptions = <TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPointsGetOrderQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof pointsGetOrder>>> = ({ signal }) => pointsGetOrder(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData> 
}

export type PointsGetOrderQueryResult = NonNullable<Awaited<ReturnType<typeof pointsGetOrder>>>
export type PointsGetOrderQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePointsGetOrder<TData = Awaited<ReturnType<typeof pointsGetOrder>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PointsGetOrderParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof pointsGetOrder>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPointsGetOrderQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGet = (
    params: MaybeRef<UserGetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGet200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/get`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetQueryKey = (params: MaybeRef<UserGetParams>,) => {
    return ['user','get', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetQueryOptions = <TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGet>>> = ({ signal }) => userGet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData> 
}

export type UserGetQueryResult = NonNullable<Awaited<ReturnType<typeof userGet>>>
export type UserGetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGet<TData = Awaited<ReturnType<typeof userGet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userProfile = (
    params: MaybeRef<UserProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/profile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserProfileQueryKey = (params: MaybeRef<UserProfileParams>,) => {
    return ['user','profile', ...(params ? [params]: [])] as const;
    }

    
export const getUserProfileQueryOptions = <TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userProfile>>> = ({ signal }) => userProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData> 
}

export type UserProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userProfile>>>
export type UserProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserProfile<TData = Awaited<ReturnType<typeof userProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userPublicProfile = (
    params: MaybeRef<UserPublicProfileParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPublicProfile200>> => {
    params = unref(params);
    
    return axios.get(
      `/user/publicProfile`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPublicProfileQueryKey = (params: MaybeRef<UserPublicProfileParams>,) => {
    return ['user','publicProfile', ...(params ? [params]: [])] as const;
    }

    
export const getUserPublicProfileQueryOptions = <TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPublicProfileQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPublicProfile>>> = ({ signal }) => userPublicProfile(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData> 
}

export type UserPublicProfileQueryResult = NonNullable<Awaited<ReturnType<typeof userPublicProfile>>>
export type UserPublicProfileQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPublicProfile<TData = Awaited<ReturnType<typeof userPublicProfile>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserPublicProfileParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPublicProfile>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPublicProfileQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetUsername = (
    params: MaybeRef<UserGetUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/getUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserGetUsernameQueryKey = (params: MaybeRef<UserGetUsernameParams>,) => {
    return ['user','getUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserGetUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetUsername>>> = ({ signal }) => userGetUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData> 
}

export type UserGetUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userGetUsername>>>
export type UserGetUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetUsername<TData = Awaited<ReturnType<typeof userGetUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserGetUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetUsername = (
    userSetUsernameBody: MaybeRef<UserSetUsernameBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetUsername200>> => {
    userSetUsernameBody = unref(userSetUsernameBody);
    
    return axios.post(
      `/user/setUsername`,
      userSetUsernameBody,options
    );
  }



export const getUserSetUsernameMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext> => {

const mutationKey = ['userSetUsername'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetUsername>>, {data: UserSetUsernameBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetUsername(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetUsernameMutationResult = NonNullable<Awaited<ReturnType<typeof userSetUsername>>>
    export type UserSetUsernameMutationBody = UserSetUsernameBody
    export type UserSetUsernameMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetUsername = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetUsername>>, TError,{data: UserSetUsernameBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetUsername>>,
        TError,
        {data: UserSetUsernameBody},
        TContext
      > => {

      const mutationOptions = getUserSetUsernameMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetBio = (
    userSetBioBody: MaybeRef<UserSetBioBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetBio200>> => {
    userSetBioBody = unref(userSetBioBody);
    
    return axios.post(
      `/user/setBio`,
      userSetBioBody,options
    );
  }



export const getUserSetBioMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext> => {

const mutationKey = ['userSetBio'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetBio>>, {data: UserSetBioBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetBio(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetBioMutationResult = NonNullable<Awaited<ReturnType<typeof userSetBio>>>
    export type UserSetBioMutationBody = UserSetBioBody
    export type UserSetBioMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetBio = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetBio>>, TError,{data: UserSetBioBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetBio>>,
        TError,
        {data: UserSetBioBody},
        TContext
      > => {

      const mutationOptions = getUserSetBioMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSendVerificationEmail = (
    userSendVerificationEmailBody: MaybeRef<UserSendVerificationEmailBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSendVerificationEmailBody = unref(userSendVerificationEmailBody);
    
    return axios.post(
      `/user/sendVerificationEmail`,
      userSendVerificationEmailBody,options
    );
  }



export const getUserSendVerificationEmailMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext> => {

const mutationKey = ['userSendVerificationEmail'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSendVerificationEmail>>, {data: UserSendVerificationEmailBody}> = (props) => {
          const {data} = props ?? {};

          return  userSendVerificationEmail(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSendVerificationEmailMutationResult = NonNullable<Awaited<ReturnType<typeof userSendVerificationEmail>>>
    export type UserSendVerificationEmailMutationBody = UserSendVerificationEmailBody
    export type UserSendVerificationEmailMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSendVerificationEmail = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSendVerificationEmail>>, TError,{data: UserSendVerificationEmailBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSendVerificationEmail>>,
        TError,
        {data: UserSendVerificationEmailBody},
        TContext
      > => {

      const mutationOptions = getUserSendVerificationEmailMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userPointsHistory = (
    params?: MaybeRef<UserPointsHistoryParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserPointsHistory200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/user/pointsHistory`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserPointsHistoryQueryKey = (params?: MaybeRef<UserPointsHistoryParams>,) => {
    return ['user','pointsHistory', ...(params ? [params]: [])] as const;
    }

    
export const getUserPointsHistoryQueryOptions = <TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserPointsHistoryQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userPointsHistory>>> = ({ signal }) => userPointsHistory(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData> 
}

export type UserPointsHistoryQueryResult = NonNullable<Awaited<ReturnType<typeof userPointsHistory>>>
export type UserPointsHistoryQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserPointsHistory<TData = Awaited<ReturnType<typeof userPointsHistory>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<UserPointsHistoryParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userPointsHistory>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserPointsHistoryQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByUsername = (
    params: MaybeRef<UserFindByUsernameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByUsername`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByUsernameQueryKey = (params: MaybeRef<UserFindByUsernameParams>,) => {
    return ['user','findByUsername', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByUsernameQueryOptions = <TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByUsernameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByUsername>>> = ({ signal }) => userFindByUsername(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData> 
}

export type UserFindByUsernameQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByUsername>>>
export type UserFindByUsernameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByUsername<TData = Awaited<ReturnType<typeof userFindByUsername>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByUsernameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByUsername>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByUsernameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByEmail = (
    params: MaybeRef<UserFindByEmailParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByEmail`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByEmailQueryKey = (params: MaybeRef<UserFindByEmailParams>,) => {
    return ['user','findByEmail', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByEmailQueryOptions = <TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByEmailQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByEmail>>> = ({ signal }) => userFindByEmail(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData> 
}

export type UserFindByEmailQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByEmail>>>
export type UserFindByEmailQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByEmail<TData = Awaited<ReturnType<typeof userFindByEmail>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByEmailParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByEmail>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByEmailQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPhone = (
    params: MaybeRef<UserFindByPhoneParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPhone`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPhoneQueryKey = (params: MaybeRef<UserFindByPhoneParams>,) => {
    return ['user','findByPhone', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPhoneQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPhoneQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPhone>>> = ({ signal }) => userFindByPhone(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData> 
}

export type UserFindByPhoneQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPhone>>>
export type UserFindByPhoneQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPhone<TData = Awaited<ReturnType<typeof userFindByPhone>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPhoneParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPhone>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPhoneQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userFindByPrivyId = (
    params: MaybeRef<UserFindByPrivyIdParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    params = unref(params);
    
    return axios.get(
      `/user/findByPrivyId`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getUserFindByPrivyIdQueryKey = (params: MaybeRef<UserFindByPrivyIdParams>,) => {
    return ['user','findByPrivyId', ...(params ? [params]: [])] as const;
    }

    
export const getUserFindByPrivyIdQueryOptions = <TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserFindByPrivyIdQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userFindByPrivyId>>> = ({ signal }) => userFindByPrivyId(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData> 
}

export type UserFindByPrivyIdQueryResult = NonNullable<Awaited<ReturnType<typeof userFindByPrivyId>>>
export type UserFindByPrivyIdQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserFindByPrivyId<TData = Awaited<ReturnType<typeof userFindByPrivyId>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<UserFindByPrivyIdParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userFindByPrivyId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserFindByPrivyIdQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userGetNotificationConfig = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserGetNotificationConfig200>> => {
    
    
    return axios.get(
      `/user/getNotificationConfig`,options
    );
  }


export const getUserGetNotificationConfigQueryKey = () => {
    return ['user','getNotificationConfig'] as const;
    }

    
export const getUserGetNotificationConfigQueryOptions = <TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserGetNotificationConfigQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userGetNotificationConfig>>> = ({ signal }) => userGetNotificationConfig({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData> 
}

export type UserGetNotificationConfigQueryResult = NonNullable<Awaited<ReturnType<typeof userGetNotificationConfig>>>
export type UserGetNotificationConfigQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserGetNotificationConfig<TData = Awaited<ReturnType<typeof userGetNotificationConfig>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userGetNotificationConfig>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserGetNotificationConfigQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const userSetNotificationConfig = (
    userSetNotificationConfigBody: MaybeRef<UserSetNotificationConfigBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserSetNotificationConfig200>> => {
    userSetNotificationConfigBody = unref(userSetNotificationConfigBody);
    
    return axios.post(
      `/user/setNotificationConfig`,
      userSetNotificationConfigBody,options
    );
  }



export const getUserSetNotificationConfigMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext> => {

const mutationKey = ['userSetNotificationConfig'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetNotificationConfig>>, {data: UserSetNotificationConfigBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetNotificationConfig(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetNotificationConfigMutationResult = NonNullable<Awaited<ReturnType<typeof userSetNotificationConfig>>>
    export type UserSetNotificationConfigMutationBody = UserSetNotificationConfigBody
    export type UserSetNotificationConfigMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetNotificationConfig = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetNotificationConfig>>, TError,{data: UserSetNotificationConfigBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetNotificationConfig>>,
        TError,
        {data: UserSetNotificationConfigBody},
        TContext
      > => {

      const mutationOptions = getUserSetNotificationConfigMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userUnsubscribeEmailNotifications = (
    userUnsubscribeEmailNotificationsBody: MaybeRef<UserUnsubscribeEmailNotificationsBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    userUnsubscribeEmailNotificationsBody = unref(userUnsubscribeEmailNotificationsBody);
    
    return axios.post(
      `/user/unsubscribeEmailNotifications`,
      userUnsubscribeEmailNotificationsBody,options
    );
  }



export const getUserUnsubscribeEmailNotificationsMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext> => {

const mutationKey = ['userUnsubscribeEmailNotifications'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, {data: UserUnsubscribeEmailNotificationsBody}> = (props) => {
          const {data} = props ?? {};

          return  userUnsubscribeEmailNotifications(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserUnsubscribeEmailNotificationsMutationResult = NonNullable<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>>
    export type UserUnsubscribeEmailNotificationsMutationBody = UserUnsubscribeEmailNotificationsBody
    export type UserUnsubscribeEmailNotificationsMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserUnsubscribeEmailNotifications = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>, TError,{data: UserUnsubscribeEmailNotificationsBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userUnsubscribeEmailNotifications>>,
        TError,
        {data: UserUnsubscribeEmailNotificationsBody},
        TContext
      > => {

      const mutationOptions = getUserUnsubscribeEmailNotificationsMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userSetAvatar = (
    userSetAvatarBody: MaybeRef<UserSetAvatarBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    userSetAvatarBody = unref(userSetAvatarBody);
    
    return axios.post(
      `/user/setAvatar`,
      userSetAvatarBody,options
    );
  }



export const getUserSetAvatarMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext> => {

const mutationKey = ['userSetAvatar'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof userSetAvatar>>, {data: UserSetAvatarBody}> = (props) => {
          const {data} = props ?? {};

          return  userSetAvatar(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UserSetAvatarMutationResult = NonNullable<Awaited<ReturnType<typeof userSetAvatar>>>
    export type UserSetAvatarMutationBody = UserSetAvatarBody
    export type UserSetAvatarMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useUserSetAvatar = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof userSetAvatar>>, TError,{data: UserSetAvatarBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof userSetAvatar>>,
        TError,
        {data: UserSetAvatarBody},
        TContext
      > => {

      const mutationOptions = getUserSetAvatarMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const userAllUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserAllUsers200Item[]>> => {
    
    
    return axios.get(
      `/user/allUsers`,options
    );
  }


export const getUserAllUsersQueryKey = () => {
    return ['user','allUsers'] as const;
    }

    
export const getUserAllUsersQueryOptions = <TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getUserAllUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof userAllUsers>>> = ({ signal }) => userAllUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData> 
}

export type UserAllUsersQueryResult = NonNullable<Awaited<ReturnType<typeof userAllUsers>>>
export type UserAllUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useUserAllUsers<TData = Awaited<ReturnType<typeof userAllUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof userAllUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUserAllUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const loginLinkInitLoginLink = (
    loginLinkInitLoginLinkBody: MaybeRef<LoginLinkInitLoginLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    loginLinkInitLoginLinkBody = unref(loginLinkInitLoginLinkBody);
    
    return axios.post(
      `/loginLink/initLoginLink`,
      loginLinkInitLoginLinkBody,options
    );
  }



export const getLoginLinkInitLoginLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext> => {

const mutationKey = ['loginLinkInitLoginLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, {data: LoginLinkInitLoginLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkInitLoginLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkInitLoginLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkInitLoginLink>>>
    export type LoginLinkInitLoginLinkMutationBody = LoginLinkInitLoginLinkBody
    export type LoginLinkInitLoginLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkInitLoginLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkInitLoginLink>>, TError,{data: LoginLinkInitLoginLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkInitLoginLink>>,
        TError,
        {data: LoginLinkInitLoginLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkInitLoginLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const loginLinkLoginWithLink = (
    loginLinkLoginWithLinkBody: MaybeRef<LoginLinkLoginWithLinkBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<LoginLinkLoginWithLink200>> => {
    loginLinkLoginWithLinkBody = unref(loginLinkLoginWithLinkBody);
    
    return axios.post(
      `/loginLink/loginWithLink`,
      loginLinkLoginWithLinkBody,options
    );
  }



export const getLoginLinkLoginWithLinkMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext> => {

const mutationKey = ['loginLinkLoginWithLink'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, {data: LoginLinkLoginWithLinkBody}> = (props) => {
          const {data} = props ?? {};

          return  loginLinkLoginWithLink(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLinkLoginWithLinkMutationResult = NonNullable<Awaited<ReturnType<typeof loginLinkLoginWithLink>>>
    export type LoginLinkLoginWithLinkMutationBody = LoginLinkLoginWithLinkBody
    export type LoginLinkLoginWithLinkMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useLoginLinkLoginWithLink = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLinkLoginWithLink>>, TError,{data: LoginLinkLoginWithLinkBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof loginLinkLoginWithLink>>,
        TError,
        {data: LoginLinkLoginWithLinkBody},
        TContext
      > => {

      const mutationOptions = getLoginLinkLoginWithLinkMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const statsUsers = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsUsers200>> => {
    
    
    return axios.get(
      `/stats/users`,options
    );
  }


export const getStatsUsersQueryKey = () => {
    return ['stats','users'] as const;
    }

    
export const getStatsUsersQueryOptions = <TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsUsersQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsUsers>>> = ({ signal }) => statsUsers({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData> 
}

export type StatsUsersQueryResult = NonNullable<Awaited<ReturnType<typeof statsUsers>>>
export type StatsUsersQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsUsers<TData = Awaited<ReturnType<typeof statsUsers>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsUsers>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsUsersQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsImages = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsImages200>> => {
    
    
    return axios.get(
      `/stats/images`,options
    );
  }


export const getStatsImagesQueryKey = () => {
    return ['stats','images'] as const;
    }

    
export const getStatsImagesQueryOptions = <TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsImagesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsImages>>> = ({ signal }) => statsImages({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData> 
}

export type StatsImagesQueryResult = NonNullable<Awaited<ReturnType<typeof statsImages>>>
export type StatsImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsImages<TData = Awaited<ReturnType<typeof statsImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsImagesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsCollections = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsCollections200>> => {
    
    
    return axios.get(
      `/stats/collections`,options
    );
  }


export const getStatsCollectionsQueryKey = () => {
    return ['stats','collections'] as const;
    }

    
export const getStatsCollectionsQueryOptions = <TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsCollectionsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsCollections>>> = ({ signal }) => statsCollections({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData> 
}

export type StatsCollectionsQueryResult = NonNullable<Awaited<ReturnType<typeof statsCollections>>>
export type StatsCollectionsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsCollections<TData = Awaited<ReturnType<typeof statsCollections>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsCollections>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsCollectionsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const statsPayments = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<StatsPayments200>> => {
    
    
    return axios.get(
      `/stats/payments`,options
    );
  }


export const getStatsPaymentsQueryKey = () => {
    return ['stats','payments'] as const;
    }

    
export const getStatsPaymentsQueryOptions = <TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getStatsPaymentsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof statsPayments>>> = ({ signal }) => statsPayments({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData> 
}

export type StatsPaymentsQueryResult = NonNullable<Awaited<ReturnType<typeof statsPayments>>>
export type StatsPaymentsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useStatsPayments<TData = Awaited<ReturnType<typeof statsPayments>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof statsPayments>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getStatsPaymentsQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsMediaInUsersCollection = (
    params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/mediaInUsersCollection`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsMediaInUsersCollectionQueryKey = (params: MaybeRef<CollectionsMediaInUsersCollectionParams>,) => {
    return ['collections','mediaInUsersCollection', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsMediaInUsersCollectionQueryOptions = <TData = Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsMediaInUsersCollectionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>> = ({ signal }) => collectionsMediaInUsersCollection(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData> 
}

export type CollectionsMediaInUsersCollectionQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>>
export type CollectionsMediaInUsersCollectionQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsMediaInUsersCollection<TData = Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsMediaInUsersCollectionParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsMediaInUsersCollection>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsMediaInUsersCollectionQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsLikeMedia = (
    collectionsLikeMediaBody: MaybeRef<CollectionsLikeMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsLikeMediaBody = unref(collectionsLikeMediaBody);
    
    return axios.post(
      `/collections/likeMedia`,
      collectionsLikeMediaBody,options
    );
  }



export const getCollectionsLikeMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext> => {

const mutationKey = ['collectionsLikeMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsLikeMedia>>, {data: CollectionsLikeMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsLikeMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsLikeMediaMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsLikeMedia>>>
    export type CollectionsLikeMediaMutationBody = CollectionsLikeMediaBody
    export type CollectionsLikeMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsLikeMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsLikeMedia>>, TError,{data: CollectionsLikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsLikeMedia>>,
        TError,
        {data: CollectionsLikeMediaBody},
        TContext
      > => {

      const mutationOptions = getCollectionsLikeMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsUnlikeMedia = (
    collectionsUnlikeMediaBody: MaybeRef<CollectionsUnlikeMediaBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<boolean>> => {
    collectionsUnlikeMediaBody = unref(collectionsUnlikeMediaBody);
    
    return axios.post(
      `/collections/unlikeMedia`,
      collectionsUnlikeMediaBody,options
    );
  }



export const getCollectionsUnlikeMediaMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext> => {

const mutationKey = ['collectionsUnlikeMedia'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, {data: CollectionsUnlikeMediaBody}> = (props) => {
          const {data} = props ?? {};

          return  collectionsUnlikeMedia(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CollectionsUnlikeMediaMutationResult = NonNullable<Awaited<ReturnType<typeof collectionsUnlikeMedia>>>
    export type CollectionsUnlikeMediaMutationBody = CollectionsUnlikeMediaBody
    export type CollectionsUnlikeMediaMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useCollectionsUnlikeMedia = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof collectionsUnlikeMedia>>, TError,{data: CollectionsUnlikeMediaBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof collectionsUnlikeMedia>>,
        TError,
        {data: CollectionsUnlikeMediaBody},
        TContext
      > => {

      const mutationOptions = getCollectionsUnlikeMediaMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const collectionsGetCollectionMeta = (
    params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionMeta200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionMeta`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionMetaQueryKey = (params: MaybeRef<CollectionsGetCollectionMetaParams>,) => {
    return ['collections','getCollectionMeta', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionMetaQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionMetaQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>> = ({ signal }) => collectionsGetCollectionMeta(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData> 
}

export type CollectionsGetCollectionMetaQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>>
export type CollectionsGetCollectionMetaQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionMeta<TData = Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionMetaParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionMeta>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionMetaQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsFindCollectionByName = (
    params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsFindCollectionByName200>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/findCollectionByName`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsFindCollectionByNameQueryKey = (params: MaybeRef<CollectionsFindCollectionByNameParams>,) => {
    return ['collections','findCollectionByName', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsFindCollectionByNameQueryOptions = <TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsFindCollectionByNameQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsFindCollectionByName>>> = ({ signal }) => collectionsFindCollectionByName(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData> 
}

export type CollectionsFindCollectionByNameQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsFindCollectionByName>>>
export type CollectionsFindCollectionByNameQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsFindCollectionByName<TData = Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsFindCollectionByNameParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsFindCollectionByName>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsFindCollectionByNameQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionImages = (
    params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionImages200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionImages`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionImagesQueryKey = (params: MaybeRef<CollectionsGetCollectionImagesParams>,) => {
    return ['collections','getCollectionImages', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionImagesQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionImagesQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionImages>>> = ({ signal }) => collectionsGetCollectionImages(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData> 
}

export type CollectionsGetCollectionImagesQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionImages>>>
export type CollectionsGetCollectionImagesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionImages<TData = Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionImagesParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionImages>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionImagesQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const collectionsGetCollectionVideos = (
    params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<CollectionsGetCollectionVideos200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/collections/getCollectionVideos`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getCollectionsGetCollectionVideosQueryKey = (params: MaybeRef<CollectionsGetCollectionVideosParams>,) => {
    return ['collections','getCollectionVideos', ...(params ? [params]: [])] as const;
    }

    
export const getCollectionsGetCollectionVideosQueryOptions = <TData = Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getCollectionsGetCollectionVideosQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>> = ({ signal }) => collectionsGetCollectionVideos(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData> 
}

export type CollectionsGetCollectionVideosQueryResult = NonNullable<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>>
export type CollectionsGetCollectionVideosQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useCollectionsGetCollectionVideos<TData = Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<CollectionsGetCollectionVideosParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof collectionsGetCollectionVideos>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getCollectionsGetCollectionVideosQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoCreatePromoCode = (
    promoCreatePromoCodeBody: MaybeRef<PromoCreatePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoCreatePromoCode200>> => {
    promoCreatePromoCodeBody = unref(promoCreatePromoCodeBody);
    
    return axios.post(
      `/promo/createPromoCode`,
      promoCreatePromoCodeBody,options
    );
  }



export const getPromoCreatePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext> => {

const mutationKey = ['promoCreatePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoCreatePromoCode>>, {data: PromoCreatePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoCreatePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoCreatePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoCreatePromoCode>>>
    export type PromoCreatePromoCodeMutationBody = PromoCreatePromoCodeBody
    export type PromoCreatePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoCreatePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoCreatePromoCode>>, TError,{data: PromoCreatePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoCreatePromoCode>>,
        TError,
        {data: PromoCreatePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoCreatePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoDeletePromoCode = (
    promoDeletePromoCodeBody: MaybeRef<PromoDeletePromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoDeletePromoCodeBody = unref(promoDeletePromoCodeBody);
    
    return axios.post(
      `/promo/deletePromoCode`,
      promoDeletePromoCodeBody,options
    );
  }



export const getPromoDeletePromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext> => {

const mutationKey = ['promoDeletePromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoDeletePromoCode>>, {data: PromoDeletePromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoDeletePromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoDeletePromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoDeletePromoCode>>>
    export type PromoDeletePromoCodeMutationBody = PromoDeletePromoCodeBody
    export type PromoDeletePromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoDeletePromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoDeletePromoCode>>, TError,{data: PromoDeletePromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoDeletePromoCode>>,
        TError,
        {data: PromoDeletePromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoDeletePromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const promoGetPromoCodes = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodes200Item[]>> => {
    
    
    return axios.get(
      `/promo/getPromoCodes`,options
    );
  }


export const getPromoGetPromoCodesQueryKey = () => {
    return ['promo','getPromoCodes'] as const;
    }

    
export const getPromoGetPromoCodesQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodesQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodes>>> = ({ signal }) => promoGetPromoCodes({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData> 
}

export type PromoGetPromoCodesQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodes>>>
export type PromoGetPromoCodesQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodes<TData = Awaited<ReturnType<typeof promoGetPromoCodes>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodes>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodesQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoGetPromoCodeDetails = (
    params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PromoGetPromoCodeDetails200>> => {
    params = unref(params);
    
    return axios.get(
      `/promo/getPromoCodeDetails`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getPromoGetPromoCodeDetailsQueryKey = (params: MaybeRef<PromoGetPromoCodeDetailsParams>,) => {
    return ['promo','getPromoCodeDetails', ...(params ? [params]: [])] as const;
    }

    
export const getPromoGetPromoCodeDetailsQueryOptions = <TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getPromoGetPromoCodeDetailsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>> = ({ signal }) => promoGetPromoCodeDetails(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData> 
}

export type PromoGetPromoCodeDetailsQueryResult = NonNullable<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>>
export type PromoGetPromoCodeDetailsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function usePromoGetPromoCodeDetails<TData = Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<PromoGetPromoCodeDetailsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof promoGetPromoCodeDetails>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getPromoGetPromoCodeDetailsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const promoClaimPromoCode = (
    promoClaimPromoCodeBody: MaybeRef<PromoClaimPromoCodeBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    promoClaimPromoCodeBody = unref(promoClaimPromoCodeBody);
    
    return axios.post(
      `/promo/claimPromoCode`,
      promoClaimPromoCodeBody,options
    );
  }



export const getPromoClaimPromoCodeMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext> => {

const mutationKey = ['promoClaimPromoCode'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof promoClaimPromoCode>>, {data: PromoClaimPromoCodeBody}> = (props) => {
          const {data} = props ?? {};

          return  promoClaimPromoCode(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PromoClaimPromoCodeMutationResult = NonNullable<Awaited<ReturnType<typeof promoClaimPromoCode>>>
    export type PromoClaimPromoCodeMutationBody = PromoClaimPromoCodeBody
    export type PromoClaimPromoCodeMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePromoClaimPromoCode = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof promoClaimPromoCode>>, TError,{data: PromoClaimPromoCodeBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof promoClaimPromoCode>>,
        TError,
        {data: PromoClaimPromoCodeBody},
        TContext
      > => {

      const mutationOptions = getPromoClaimPromoCodeMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsEditModel = (
    modelsEditModelBody: MaybeRef<ModelsEditModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsEditModelBody = unref(modelsEditModelBody);
    
    return axios.post(
      `/models/editModel`,
      modelsEditModelBody,options
    );
  }



export const getModelsEditModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext> => {

const mutationKey = ['modelsEditModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsEditModel>>, {data: ModelsEditModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsEditModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsEditModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsEditModel>>>
    export type ModelsEditModelMutationBody = ModelsEditModelBody
    export type ModelsEditModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsEditModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsEditModel>>, TError,{data: ModelsEditModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsEditModel>>,
        TError,
        {data: ModelsEditModelBody},
        TContext
      > => {

      const mutationOptions = getModelsEditModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetUserModels = (
    params?: MaybeRef<ModelsGetUserModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetUserModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getUserModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetUserModelsQueryKey = (params?: MaybeRef<ModelsGetUserModelsParams>,) => {
    return ['models','getUserModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetUserModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetUserModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetUserModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetUserModels>>> = ({ signal }) => modelsGetUserModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData> 
}

export type ModelsGetUserModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetUserModels>>>
export type ModelsGetUserModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetUserModels<TData = Awaited<ReturnType<typeof modelsGetUserModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetUserModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetUserModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetUserModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsCreateModel = (
    modelsCreateModelBody: MaybeRef<ModelsCreateModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    modelsCreateModelBody = unref(modelsCreateModelBody);
    
    return axios.post(
      `/models/createModel`,
      modelsCreateModelBody,options
    );
  }



export const getModelsCreateModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext> => {

const mutationKey = ['modelsCreateModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsCreateModel>>, {data: ModelsCreateModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsCreateModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsCreateModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsCreateModel>>>
    export type ModelsCreateModelMutationBody = ModelsCreateModelBody
    export type ModelsCreateModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsCreateModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsCreateModel>>, TError,{data: ModelsCreateModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsCreateModel>>,
        TError,
        {data: ModelsCreateModelBody},
        TContext
      > => {

      const mutationOptions = getModelsCreateModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetTrainingStatus = (
    params: MaybeRef<ModelsGetTrainingStatusParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetTrainingStatus200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getTrainingStatus`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetTrainingStatusQueryKey = (params: MaybeRef<ModelsGetTrainingStatusParams>,) => {
    return ['models','getTrainingStatus', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetTrainingStatusQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetTrainingStatusQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetTrainingStatus>>> = ({ signal }) => modelsGetTrainingStatus(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData> 
}

export type ModelsGetTrainingStatusQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetTrainingStatus>>>
export type ModelsGetTrainingStatusQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetTrainingStatus<TData = Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetTrainingStatusParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetTrainingStatus>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetTrainingStatusQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsDeleteModel = (
    modelsDeleteModelBody: MaybeRef<ModelsDeleteModelBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsDeleteModelBody = unref(modelsDeleteModelBody);
    
    return axios.post(
      `/models/deleteModel`,
      modelsDeleteModelBody,options
    );
  }



export const getModelsDeleteModelMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext> => {

const mutationKey = ['modelsDeleteModel'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsDeleteModel>>, {data: ModelsDeleteModelBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsDeleteModel(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsDeleteModelMutationResult = NonNullable<Awaited<ReturnType<typeof modelsDeleteModel>>>
    export type ModelsDeleteModelMutationBody = ModelsDeleteModelBody
    export type ModelsDeleteModelMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsDeleteModel = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsDeleteModel>>, TError,{data: ModelsDeleteModelBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsDeleteModel>>,
        TError,
        {data: ModelsDeleteModelBody},
        TContext
      > => {

      const mutationOptions = getModelsDeleteModelMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const modelsGetCustomModel = (
    params: MaybeRef<ModelsGetCustomModelParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetCustomModel200>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getCustomModel`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetCustomModelQueryKey = (params: MaybeRef<ModelsGetCustomModelParams>,) => {
    return ['models','getCustomModel', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetCustomModelQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetCustomModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<ModelsGetCustomModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetCustomModelQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetCustomModel>>> = ({ signal }) => modelsGetCustomModel(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData> 
}

export type ModelsGetCustomModelQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetCustomModel>>>
export type ModelsGetCustomModelQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetCustomModel<TData = Awaited<ReturnType<typeof modelsGetCustomModel>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<ModelsGetCustomModelParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetCustomModel>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetCustomModelQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsGetPublicModels = (
    params?: MaybeRef<ModelsGetPublicModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetPublicModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getPublicModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetPublicModelsQueryKey = (params?: MaybeRef<ModelsGetPublicModelsParams>,) => {
    return ['models','getPublicModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetPublicModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetPublicModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetPublicModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetPublicModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetPublicModels>>> = ({ signal }) => modelsGetPublicModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData> 
}

export type ModelsGetPublicModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetPublicModels>>>
export type ModelsGetPublicModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetPublicModels<TData = Awaited<ReturnType<typeof modelsGetPublicModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetPublicModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetPublicModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetPublicModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsGetBaseModels = (
    params?: MaybeRef<ModelsGetBaseModelsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<ModelsGetBaseModels200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/models/getBaseModels`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getModelsGetBaseModelsQueryKey = (params?: MaybeRef<ModelsGetBaseModelsParams>,) => {
    return ['models','getBaseModels', ...(params ? [params]: [])] as const;
    }

    
export const getModelsGetBaseModelsQueryOptions = <TData = Awaited<ReturnType<typeof modelsGetBaseModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params?: MaybeRef<ModelsGetBaseModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getModelsGetBaseModelsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof modelsGetBaseModels>>> = ({ signal }) => modelsGetBaseModels(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData> 
}

export type ModelsGetBaseModelsQueryResult = NonNullable<Awaited<ReturnType<typeof modelsGetBaseModels>>>
export type ModelsGetBaseModelsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useModelsGetBaseModels<TData = Awaited<ReturnType<typeof modelsGetBaseModels>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params?: MaybeRef<ModelsGetBaseModelsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof modelsGetBaseModels>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getModelsGetBaseModelsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const modelsSetModelPrivacy = (
    modelsSetModelPrivacyBody: MaybeRef<ModelsSetModelPrivacyBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    modelsSetModelPrivacyBody = unref(modelsSetModelPrivacyBody);
    
    return axios.post(
      `/models/setModelPrivacy`,
      modelsSetModelPrivacyBody,options
    );
  }



export const getModelsSetModelPrivacyMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext> => {

const mutationKey = ['modelsSetModelPrivacy'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, {data: ModelsSetModelPrivacyBody}> = (props) => {
          const {data} = props ?? {};

          return  modelsSetModelPrivacy(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ModelsSetModelPrivacyMutationResult = NonNullable<Awaited<ReturnType<typeof modelsSetModelPrivacy>>>
    export type ModelsSetModelPrivacyMutationBody = ModelsSetModelPrivacyBody
    export type ModelsSetModelPrivacyMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useModelsSetModelPrivacy = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof modelsSetModelPrivacy>>, TError,{data: ModelsSetModelPrivacyBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof modelsSetModelPrivacy>>,
        TError,
        {data: ModelsSetModelPrivacyBody},
        TContext
      > => {

      const mutationOptions = getModelsSetModelPrivacyMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const adminLoginAsUser = (
    adminLoginAsUserBody: MaybeRef<AdminLoginAsUserBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<string>> => {
    adminLoginAsUserBody = unref(adminLoginAsUserBody);
    
    return axios.post(
      `/admin/loginAsUser`,
      adminLoginAsUserBody,options
    );
  }



export const getAdminLoginAsUserMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext> => {

const mutationKey = ['adminLoginAsUser'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof adminLoginAsUser>>, {data: AdminLoginAsUserBody}> = (props) => {
          const {data} = props ?? {};

          return  adminLoginAsUser(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type AdminLoginAsUserMutationResult = NonNullable<Awaited<ReturnType<typeof adminLoginAsUser>>>
    export type AdminLoginAsUserMutationBody = AdminLoginAsUserBody
    export type AdminLoginAsUserMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useAdminLoginAsUser = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof adminLoginAsUser>>, TError,{data: AdminLoginAsUserBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof adminLoginAsUser>>,
        TError,
        {data: AdminLoginAsUserBody},
        TContext
      > => {

      const mutationOptions = getAdminLoginAsUserMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const privyAuthenticate = (
    privyAuthenticateBody: MaybeRef<PrivyAuthenticateBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PrivyAuthenticate200>> => {
    privyAuthenticateBody = unref(privyAuthenticateBody);
    
    return axios.post(
      `/privy/authenticate`,
      privyAuthenticateBody,options
    );
  }



export const getPrivyAuthenticateMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext> => {

const mutationKey = ['privyAuthenticate'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof privyAuthenticate>>, {data: PrivyAuthenticateBody}> = (props) => {
          const {data} = props ?? {};

          return  privyAuthenticate(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PrivyAuthenticateMutationResult = NonNullable<Awaited<ReturnType<typeof privyAuthenticate>>>
    export type PrivyAuthenticateMutationBody = PrivyAuthenticateBody
    export type PrivyAuthenticateMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const usePrivyAuthenticate = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof privyAuthenticate>>, TError,{data: PrivyAuthenticateBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof privyAuthenticate>>,
        TError,
        {data: PrivyAuthenticateBody},
        TContext
      > => {

      const mutationOptions = getPrivyAuthenticateMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsCreateSet = (
    trainingSetsCreateSetBody: MaybeRef<TrainingSetsCreateSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsCreateSet200>> => {
    trainingSetsCreateSetBody = unref(trainingSetsCreateSetBody);
    
    return axios.post(
      `/trainingSets/createSet`,
      trainingSetsCreateSetBody,options
    );
  }



export const getTrainingSetsCreateSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext> => {

const mutationKey = ['trainingSetsCreateSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsCreateSet>>, {data: TrainingSetsCreateSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsCreateSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsCreateSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsCreateSet>>>
    export type TrainingSetsCreateSetMutationBody = TrainingSetsCreateSetBody
    export type TrainingSetsCreateSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsCreateSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsCreateSet>>, TError,{data: TrainingSetsCreateSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsCreateSet>>,
        TError,
        {data: TrainingSetsCreateSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsCreateSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsFinalizeSet = (
    trainingSetsFinalizeSetBody: MaybeRef<TrainingSetsFinalizeSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsFinalizeSetBody = unref(trainingSetsFinalizeSetBody);
    
    return axios.post(
      `/trainingSets/finalizeSet`,
      trainingSetsFinalizeSetBody,options
    );
  }



export const getTrainingSetsFinalizeSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext> => {

const mutationKey = ['trainingSetsFinalizeSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, {data: TrainingSetsFinalizeSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsFinalizeSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsFinalizeSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>>
    export type TrainingSetsFinalizeSetMutationBody = TrainingSetsFinalizeSetBody
    export type TrainingSetsFinalizeSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsFinalizeSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsFinalizeSet>>, TError,{data: TrainingSetsFinalizeSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsFinalizeSet>>,
        TError,
        {data: TrainingSetsFinalizeSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsFinalizeSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsGetUserSets = (
    params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetUserSets200Item[]>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getUserSets`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetUserSetsQueryKey = (params: MaybeRef<TrainingSetsGetUserSetsParams>,) => {
    return ['trainingSets','getUserSets', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetUserSetsQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetUserSetsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetUserSets>>> = ({ signal }) => trainingSetsGetUserSets(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData> 
}

export type TrainingSetsGetUserSetsQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetUserSets>>>
export type TrainingSetsGetUserSetsQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetUserSets<TData = Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetUserSetsParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetUserSets>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetUserSetsQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsGetSet = (
    params: MaybeRef<TrainingSetsGetSetParams>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TrainingSetsGetSet200>> => {
    params = unref(params);
    
    return axios.get(
      `/trainingSets/getSet`,{
    ...options,
        params: {...unref(params), ...options?.params},}
    );
  }


export const getTrainingSetsGetSetQueryKey = (params: MaybeRef<TrainingSetsGetSetParams>,) => {
    return ['trainingSets','getSet', ...(params ? [params]: [])] as const;
    }

    
export const getTrainingSetsGetSetQueryOptions = <TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  getTrainingSetsGetSetQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof trainingSetsGetSet>>> = ({ signal }) => trainingSetsGetSet(params, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData> 
}

export type TrainingSetsGetSetQueryResult = NonNullable<Awaited<ReturnType<typeof trainingSetsGetSet>>>
export type TrainingSetsGetSetQueryError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>



export function useTrainingSetsGetSet<TData = Awaited<ReturnType<typeof trainingSetsGetSet>>, TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorNOTFOUND | ErrorINTERNALSERVERERROR>>(
 params: MaybeRef<TrainingSetsGetSetParams>, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof trainingSetsGetSet>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ): UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getTrainingSetsGetSetQueryOptions(params,options)

  const query = useQuery(queryOptions , queryClient) as UseQueryReturnType<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<QueryKey, TData, TError>;

  return query;
}




export const trainingSetsDeleteSet = (
    trainingSetsDeleteSetBody: MaybeRef<TrainingSetsDeleteSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsDeleteSetBody = unref(trainingSetsDeleteSetBody);
    
    return axios.post(
      `/trainingSets/deleteSet`,
      trainingSetsDeleteSetBody,options
    );
  }



export const getTrainingSetsDeleteSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext> => {

const mutationKey = ['trainingSetsDeleteSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, {data: TrainingSetsDeleteSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsDeleteSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsDeleteSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsDeleteSet>>>
    export type TrainingSetsDeleteSetMutationBody = TrainingSetsDeleteSetBody
    export type TrainingSetsDeleteSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsDeleteSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsDeleteSet>>, TError,{data: TrainingSetsDeleteSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsDeleteSet>>,
        TError,
        {data: TrainingSetsDeleteSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsDeleteSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
export const trainingSetsEditSet = (
    trainingSetsEditSetBody: MaybeRef<TrainingSetsEditSetBody>, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<unknown>> => {
    trainingSetsEditSetBody = unref(trainingSetsEditSetBody);
    
    return axios.post(
      `/trainingSets/editSet`,
      trainingSetsEditSetBody,options
    );
  }



export const getTrainingSetsEditSetMutationOptions = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext> => {

const mutationKey = ['trainingSetsEditSet'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof trainingSetsEditSet>>, {data: TrainingSetsEditSetBody}> = (props) => {
          const {data} = props ?? {};

          return  trainingSetsEditSet(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type TrainingSetsEditSetMutationResult = NonNullable<Awaited<ReturnType<typeof trainingSetsEditSet>>>
    export type TrainingSetsEditSetMutationBody = TrainingSetsEditSetBody
    export type TrainingSetsEditSetMutationError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>

    export const useTrainingSetsEditSet = <TError = AxiosError<ErrorBADREQUEST | ErrorUNAUTHORIZED | ErrorFORBIDDEN | ErrorINTERNALSERVERERROR>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof trainingSetsEditSet>>, TError,{data: TrainingSetsEditSetBody}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationReturnType<
        Awaited<ReturnType<typeof trainingSetsEditSet>>,
        TError,
        {data: TrainingSetsEditSetBody},
        TContext
      > => {

      const mutationOptions = getTrainingSetsEditSetMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
